// 桥接模式
//Abstraction.h
#ifndef _ABSTRACTION_H_
#define _ABSTRACTION_H_
class AbstractionImp; 

class Abstraction 
{ 
public: 
virtual ~Abstraction(); 
virtual void Operation() = 0; 
protected: 
Abstraction();
private: 
}; 

class RefinedAbstraction:public Abstraction 
{ 
public: 
RefinedAbstraction(AbstractionImp* imp); 
~RefinedAbstraction(); 
void Operation();
protected: 
private: 
AbstractionImp* _imp; //
}; 
#endif //~_ABSTRACTION_H_

//Abstraction.cpp 
#include "Abstraction.h" 
#include "AbstractionImp.h" 
#include <iostream> 
using namespace std; 
Abstraction::Abstraction() 
{ 
} 
Abstraction::~Abstraction() 
{ 
} 
RefinedAbstraction::RefinedAbstraction(AbstractionImp* imp)
{ 
_imp = imp; 
} 
RefinedAbstraction::~RefinedAbstraction() 
{ 
} 
void RefinedAbstraction::Operation() 
{ 
 _imp->Operation(); 
} 

//AbstractionImp.h 
#ifndef _ABSTRACTIONIMP_H_ 
#define _ABSTRACTIONIMP_H_ 
class AbstractionImp 
{ 
public: 
virtual ~AbstractionImp(); 
virtual void Operation() = 0; 
protected: 
AbstractionImp(); 
private: 
}; 

class ConcreteAbstractionImpA:public AbstractionImp
{ 
public: 
ConcreteAbstractionImpA(); 
~ConcreteAbstractionImpA(); 
virtual void Operation();
protected: 
private: 
}; 

class ConcreteAbstractionImpB:public AbstractionImp
{ 
public: 
ConcreteAbstractionImpB(); 
~ConcreteAbstractionImpB(); 
virtual void Operation();
protected: 
private: 
}; 
#endif //~_ABSTRACTIONIMP_H_ 

//AbstractionImp.cpp 
#include "AbstractionImp.h" 
#include <iostream> 
using namespace std; 
AbstractionImp::AbstractionImp() 
{ 
} 
AbstractionImp::~AbstractionImp() 
{ 
} 
void AbstractionImp::Operation() 
{ 
 cout<<"AbstractionImp....imp..."<<endl; 
} 
ConcreteAbstractionImpA::ConcreteAbstractionImpA() 
{ 
} 
ConcreteAbstractionImpA::~ConcreteAbstractionImpA() 
{ 
} 
void ConcreteAbstractionImpA::Operation() 
{ 
 cout<<"ConcreteAbstractionImpA...."<<endl; 
} 
ConcreteAbstractionImpB::ConcreteAbstractionImpB() 
{ 
} 
ConcreteAbstractionImpB::~ConcreteAbstractionImpB() 
{ 
} 
void ConcreteAbstractionImpB::Operation() 
{ 
 cout<<"ConcreteAbstractionImpB...."<<endl; 
}

//main.cpp 
#include "Abstraction.h" 
#include "AbstractionImp.h" 
#include <iostream> 
using namespace std; 
int main(int argc,char* argv[])
{ 
AbstractionImp* imp = new ConcreteAbstractionImpA(); 
Abstraction* abs = new RefinedAbstraction(imp); 
abs->Operation(); 
 
 return 0;
}

#include <bits/stdc++.h>

//
//桥接模式
//关键代码：将实现独立出来，抽象类依赖现实类。
//以下示例中，将各类App、各类手机独立开来，实现各种App和各种手机的自由桥接/组合
//


//抽象App类，提供接口
class App {
public:
    virtual ~App() = default;

    virtual void run() = 0;
};

//具体的App实现类
class GameApp : public App {
public:
    void run() override {
        std::cout << "GameApp Running" << std::endl;
    }
};

//具体的App实现类
class TranslateApp : public App {
public:
    void run() override {
        std::cout << "TranslateApp Running" << std::endl;
    }
};

//抽象手机类，提供接口
class MobilePhone {
public:
    virtual ~MobilePhone() = default;

    //构造函数不能定义为虚函数.有兴趣的可以思考一下why.
    MobilePhone(const std::shared_ptr<App> pApp) : m_pApp(pApp) {}

    virtual void appRun() = 0;

protected:
    //由于继承类要使用该对象,因此不能定义为private类型
    std::shared_ptr<App> m_pApp;//持有一个实现的引用.类通过该对象实现app与手机的桥接
};

//具体的手机实现类
class XiaoMi : public MobilePhone {
public:
    XiaoMi(const std::shared_ptr<App> pApp) : MobilePhone(pApp) {}

    void appRun() override {
        std::cout << "XiaoMi: ";
        m_pApp->run();
    }
};

//具体的手机实现类
class HuaWei : public MobilePhone {
public:
    HuaWei(const std::shared_ptr<App> pApp) : MobilePhone(pApp) {}

    void appRun() override {
        std::cout << "HuaWei: ";
        m_pApp->run();
    }
};

int main() {
    std::shared_ptr<App> pGameApp = std::make_shared<GameApp>();//实现部分
    std::shared_ptr<MobilePhone> pXiaoMi = std::make_shared<XiaoMi>(pGameApp);//抽象部分
    pXiaoMi->appRun();

    std::shared_ptr<App> pTranslateApp = std::make_shared<TranslateApp>();//实现部分
    pXiaoMi = std::make_shared<XiaoMi>(pTranslateApp);//抽象部分
    pXiaoMi->appRun();

    std::cout << std::string(50, '-') << std::endl;

    std::shared_ptr<MobilePhone> pHuaWei = std::make_shared<HuaWei>(pGameApp);
    pHuaWei->appRun();

    pHuaWei = std::make_shared<HuaWei>(pTranslateApp);
    pHuaWei->appRun();

    return 0;
    //运行结果:
    //XiaoMi: GameApp Running
    //XiaoMi: TranslateApp Running
    //--------------------------------------------------
    //HuaWei: GameApp Running
    //HuaWei: TranslateApp Running
}

