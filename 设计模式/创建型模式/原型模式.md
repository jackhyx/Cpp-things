*Prototype  模式*

#### 总结：

* Builder 模式的关键是其中的 Director对象并不直接返回对象，而是通过一步步（BuildPartA，BuildPartB，BuildPartC）来一步步进行对象的创建。
* Builder 模式的示例代码中，BuildPart 的参数是通过客户程序员传入的，这里使用“user-defined”代替，实际的可在 Construct 方法中传入这 3 个参数，这样就可以得到不同的细微差别的复杂对象了。
* Builder 模式和 AbstractFactory 模式在功能上很相似，因为都是用来创建大的复杂的对象，它们的区别是Builder 模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结果对象，一般来说 Builder 模式中对象不是直接返回的。而在 AbstractFactory 模式中对象是直接返回的，AbstractFactory 模式强调的是为创建多个相互依赖的对象提供一个同一的接口。



#### 定义：
Prototype 模式也正是提供了自我复制的功能，就是说新对象的创建可以通过已有对象进行创建。

* 浅拷贝：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
* 深拷贝：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的
*
#### 功能：
Prototype 模式提供了一个通过已存在对象进行新对象创建的接口（Clone），Clone接口在 C++中我们将通过拷贝构造函数实现。

#### 总结：

* Prototype 模式通过复制原型（Prototype）而获得新对象创建的功能，这里 Prototype本身就是“对象工厂”（因为能够生产对象），实际上 Prototype 模式和 Builder 模式、AbstractFactory模式都是通过一个类（对象实例）来专门负责对象的创建工作（工厂对象），它们之间的区别是：Builder模式重在复杂对象的一步步创建（并不直接返回对象），AbstractFactory 模式重在产生多个相互依赖类的对象，而 Prototype模式重在从自身复制自己创建新类。
* 原型模式的本质就是clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制



```// 原型模式
//Prototype.h 
#ifndef _PROTOTYPE_H_ 
#define _PROTOTYPE_H_ 
class Prototype 
{ 
public: 
 virtual ~Prototype(); 
virtual Prototype* Clone() const = 0; 
protected: 
 Prototype(); 
private: 
}; 
class ConcretePrototype:public Prototype 
{ 
public: 
 ConcretePrototype(); 
 ConcretePrototype(const 
ConcretePrototype& cp); 
 ~ConcretePrototype(); 
Prototype* Clone() const; 
protected: 
private: 
}; 
#endif //~_PROTOTYPE_H_ 


//Prototype.cpp
#include "Prototype.h" 
#include <iostream> 
using namespace std; 
Prototype::Prototype() 
{ 
} 
Prototype::~Prototype() 
{ 
} 
Prototype* Prototype::Clone() const 
{ 
 return 0;
} 
ConcretePrototype::ConcretePrototype() 
{ 
} 
ConcretePrototype::~ConcretePrototype() 
{ 
} 
ConcretePrototype::ConcretePrototype(const ConcretePrototype& cp) 
{ 
 cout<<"ConcretePrototype copy ..."<<endl;
} 
Prototype* ConcretePrototype::Clone() const 
{ 
return new ConcretePrototype(*this); 
}


//main.cpp 
#include "Prototype.h" 
#include <iostream> 
using namespace std; 
int main(int argc,char* argv[])
{ 
Prototype* p = new ConcretePrototype(); 
Prototype* p1 = p->Clone(); 
 return 0;
}

```