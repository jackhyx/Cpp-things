#### SRP：单一职责原则
* 单一职责原则（The Single Responsibility Principle，SRP）
* 一个模块应该有且只有一个导致其变化的原因。
* 如何定义一个模块
我们通常会把一个源文件定义为最小粒度的模块。
* 如何找到这个原因
一个软件的变化往往是为了满足某个用户的需求，那么这个用户就是导致变化的原因。

#### 除了重复的代码编译，违反SRP还会带来以下2个常见的问题：
* 代码冲突。程序员A修改了模块的A功能，而程序员B在不知情的情况下也在修改该模块的B功能（因为A功能和B功能面向不同的用户，完全可能由2位不同的程序员来维护），当他们同时提交修改时，代码冲突就会发生（修改了同一个源文件）。
* A功能的修改影响了B功能。如果A功能和B功能都使用了模块里的一个公共函数C，现在A功能有新的需求需要修改函数C，那么如果修改人没有考虑到B功能，那么B功能的原有逻辑就会受到影响。
* 如果一个模块面向的都是同一类用户（变化原因一致），那么就没必要进行拆分。
* SRP是聚合和拆分的一个平衡，太过聚合会导致牵一发动全身，拆分过细又会提升复杂性。要从用户的视角来把握拆分的度，把面向不同用户的功能拆分开。如果实在无法判断/预测，那就等变化发生时再拆分，避免过度的设计。
#### 迪米特法则 其目的是降低类之间的耦合度，提高模块的相对独立性。
优点：
* 降低类之间的耦合度，提高模块的相对独立性。
* 由于亲和度降低，从而提高了类的可复用率和系统的扩展性。
缺点：
过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。
* 所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
使用迪米特法则需要注意：

* 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
* 在类的结构设计上，尽量降低类成员的访问权限。
* 在类的设计上，优先考虑将一个类设置成不变类。
* 在对其他类的引用上，将引用其他对象的次数降到最低。
* 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
* 谨慎使用序列化（Serializable）功能。

#### OCP: 开闭原则
软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将客户端和服务端分开。公共部分抽象出来。

问题由来：

在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，
也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

解决办法：

当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。
开闭原则可能是设计模式六项原则中定义最模糊的一个了，
它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。
以前，如果有人告诉我"你进行设计的时候一定要遵守开闭原则"，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。
在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。
其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。
也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的"平均得分"，
前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。

其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。
因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。
而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，
我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。

说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：
单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；
接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。
* “开”指的是对扩展开放 
* “闭”指的是对修改封闭，它的完整解释为：

* 通俗地讲就是，一个软件系统应该具备良好的可扩展性，新增功能应当通过扩展的方式实现，而不是在已有的代码基础上修改。
* 然而，从字面意思上看，OCP貌似又是自相矛盾的：想要给一个模块新增功能，但是又不能修改它。
* 如何才能打破这个困境呢？关键是抽象！优秀的软件系统总是建立在良好的抽象的基础上，抽象化可以降低软件系统的复杂性。

* 抽象就是不断忽略细节，找到事物间共同点的过程。
* 抽象是分层的，抽象层次越高，细节也就越少。
* 满足OCP的另一个关键点就是分离变化，只有先把变化点识别分离出来，我们才能对它进行抽象化。

#### LSP：里氏替换原则
里氏替换至少包含一下两个含义：
* 里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。
* 子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，
* 子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。

* 如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，
* 让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。
* 也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。


* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
* 子类可以增加自己特有的方法
* 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
* 当子类的方法实现父类的抽象方法时，方法的返回值应比父类更严格

* OCP的一个关键点就是抽象，而如何判断一个抽象是否合理，这是里氏替换原则 
* 简单地讲就是，子类型必须能够替换掉它们的基类型，也即基类中的所有性质，在子类中仍能成立。

* 一个模型的正确性或有效性，只能通过客户端程序来体现。 
* 符合LSP的模型所需要遵循的一些约束： 
* 基类应该设计为一个抽象类（不能直接实例化，只能被继承）。 
* 子类应该实现基类的抽象接口，而不是重写基类已经实现的具体方法。
* 子类可以新增功能，但不能改变基类的功能。
* 子类不能新增约束，包括抛出基类没有声明的异常。


### ISP：接口隔离原则
* 一个模块不应该强迫客户程序依赖它们不想使用的接口，模块间的关系应该建立在最小的接口集上。
* 违反ISP主要会带来如下2个问题： 
* 增加模块与客户端程序的依赖 
* 产生接口污染
* 实现ISP的关键是将大接口拆分成小接口，而拆分的关键就是接口粒度的把握。 
* 接口隔离可以减少模块间耦合，提升系统稳定性，
* 但是过度地细化和拆分接口，也会导致系统的接口数量的上涨，从而产生更大的维护成本。
* 接口的粒度需要根据具体的业务场景来定，可以参考单一职责原则，将那些为同一类客户端程序提供服务的接口合并在一起

### DIP：依赖倒置原则
* 高层模块不应该依赖低层模块，两者都应该依赖抽象 
* 抽象不应该依赖细节，细节应该依赖抽象
依赖倒置的中心思想是面向接口编程。
依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。
使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。
#### 高层模块和低层模块
* 一般地，我们认为高层模块是包含了应用程序核心业务逻辑、策略的模块，是整个应用程序的灵魂所在；低层模块通常是一些基础设施，比如数据库、Web框架等，它们主要为了辅助高层模块完成业务而存在。
#### 抽象和细节
* 在前文“OCP：开闭原则”一节中，我们可以知道，抽象就是众多细节中的共同点，抽象就是不断忽略细节的出来的。 
* 现在再来看DIP的定义，对于第2点我们不难理解，从抽象的定义来看，抽象是不会依赖细节的，否则那就不是抽象了；而细节依赖抽象往往都是成立的。 
* 理解DIP的关键在于第1点，按照我们正向的思维，高层模块要借助低层模块来完成业务，这必然会导致高层模块依赖低层模块。但是在软件领域里，我们可以把这个依赖关系倒置过来，这其中的关键就是抽象。
* 我们可以忽略掉低层模块的细节，抽象出一个稳定的接口，然后让高层模块依赖该接口，同时让低层模块实现该接口，从而实现了依赖关系的倒置 
* 之所以要把高层模块和底层模块的依赖关系倒置过来，主要是因为作为核心的高层模块不应该受到低层模块变化的影响。高层模块的变化原因应当只能有一个，那就是来自软件用户的业务变更需求

#### 一般地，我们都会在main/启动函数上完成依赖注入，常见的注入的方式有以下几种：
* 构造函数注入（Registry所使用的方法） 
* setter方法注入 
* 提供依赖注入的接口，客户端直调用该接口即可 
* 通过框架进行注入，比如Spring框架中的注解注入能力
