
#### SRP：单一职责原则
* 单一职责原则（The Single Responsibility Principle，SRP）
* 一个模块应该有且只有一个导致其变化的原因。
* 如何定义一个模块
我们通常会把一个源文件定义为最小粒度的模块。
* 如何找到这个原因
一个软件的变化往往是为了满足某个用户的需求，那么这个用户就是导致变化的原因。

#### 除了重复的代码编译，违反SRP还会带来以下2个常见的问题：
* 代码冲突。程序员A修改了模块的A功能，而程序员B在不知情的情况下也在修改该模块的B功能（因为A功能和B功能面向不同的用户，完全可能由2位不同的程序员来维护），当他们同时提交修改时，代码冲突就会发生（修改了同一个源文件）。
* A功能的修改影响了B功能。如果A功能和B功能都使用了模块里的一个公共函数C，现在A功能有新的需求需要修改函数C，那么如果修改人没有考虑到B功能，那么B功能的原有逻辑就会受到影响。
* 如果一个模块面向的都是同一类用户（变化原因一致），那么就没必要进行拆分。
* SRP是聚合和拆分的一个平衡，太过聚合会导致牵一发动全身，拆分过细又会提升复杂性。要从用户的视角来把握拆分的度，把面向不同用户的功能拆分开。如果实在无法判断/预测，那就等变化发生时再拆分，避免过度的设计。

#### OCP: 开闭原则
* “开”指的是对扩展开放 
* “闭”指的是对修改封闭，它的完整解释为：

* 通俗地讲就是，一个软件系统应该具备良好的可扩展性，新增功能应当通过扩展的方式实现，而不是在已有的代码基础上修改。
* 然而，从字面意思上看，OCP貌似又是自相矛盾的：想要给一个模块新增功能，但是又不能修改它。
* 如何才能打破这个困境呢？关键是抽象！优秀的软件系统总是建立在良好的抽象的基础上，抽象化可以降低软件系统的复杂性。

* 抽象就是不断忽略细节，找到事物间共同点的过程。
* 抽象是分层的，抽象层次越高，细节也就越少。
* 满足OCP的另一个关键点就是分离变化，只有先把变化点识别分离出来，我们才能对它进行抽象化。

#### LSP：里氏替换原则
* OCP的一个关键点就是抽象，而如何判断一个抽象是否合理，这是里氏替换原则 
* 简单地讲就是，子类型必须能够替换掉它们的基类型，也即基类中的所有性质，在子类中仍能成立。

* 一个模型的正确性或有效性，只能通过客户端程序来体现。 
* 符合LSP的模型所需要遵循的一些约束： 
* 基类应该设计为一个抽象类（不能直接实例化，只能被继承）。 
* 子类应该实现基类的抽象接口，而不是重写基类已经实现的具体方法。
* 子类可以新增功能，但不能改变基类的功能。
* 子类不能新增约束，包括抛出基类没有声明的异常。


### ISP：接口隔离原则
* 一个模块不应该强迫客户程序依赖它们不想使用的接口，模块间的关系应该建立在最小的接口集上。
* 违反ISP主要会带来如下2个问题： 
* 增加模块与客户端程序的依赖 
* 产生接口污染
* 实现ISP的关键是将大接口拆分成小接口，而拆分的关键就是接口粒度的把握。 
* 接口隔离可以减少模块间耦合，提升系统稳定性，
* 但是过度地细化和拆分接口，也会导致系统的接口数量的上涨，从而产生更大的维护成本。
* 接口的粒度需要根据具体的业务场景来定，可以参考单一职责原则，将那些为同一类客户端程序提供服务的接口合并在一起

### DIP：依赖倒置原则
* 高层模块不应该依赖低层模块，两者都应该依赖抽象 
* 抽象不应该依赖细节，细节应该依赖抽象

#### 高层模块和低层模块
* 一般地，我们认为高层模块是包含了应用程序核心业务逻辑、策略的模块，是整个应用程序的灵魂所在；低层模块通常是一些基础设施，比如数据库、Web框架等，它们主要为了辅助高层模块完成业务而存在。
#### 抽象和细节
* 在前文“OCP：开闭原则”一节中，我们可以知道，抽象就是众多细节中的共同点，抽象就是不断忽略细节的出来的。 
* 现在再来看DIP的定义，对于第2点我们不难理解，从抽象的定义来看，抽象是不会依赖细节的，否则那就不是抽象了；而细节依赖抽象往往都是成立的。 
* 理解DIP的关键在于第1点，按照我们正向的思维，高层模块要借助低层模块来完成业务，这必然会导致高层模块依赖低层模块。但是在软件领域里，我们可以把这个依赖关系倒置过来，这其中的关键就是抽象。
* 我们可以忽略掉低层模块的细节，抽象出一个稳定的接口，然后让高层模块依赖该接口，同时让低层模块实现该接口，从而实现了依赖关系的倒置 
* 之所以要把高层模块和底层模块的依赖关系倒置过来，主要是因为作为核心的高层模块不应该受到低层模块变化的影响。高层模块的变化原因应当只能有一个，那就是来自软件用户的业务变更需求

#### 一般地，我们都会在main/启动函数上完成依赖注入，常见的注入的方式有以下几种：
* 构造函数注入（Registry所使用的方法） 
* setter方法注入 
* 提供依赖注入的接口，客户端直调用该接口即可 
* 通过框架进行注入，比如Spring框架中的注解注入能力
