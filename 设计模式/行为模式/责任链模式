*Chain of Responsibility 模式（责任链模式）*
责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。
这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

* 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

* 何时使用：在处理消息的时候以过滤很多道。
#### 总结：

将请求和处理分开，实现解耦，提高系统的灵活性
简化了对象，使对象不需要知道链的结构
调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂
最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器


```
#include <iostream>
#include <list>

    class Man;
    class Woman;
    using namespace std;

    class Action
    {
    public:
        virtual void getManResult(Man* man) =0;
        virtual void getWomanResult(Woman* woman) =0;

    private:
    };

    class Success:public Action
    {
    public:
        void getManResult(Man* man) override
        {
            cout << "男人的给的评价该歌手是很成功" << endl;
        }

        void getWomanResult(Woman* woman) override
        {
            cout << "女人的给的评价该歌手是很成功" << endl;
        }
    };

    class Fail :public Action
    {
    public:
        void getManResult(Man* man) override
        {
            cout << "男人的给的评价该歌手是失败" << endl;
        }

        void getWomanResult(Woman* woman) override
        {
            cout << "女人的给的评价该歌手是失败" << endl;
        }
    };

    class Person
    {
    public:
        //提供一个方法让访问者可以访问
        virtual void accept(Action* action) = 0;
    };

//这里用用到了双分派，即首先在客户端程序中，将具体的状态作为参数传递进Man中（第一次分派）
//然后在Man中调用作为参数的“具体方法” getManResult同时将自己作为参数传入完成第二次分派
    class Man:public Person
    {
    public:
        void accept(Action* action) override
        {
            action->getManResult(this);
        }
    };

    class Woman: public Person
    {
    public:
        void accept(Action* action) override
        {
            action->getWomanResult(this);
        }
    };

//数据结构，管理很多人（Man、Woman）用来装符合某一个评价的所有人
    class ObjectStructure
    {
    public:
        //添加到list
        void attach(Person* p)
        {
            persons.push_back(p);
        }
        //移除
        void detach(Person* p)
        {
            persons.remove(p);
            delete p;
        }

        //显示测评情况
        void display(Action* action)
        {
            for (auto value : persons)
            {
                value->accept(action);
            }
        }
    private:
        list<Person*> persons;
    };

    int main(int argc, char* argv[])
    {
        //创建ObjectStructure（可以创建很多个不同的ObjectStructure来代表不同评价，然后把同样评价的人放到一个ObjectStructure中）
        auto* objectStructure = new ObjectStructure;
        objectStructure->attach(new Man);
        objectStructure->attach(new Woman);

        //假如歌手获得成功
        auto* success = new Success;
        objectStructure->display(success);
        cout << "=======================" << endl;
        //假如歌手失败了
        Fail* fail = new Fail;
        objectStructure->display(fail);
        return 0;
    }



```