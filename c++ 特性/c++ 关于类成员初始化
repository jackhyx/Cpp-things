## 类成员初始化方式
赋值初始化，通过在函数体内进行赋值初始化；
列表初始化，在冒号后使用初始化列表进行初始化。

## 这两种方式的主要区别在于：
#对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。

#列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)；
那么分配了内存空间后，在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行；
初始化顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

## 一个派生类构造函数的执行顺序如下：

# 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。

# 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。

# 类类型的成员对象的构造函数（按照初始化顺序）

# 派生类自己的构造函数。

## 为什么用成员初始化列表会快一些
使用初始化列表少了一次调用默认构造函数的过程

赋值初始化：是在构造函数当中做赋值的操作，调用默认构造函数
列表初始化：做纯粹的初始化操作，省去了调用默认构造函数

## 以下几种情况时必须使用初始化列表
# 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
# 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
举例：

class Test
{
 priate:
    const int a;             //const成员声明
 public:
    Test():a(10){}           //初始化
};
或
class Test
{
 private:
     int &a;                        //声明
 public:
     Test(int a):a(a){}        //初始化
}

# 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
说明：数据成员是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数；
如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，而没有默认构造函数，
这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错

# 子类初始化父类的私有成员
class Test{
public:
    Test(){};
    Test (int x){ int_x = x;};
    void show(){cout<< int_x << endl;}
private:
    int int_x;
};
class Mytest:public Test{
public:
    Mytest() ：Test(110){
      //Test(110);            //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用
    };
};

© 2022 GitHub, Inc.
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About
Loading complete
