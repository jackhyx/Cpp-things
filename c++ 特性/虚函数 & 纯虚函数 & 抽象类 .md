##### 虚函数的简单含义

在某基类中声明为 virtual并在一个或多个派生类中被重新定义的成员函数
用法格式为：virtual 函数返回类型 函数名 ( 参数表 ) { 函数体 }；
实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。

那么什么是多态性呢？

所谓多态性，顾名思义就是“多个性态”。更具体一点的就是，用一个名字定义多个函数，这些函数执行不同但相似的工作。
最简单的多态性的实现方式就是函数重载和模板，这两种属于静态多态性。还有一种是动态多态性，其实现方式就是我们今天要说的虚函数。下面来看一段简单的代码

```c++
class A{
public:
    void print(){ cout<<"This is A"<<endl;}
};

class B:public A{
public:
    void print(){ cout<<"This is B"<<endl;}
};

int main(){   //为了在以后便于区分，我这段main()代码叫做main1
    A a;
    B b;
    a.print();
    b.print();
}
```

通过class A和class B的print()这个接口，可以看出这两个class因个体的差异而采用了不同的策略，输出的结果也是我们预料中的，分别是This is A和This is
B。但这是否真正做到了多态性呢？No，多态还有个关键之处就是一切用指向基类的指针或引用来操作对象。那现在就把main()处的代码改一改。

```c++
int main(){ //main2
    A a;
    B b;
    A* p1=&a;
    A* p2=&b;
    
    p1->print();
    p2->print();
}
```

运行一下看看结果，哟呵，蓦然回首，结果却是两个This is A。
问题来了，p2明明指向的是class B的对象但却是调用的class A的print()函数，这不是我们所期望的结果，那么解决这个问题就需要用到虚函数

```c++
class A{
public:
    virtual void print(){ cout<<"This is A"<<endl;} //现在成了虚函数了
};

class B:public A{
public:
    void print(){ cout<<"This is B"<<endl;} //这里需要在前面加上关键字virtual吗？
};
```

毫无疑问，class A的成员函数print()已经成了虚函数，那么class B的print()成了虚函数了吗？回答是Yes，
我们只需在把基类的成员函数设为virtual，其派生类的相应的函数也会自动变为虚函数。所以，class
B的print()也成了虚函数。那么对于在派生类的相应函数前是否需要用virtual关键字修饰，那就是你自己的问题了（可用可不用）。

现在重新运行main2的代码，这样输出的结果就是This is A和This is B了。

现在来消化一下，我作个简单的总结，指向基类的指针在操作它的多态类对象时，会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。

虚函数的重要概念
首先：强调一个概念：

定义一个函数为虚函数，不代表函数为不被实现的函数。
**定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。**
定义一个函数为纯虚函数，才代表函数没有被实现。

#### 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

假设我们有下面的类层次：

```c++
class A  
{  
public:  
    virtual void foo()  
    {  
        cout<<"A::foo() is called"<<endl;  
    }  
};  
class B:public A  
{  
public:  
    void foo()  
    {  
        cout<<"B::foo() is called"<<endl;  
    }  
};  
int main(void)  
{  
    A *a = new B();  
    a->foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  
    return 0;  
}  
```

这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念
。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。
由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
为实现多态性，可以通过基类的指针或引用访问派生类的成员。也就是说，声明一个基类指针，这个基类指针可以指向派生类对象。

#### 拓展：析构函数必须是虚拟的

基类中的虚拟成员希望其派生类定义自己的版本。

#### 特别是基类通常应该定义一个虚拟析构函数，即使它不起作用，析构函数必须是虚拟的，以允许动态分配和销毁继承层次结构中的对象。

那么为什么析构函数必须是虚拟的，而我们新建程序时，默认的析构函数却不是虚拟的呢？

#### 为什么析构函数必须是虚拟的？

因为指针指向的是一个派生类实例，我们销毁这个实例时，肯定是希望先清理派生类自己的资源，同时又清理从基类继承过来的资源。
而当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理。

总结：如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数
。这样，释放基类指针指向的派生类实例时，清理工作才能全面进行，**才不会发生内存泄漏。**

#### 为什么默认的析构函数不是虚函数？

虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。
这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，
我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。
这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。

这样一说，问题就不言而喻了。当我们创建一个类时，系统默认我们不会将该类作为基类，所以就将默认的析构函数定义成非虚函数，
这样就不会占用额外的内存空间。同时，系统也相信程序开发者在定义一个基类时，会显示地将基类的析构函数定义成虚函数，此时该类才会维护虚函数表和虚表指针。

#### 纯虚函数的含义与使用

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，**但要求任何派生类都要定义自己的实现方法**。在基类中实现纯虚函数的方法是在函数原型后加“=0”
virtual void funtion1()=0;

* 引入原因
  为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
  在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
  为了解决上述问题，引入了纯虚函数的概念
* 将函数定义为纯虚函数（方法：virtual ReturnType Function() = 0;）
* 则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象
  声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
  纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

#### 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。
所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

#### 纯虚函数的使用

问题：虚函数在基类中一定要实现吗？

```c++
class Location
{
public:
    Location(){}
    ~Location(){}

public:
    virtual bool Check(); // 这里一定要实现吗？
};

class LineLocation : public Location
{
    public:
    LineLocation(){}
    ~LineLocation(){}

public:
    virtual bool Check() {
        return 1;
    }
};

int _tmain(int argc, _TCHAR* argv[])
{
    Location* loc = NULL;
    loc = new LineLocation();
    bool b= loc->Check();
    return 0;
}
```

基类中的虚函数不实现会报错：程序链接出错，error LNK2001: unresolved external symbol。。。
而将基类的check()函数进行定义实现的话，程序链接是能够通过的。

#### 虚函数在基类中一定要实现，如果基类中的虚函数不想实现，只想通过派生类来实现，需要将基类中的虚函数换成纯虚函数，需要在函数后加 =0。
因为虚函数的地址在链接的时候需要放到类的虚函数表中，所以即使你的代码里面没有调用这个函数，编译器也需要取它的地址，已经有对它的引用了，就必须要实现才行。
* 在main函数中，如果有父类或者子类的实例对象，就需要有父类的虚函数的实现。
* 在main函数中，如果没有父类或者子类的实例对象，可以不实现父类的虚函数。
* 如果把虚函数写成纯虚函数，也就不需要实现了，也没不会发生上述讨论。
  注：因为纯虚函数就相当于接口，无法实例化，即Location loc;编译是不能通过的。即有纯虚函数的类，将其作为参数也好
* ，另一个类的成员变量也好，只能将其定义为指针或引用，只要不给基类实例化对象就行。

#### 抽象类的介绍
抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
* 抽象类的定义： 称带有纯虚函数的类为抽象类。
* 抽象类的作用：
  抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根
* 派生类将具体实现在其基类中作为接口的操作
* 所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

* 使用抽象类时注意：

* 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
  如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。
* 如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

* 抽象类是不能定义对象的。

### 总结
纯虚函数声明如下：
virtual void funtion1()=0
纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。
包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

虚函数声明如下：virtual ReturnType FunctionName(Parameter)；
虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol “public: virtual void __thiscall ClassName::virtualFunctionName(void)”

对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。

在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。

友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让**友元函数调用虚拟成员函数**来解决友元的虚拟问题

析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。

定义纯虚函数就是为了让基类不可实例化化，因为实例化这样的抽象数据结构本身并没有意义。 或者给出实现也没有意义
实际上我个人认为纯虚函数的引入，是出于两个目的
为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。
为了效率，不是程序执行的效率，而是为了编码的效率。
