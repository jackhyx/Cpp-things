#### 空类的大小

很多人都知道，一个空类（后者是空类对象）使用sizeof的时候，结果是1。
解释相信大家也知道，想想，如果真是空类。那么对于同一个空类的对象就不会占空间，不会占空间就意味着无法区分。
（有人可能会说，我们只分配对象名，不分配空间，那样的话，你会让整个C/C++语言为空类，以及相关的空类对象设计一套特殊的规则，是这个语言变得非常不合理）。
* 所以，C++的选择是，自动的给空类插入一个char类型（只一个特殊对待），只要这个类对象将来占空间，那么就可以通过地址来区分他们。



### 空类的作用

* 我们利用类型（通常是空类）来区别对待不同类对象的属性。（其实我们是可以通过使用常数来区分的，但是区别我们很容易就能知道）。

使用常数来区分需要使用if else的这种运行时来确定执行的线路的方法，而使用函数重载的方法，在参数中加入一个空类域作为区分不同的函数的方法，编译的时候直接选择，而不是在运行的时候选择，这是非常提高效率的。

要知道，不同的空类，是不同的。
他们代表着不同的类型(虽然他们结构一样）。在STL中，使用空类区分不同类型的标志，从而在编译的时候来对不同的类进行有针对性的优化是非常常见的。
```
template <typename A>

void fun(A a)

{

typedef typename trait<A>::type T;

_fun(A a, *(new T()));

}

template <typename A>

void _fun(A a, int)

{
……
}

template <typename A>

void _fun(A b, float)

{

……
}


```
当然，空类应该还有其他的用处。我们所有知道和理解的就是。空类是C++中一个有用的机制，不同名称的空类代表着不同的类型。
空类在编译的时候会被编译器自动的加入一个char成员，不为别的，只是为了，让它被实例后的对象占有空间，从而可以区分。



#### 空数组

C中我们可以定义空数组：

int a[0];

使用sizeof的时候你差是多少：

0

好吧，这里0，我们可以理解。但是问题就来了

既然前面对于空类的情况中，因为需要让对象唯一定位，所以插入char，那么空数组既然sizeof的大小为0，那应该就是不占空间，那么如何区分。

事实上，对于空数组，在C/C++有着特别的交代（可能是具体的实现不同，这里只是使用GCC，G++）。

空数组名是一个指针，（但是又不占空间）指向一个位置：

对于结构体中，空数组名这个指针指向了前面一个成员结束的第一个空间。

对于非结构题中，空数组名这个指针指向的内容，与前一个对象的指针的内容一样（虽然可能他们的类型不一样）。

虽然，我们不知道这两种安排有什么玄机，或者益处，但是无所谓（下一节会介绍空数组的作用），但是针对空数组的sizeof为什么可以为0，我们有了解释。



与空类，不同的是，空数组是一个对象，而不是一个类。既然我们这个对象定义出来了，而且它会指向一个空间（虽然这个空间可能会与其他的地方重叠）但是，我们总算能够区分开不同的空数组。



### 空数组的作用

其实在C里面，空数组的使用是非常多的。

问题：


加入你想要给一个结构体（代表一个功能）添加一个缓冲区。你会怎么做？

1）定义一个固定长度的buffer数组成员，这样的不好之处在于buffer会被定死。

2）定义一个buffer指针，在构造函数（虽然C没有，但可以使用initialize函数来代替）中动态的创建一个需要大小的buffer，给这个结构体使用。但是这样就需要我们特别管理这个空间（使用析构函数），否则会很容易出现内存泄露。并且，一个buffer指针还占有了一个空间。



那么C里面，就有一个巧用空数组来达到这个问题的方法。


```
struct  T

{

int a;

int b;

……

char buffer[];

};
```

我们知道，由于buffer并不占空间，所以，T的对象的总大小是不会把buffer算上的。



struct T * p=(T*)malloc(sizeof(T) +buffer_len);

看到没有，在声请空间的时候，加上buffer_len（所需缓冲区长度），这样结构体和缓冲区一起被声请了，（在结束的时候，也可以直接使用free一起释放，可以避免独立的管理结构体和缓冲区）。

并且我们知道，buffer这个“指针”指向的就是结构体后面的那个buffer_len的空间。



这样做还有一个好处，如果我们分开管理结构体和缓冲区（通常这个时候结构体是一个小碎片）。
在申请和释放的时候，很容易在内存中制造出碎片。而如果向上面的这样管理，结构体，依附这缓冲区（大块）一起被管理。那将是一个很美好的事情。

这就是空数组的用处。

#### 类中空数组
```
class T

{

int a[0];

};
```
您看这个类的sizeof为多少：

0

你会觉得这像个玩笑。但是其实仔细分析一下，也是可以所通的。我前面说给一个空类插入一个char成员，是因为想让程序能够区分该类的不同对象。而这里，我们知道由于空数组是不占内存的，它就像一个指针指向某个地方，但是又不占内存。但是的确我们的类对象能够借助空数组这个东西来区分开来。所以既然目的达到了，那么为什么还要加入什么一些什么信息呢？