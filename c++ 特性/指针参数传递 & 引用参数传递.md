#### C++指针和引用的区别

* 内存分配：指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
* 初始化：引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。
* 使用级别：有多级指针，但是没有多级引用，只能一级引用。
* 自增运算：指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）
* 使用sizeof时：引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。
* 直接与间接访问：引用访问一个变量是直接访问，而指针访问一个变量是间接访问。
* 野指针：使用指针前最好做类型检查，防止野指针的出现；
* 参数传递：作为参数时，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。


#### C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？

* 指针参数传递本质上是值传递，它所传递的是一个地址值。
值传递过程中，被调函数的形式参数作为被调函数的局部变量处理# 会在栈中开辟内存空间以存放由主调函数传递进来的实参值 #从而形成了实参的一个副本（替身）；
值传递的特点：被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变） 

* 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。
被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。
因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

* 引用传递和指针传递是不同的 
* 虽然他们都是在被调函数栈空间上的一个局部变量 
* 任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量
* 而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

* 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。
* 指针变量在符号表上对应的地址值 #为指针变量的地址值 
* 而引用在符号表上对应的地址值 #为引用对象的地址值（与实参名字不同，地址相同）。 
* 符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

#### 你什么情况用指针当参数，什么时候用引用，为什么？
* 使用引用参数的主要原因有两个：
程序员能修改调用函数中的数据对象
通过传递引用而不是整个数据–对象，可以提高程序的运行速度

* 一般的原则：对于使用引用的值而不做修改的函数：

如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；
如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；
如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；
如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；

* 对于修改函数中数据的函数：

如果数据是内置数据类型，则使用指针
如果数据对象是数组，则只能使用指针
如果数据对象是结构，则使用引用或者指针
如果数据是类对象，则使用引用

#### 在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？
* 传参-->对比值传递 # 引用传参的好处：
 在函数内部可以对此参数进行修改
 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递
函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本
即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改
函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

* 返回值-->用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

* 不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁

* 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面
例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性





