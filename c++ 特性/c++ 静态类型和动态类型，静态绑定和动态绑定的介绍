### 静态类型和动态类型，静态绑定和动态绑定的介绍
###静态类型和动态类型，静态绑定和动态绑定的介绍

* 静态类型：对象在声明时采用的类型，在编译期既已确定； 
* 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；

* 继承体系下： 
* 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 
* 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；
##静态类型：对象在声明时采用的类型，在编译期既已确定；
##动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
继承体系下：
##静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
##动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；
从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）

* 从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）

```举个例子：
举个例子：

#include <iostream>
using namespace std;

class A
{
public:
    /*virtual*/ void func() { std::cout << "A::func()\n"; }
};
class B : public A
{
public:
    void func() { std::cout << "B::func()\n"; }
};
class C : public A
{
public:
    void func() { std::cout << "C::func()\n"; }
};
int main()
{
    C* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；
    B* pb = new B(); //pb的静态类型和动态类型也都是B*；
    A* pa = pc;      //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；
    pa = pb;         //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；
    C *pnull = NULL; //pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；

    pa->func();      //A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；
    pc->func();      //C::func() pc的动、静态类型都是C*，因此调用C::func()；
    pnull->func();   //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；
    return 0;
}
```

如果将A类中的virtual注释去掉，则运行结果是：

pa->func();      //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；
pc->func();      //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；
pnull->func();   //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；

在上面的例子中，

* 如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。 
* 同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态； 
* 如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性； 
* 本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。
如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。

同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；

如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；

本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。

## 至此总结一下静态绑定和动态绑定的区别：

* 静态绑定发生在编译期，动态绑定发生在运行期； 
* 对象的动态类型可以更改，但是静态类型无法更改； 
* 要想实现动态，必须使用动态绑定； 
* 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；
静态绑定发生在编译期，动态绑定发生在运行期；

对象的动态类型可以更改，但是静态类型无法更改；

要想实现动态，必须使用动态绑定；

在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；

## 建议：
## 绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36）
因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系
没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG->>>有可能空指针也能调用函数 null->静态类型 + 静态绑定

## 另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。
当默认参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。 看下面的代码：

```#include <iostream>
#include <iostream>
using namespace std;

class E
{
public:
    virtual void func(int i = 0)
    {
        std::cout << "E::func()\t" << i << "\n";
    } // \t tab
    }
};
class F : public E
{
public:
    virtual void func(int i = 1)
    {
        std::cout << "F::func()\t" << i << "\n";
    }
};

void test2()
{
    F* pf = new F();
    E* pe = pf;
    pf->func(); //F::func() 1  正常，就该如此；
    pe->func(); //F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！
    // 当基类类型的指针，调用fun函数时，调用的是子类的fun()函数，但使用了基类函数fun()中的默认值！
}
int main()
{
    test2();
    return 0;
}
```


原因解释：
## 默认参数是不会做为判断函数是否相同的因素的 所以子类与基类中的fun()函数被认为是相同的，这样基类的fun()函数被隐藏了
默认值是在编译期间使用的，当编译器看到一个函数调用中的某个参数缺失了，它就会用默认提供的值来替换；
因此，上面程序中，i的值在编译期间被替换了，在运行时期间调用的是子类的fun()函数；
## 一句话：静态绑定发生在编译期，动态绑定发生在运行期


## 引用是否能实现动态绑定，为什么可以实现？
可以。
# 引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。

    ```举个例子：
    
    #include <iostream>
    using namespace std;
    
    class Base 
    {
    public:
        virtual void  fun()
        {
            cout << "base :: fun()" << endl;
        }
    };
    
    class Son : public Base
    {
    public:
        virtual void  fun()
        {
            cout << "son :: fun()" << endl;
        }
        void func()
        {
            cout << "son :: not virtual function" <<endl;
        }
    };
    
    int main()
    {
        Son s;
        Base& b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化
        s.fun(); //son::fun()
        b.fun(); //son::fun()
        return 0;
    }```
举个例子：

#include <iostream>
using namespace std;

class Base 
{
public:
    virtual void  fun()
    {
        cout << "base :: fun()" << endl;
    }
};

class Son : public Base
{
public:
    virtual void  fun()
    {
        cout << "son :: fun()" << endl;
    }
    void func()
    {
        cout << "son :: not virtual function" <<endl;
    }
};

int main()
{
    Son s;
    Base& b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化
    s.fun(); //son::fun()
    b.fun(); //son :: fun()
    return 0;
}
需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。
