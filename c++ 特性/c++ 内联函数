## 为什么要引入内联函数（内联函数的作用）

用它替代宏定义，消除宏定义的缺点
宏定义使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测
另外它的返回值不能被强制转换为可转换的合适类型，且C++中引入了类及类的访问控制，在涉及到类的保护成员和私有成员就不能用宏定义来操作

# 内联函数与宏定义的区别：
内联函数在编译时展开，可以做一些类型检测处理，宏在*预编译时*展开；
内联函数直接嵌入到目标代码中，宏是简单的做文本替换。
C++中引入了类及类的访问控制，在涉及到类的保护成员和私有成员就不能用宏定义来操作

# inline相比宏定义有哪些优越处

inline函数代码是被放到符号表中，使用时像宏一样展开没有调用的开销，效率很高 
inline函数是真正的函数，所以要进行一系列的数据类型检查；
inline函数作为类的成员函数，可以使用类的保护成员及私有成员；

* 符号表
* 在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。
* 在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。
* 
# 为什么不能把所有的函数写成inline函数

* 内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率
* 内联函数体内代码执行时间相比函数调用开销大没有太大的意义；
* 每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数。
* 函数体内有循环，函数执行时间要比函数调用开销大；
  故不能把定义了静态对象的函数作为内联函数。
* 
另外两点需要注意：
* 内联函数时无法获取其地址的。
* 内联函数不可以做为虚函数（内联函数，构造函数，静态函数时都不能为虚函数的）

# 类中的构造函数和析构函数可以是内联的吗

effective里面说，构造函数和析构函数往往是inlining的糟糕候选人
因为编译器在编译期间会给你的构造函数和析构函数额外加入很多的代码，像成员函数的构造析构等代码，所以通常构造析构函数比表面上看起来的要多，并不适合作为内联函数。
inline很重要的一个缺点是：inline造成代码膨胀会导致额外的换页行为，降低指令高速缓存装置的命中率，以及伴随这些而来的效率降低 

#### 宏 VS 函数
* 函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。
* 这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。
* 总结：函数调用要有一定的时间和空间方面的开销，将影响其效率。
* 而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。
但是宏也有很多的不尽人意的地方。
* 宏不能访问对象的私有成员。
* 宏的定义很容易产生二意性。
我们举个例子：
#define square(x) (x*x)
我们用一个数字去调用它,square(5)，这样看上去没有什么错误，结果返回25,是正确的，但是如果我们用squre (5+5)去调用的话，我们期望的结果是100，而宏的调用结果是(5+5*5+5),结果是35，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号。
#define square(x) ((x)*(x))

#### 宏 VS 内联函数
从上面的阐述，可以看到宏有一些难以避免的问题，怎么解决呢？
内联函数是代码被插入到调用者代码处的函数。
如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。
* 宏是由预处理器对宏进行替代
* 而内联函数是通过编译器控制来实现的。 
* 而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。
* 你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。
声明内联函数看上去和普通函数非常相似：
void f(int i, char c);
当你定义一个内联函数时，在函数定义前加上 inline 关键字，并且将定义放入头文件：
inline void f(int i, char c)
{
// ...
}
内联函数必须是和函数体申明在一起，才有效。
像这样的申明inline function(int i)是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体。
inline int function(int i) {return i*i;}
这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。
当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
有上面的两者的特性，我们可以用内联函数完全取代预处理宏。

  

先说宏和函数的区别：
1. 宏做的是简单的字符串替换(注意是字符串的替换,不是其他类型参数的替换),而函数的参数的传递,参数是有数据类型的,可以是各种各样的类型.
2. 宏的参数替换是不经计算而直接处理的,而函数调用是将实参的值传递给形参,既然说是值,自然是计算得来的.
3. 宏在编译之前进行,即先用宏体替换宏名,然后再编译的,而函数显然是编译之后,在执行时,才调用的.因此,宏占用的是编译的时间,而函数占用的是执行时的时间.
4. 宏的参数是不占内存空间的,因为只是做字符串的替换,而函数调用时的参数传递则是具体变量之间的信息传递,形参作为函数的局部变量,显然是占用内存的.
5. 函数的调用是需要付出一定的时空开销的,因为系统在调用函数时,要保留现场,然后转入被调用函数去执行,调用完,再返回主调函数,此时再恢复现场,这些操作,显然在宏中是没有的.


#### 如何禁止函数进行内联？
如果使用VC++，可以使用/Ob命令行参数。当然，也可以在程序中使用 #pragma auto_inline达到相同的目的。

