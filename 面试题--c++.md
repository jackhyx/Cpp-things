
4.设计模式六大原则  单一职责  里氏替换原则等等。了解哪些设计模式？具体说说

9.C++智能指针怎么解决循环引用（我完全没看C++的东西）




算法：字典树   （没理解啥意思，换了一题）
算法：leetcode3  middle 无重复字符的最长子串 （想边说边写的，被面试官说“你不用说直接写就可以了”）

go 协程如何实现


sql语句
（1）查询每个班级的平均分
（2）查询班级平均分 排名前三的班。

算法：都是 leecode 上的题
判断是否是二叉搜索树
k值的最小字典序列
股票问题 一次买卖  ？多次买卖？
 

熟悉什么语言？使用中遇到的问题
golang map【循环】两次打印 结果一样吗？map使用注意事项？不一样。多线程访问。不安全。
索引相关
（1）单列索引 a和b select *  where a= and b= 先查哪个。  那个区分度大查那个 名字>年龄
（2）联合索引 a，b，c  然后查 b，c 会不会用到索引
（3）主键索引和单列索引区别
tcp四次挥手过程？最后为什么等待2msls
事务，通过什么实现？除了行锁还有什么？
文件里面 两亿个数，找到最大100个的
系统的文件日志，几千万条，怎么找出出现最多的ip地址。
算法：一个序列，先增后减，例如 1，4，6，9，13，10，6，2  找某一个数是否在其中。[二分查找]
【三面】


设计一个栈 ，pop push getMax 时间复杂度o
一个数组，除了一个数出现一次，其他都是两次，求该数？如果有两个数呢 ？[异或位运算]
开始-结束时间，好多组，问给定一段时间，能最大干完多少个任务。说思路
写算法：二叉树的镜像。

const和define的区别，有什么优势？
  --编译阶段
  define是在编译的预处理阶段起作用，属于文本插入替换，而const是在编译、运行的时候起作用
  --安全性
  define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
  const常量有数据类型，编译器可以对其进行类型安全检查
  --内存占用
* define只是将宏名称进行替换，在内存中会产生多分相同的备份。
* const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
* 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间
指针和引用的区别


算法：寻找无序数组的中位数

数组和链表的区别 

继承与多态
算法：输出一个有序数组中一个数字的第一次出现的位置或者返回-1
vector的实现
**static关键字的作用**

**explicit关键字的作用**
防止类构造函数的隐式转换


hashmap的实现，冲突时除了链表还有什么方法，读的时间复杂度
所读过的开源框架及其原理
算法：N个长度为K的有序链表合并，时间复杂度，空间复杂度
算法：找出一个字符串最长不包含重复字符的字串的长度。


算法：逆转链表

字节安卓二面
overflow和out of memory的区别


算法：股票买卖一次最大利润、买卖多次最大利润



智力题:64匹马，8个赛道，最少多次求出TOP5



字节安卓四面
如何提高数据库检索速度、索引

索引为什么选B+(对比红黑树、哈希表、B树)

项目的权限管理如何实现

为什么要MD5要加盐



接口和抽象类的区别

finally不执行的情况

ThreadLocal

单例的缺点

LRU、LFU原理




套接字

场景题：一个类有三个方法，三个线程分别访问该类的对象的三个方法中各一个，如何按顺序执行？只对类进行操作，不对线程进行操作。（方法之间设置标志位，first执行完之后再改变标志位，让second跳出循环执行）
```c++
class Foo{

boolean flag = flase;

public void first(){

sout(xxx);

flag = true;

}

public void secnod(){

while(flag == flase){

}

sout(xxx);

}

}
```

算法：二叉树层次遍历
字节安卓五面
算法:一个二维数组，左到右、上到下递增，找到目标值的位置。

场景题：如何实现在浏览器中编辑运行Java

浏览器传输文体text --&gt; 服务器转成java源代码 xxx.java --&gt; 编译运行

返回res{

state，//返回数据的类型

content //返回数据的具体内容

}


*用什么get还是post传？post，参数长度无限制

*运行超时怎么办？服务器中设置一个计数器进程，为Java进程计数
线程和进程的区别、优缺点对比

为什么说线程不便于资源的管理和保护，而进程相反

智力题：A、B两人轮流扔一个硬币，先扔到正面的为赢，A先扔，问A赢得概率为多少？


HTTP访问一个网站，发生了哪些过程？
TCP三次握手发生了什么？
三次握手建立起来的连接，在操作系统层面表现的是什么？
JVM的内存模型
java代码运行的时候怎么进行类加载的，这个类加载和刚刚说的JVM有什么关系？
说几个线程的状态
Thread.sleep()
Thread.wait()进入哪个状态
Redis使用什么机制提高了数据读取和写入的效率？
Redis怎么保证可用性？
假设有大流量的请求进来，如何解决？
springboot支持多例吗？生命周期是多长？多例和单例的区别是什么？比如存活时间
spring里用到了哪些设计模式？
springcloud中的Nacos主要的作用是什么？
算法（只说思路）：
一维数组里是正整数，会重复，求其中连续增长的最长子串的长度？如果不是连续子串呢？
41个正整数，找出其中出现次数最多的数

自我介绍

项目都是自己做的吗？

介绍一下你最擅长的项目？-分布式对象存储

数据存放在哪里？ES用在哪？

直接问数据的一致性？

怎么保证数据的一致性？

恢复的时候怎么知道谁的数据是正确的？

如果最后是3对3，怎么少数服从多数？

如果多个节点垮掉了怎么办？

怎么进行数据恢复？

MySQL了解吗？参考一下他们的思路实现这个过程？

有没有运用到实际的场景？

MySQL的存储引擎？除了Innodb和MyISAM还了解其他的存储引擎吗？

了解索引吗？聚集索引和非聚集索引的区别?

你MySQL运用的场景有哪些？

建表的mysql语句？

索引用过吗？

举了一个联合索引，select * ..... 会不会走索引？

自己有没有设置表？用户表？有没有设计索引？

varchar了解吗？10的长度可以存20吗？



其他语言涉及吗？PHP了解吗？

Linux用过吗？说一下哪些指令？

HTTP状态码？502和504什么意思？

go语言的slice和数组有什么区别？slice是有序的吗？

协程用到异常panic怎么办？怎么捕获，具体的语句怎么写？

怎么查询go语言的性能？

两个比较大的数相加怎么做？写代码？





删除链表第 k 个节点，后改为删除链表的倒数第 k 个节点

线程安全的集合


线程池参数

拒绝策略有哪些？

线程池加入新任务的过程

JVM 为什么要分为新生代和老年代？

以下代码输出什么？执行完这条语句创建了几个对象？

1
new String("123") == new String("123");
Spring 用到了哪些设计模式？

讲讲 AOP

MyBatis 中 #{} 和 ${} 的区别

TCP 三次握手

数据库和缓存的一致性

反问


算法

项目中 JWT 存什么？

日志 AOP 怎么实现的？具体代码说一说

日志如果太大太长怎么办？

序列化手段有什么？（上个问题回答了序列化）

怎么避免重复点击导致数据库中出现重复数据？

Nacos 有什么功能？

注册中心的流程？

配置中心有什么用？

注册中心有什么用？



Redis 的分布式锁
深拷贝、浅拷贝

堆和栈、栈内存如何管理
5、c++11引入了三个智能指针 说说看
6、weakptr是怎么实现监控的？
（不太熟）
7、move了解吗
8、为什么要有move
9、说说宏和内敛函数
10、写一个宏函数看看
11、内敛函数是干了什么
12、c++里的类型转换了解几个 说说
（说了三个，难道还有一个漏了）
13、指针和引用说说
14、引用占空间吗 为什么
15、堆和栈的区别
16、为什么堆慢
17、malloc里面填size 我free的时候是怎么知道释放多少的
我说了下new的、说不太清楚malloc 让我猜猜看 让我设计会怎么设计：
我就说要我设计我就肯定得每malloc就记录在某个表里 free的时候查表就行了
18、说说多态
19、虚函数表是属于谁的
20、对象怎么知道调用了什么函数
21、怎么传的this指针
22、构造函数可以虚函数吗 为什么
23、写了个指向空的类指针 问输出什么
24、说说类的继承权限
25、说说vlc
26、说说h264
答了点它的大概 太久没搞过这个..别的忘了
27、说说rtsp
28、给两个数 求他们的平均数 只能用int
29、两数之和
反问：具体做些啥
忘了
我有什么不足
答：还好吧 主要看基础。 面试结果三个工作日内会有答复







#### c++
* define宏定义和const的区别
--编译阶段
define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
--安全性
define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
const常量有数据类型，编译器可以对其进行类型安全检查
--内存占用
define只是将宏名称进行替换，在内存中会产生多分相同的备份。
* const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
宏不检查类型；const会检查数据类型。
宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间

* C++虚函数，纯虚函数，虚析构函数

* C++的vector的底层实现
* 智能指针（用过，但是不太熟。直接说没怎么用）
* C++独有特性，和C的区别，描述面向对象，虚函数怎么实现，为什么需要虚函数，虚基类有接触吗

* 纯虚函数和虚函数区别，有一个大规模项目需要合作，纯虚函数有什么好处

* 函数指针和指向指针的指针是什么，有什么用

* 有哪些设计模式，单例模式是为了解决什么问题，解释一下工厂和抽象工厂

* 学过的数据结构有什么用，堆栈用处大吗，树是干什么用的，为什么要用红黑树不用其他树

* 指针和引用的区别
 
* 智能指针主要解决什么问题
* 智能指针循环引用问题
* 介绍虚函数、纯虚函数
* C++的面向对象的特点
* 多态的实现形式
* 讲一讲Python语言和C++语言的区别
* Socket什么时候可读?（没有回答好）
* 构造函数是否能为虚函数，为什么。
* 动态多态。
* 静态多态?（只回答了重载，其实还有函数模板）
* 重载、重写以及隐藏各自是什么。

* 如何避免内存泄漏。
* （其实面试官想问如何定位内存泄漏，我说可以使用工具valgrind，又问如何使用这个工具定位内存泄漏，我也没用过，所以回答不上来，然后就换了一个问题）


* OS，怎么看虚拟内存，我这里也给他答了很深，把八股串起来了，面试官觉得还行。
* 问计算机网络，从浏览器输入一个url到渲染到浏览器这之间经过了哪些缓存。我答了DNS缓存，架构，以及业务代码的缓存。

* C++11新特性
* 智能指针
* 循环引用问题及解决
* 手写shared_ptr，就大概哪些成员变量和成员函数实现
* move有了解过吗
* 给出了智能指针一段代码的用法，找错
* C++内存管理
* STL的一些容器
* 一个程序从预处理到运行经历了那些过程（详细说，编译过程中还包含词法分析、语法分析、语义分析......

然后问 set 怎么实现？答：拉链法
直接进入算法环节：
拉链法实现个 map
之后问给实现的 map 加上 lru 怎么加，随便答了答
下来之后自己好好写了个，看这里：https://codetop.cc/discuss/232

http 500状态码
如何使用 Wireshark 抓自己写的服务的数据包

自我介绍。
你所做的项目中最困难的两件事。（越是这种问题，越不好答）
用优先队列实现小根堆。
你所使用Thrift接口又有哪些。
枚举的定义，什么又是枚举类型。

* 说说STL常见的容器，以及各自适用的场景。
* map中的元素为什么是有序的。
* 实现一个类模板。
* 用类模板的方式去实现一个单例模式。
* 一般懒汉式存在什么问题。
* 除了单例模式还知道什么模式，各自的含义又是什么。
* c++11新特性有哪些。
* 线程同步的方式。
* 条件变量的作用，和互斥锁相比又有什么区别。

一堆C/C++的基础（经典的 small ending、big ending、sizeof()、strlen()）
从c语言到c++再到c++11新特性，以及STL

接下来就是给小姐姐讲项目了，问了两个编程项目和自己做的实验室项目~

反问阶段：问了三个问题问问自己面试有啥缺点?知识点上学习有啥不足？再就是实习结果啥时候出来之类的？实习转正之类的问题？

### 算法题

* 递归和非递归前序遍历二叉树
* 二叉树的最大直径
* 手撕：反转链表
* 剑指 Offer 42. 连续子数组的最大和
*
    124. 二叉树中的最大路径和
*
    64. 最小路径和
* 算法：剑指 Offer 28. 对称的二叉树
  分析复杂度
* 算法：3. 无重复字符的最长子串
  分析复杂度及优化
* 手撕：给一个等差数列，其中有一项缺失，找出这一项
* 了解哪些排序算法，其中哪些是稳定的
* 排序的时间复杂度
* 什么排序的时间复杂度下限可以突破O(nlogn)
* 基数排序的场景
* 算法：剑指 Offer II 074. 合并区间
* 找到二叉树路径和为target的所有路径并打印出来（不一定是从根节点出发）。
* 最长回文串；全排列。
* 实现多种方式三个线程依次轮流打印ABC，打印100次；leetcode842，将数组拆分成斐波那契数列。
* 最长回文串；
* 全排列
* 算法题 不重复的全排列
* 算法题 1、全排列 2、岛屿数量，leetcode原题
  算法题：给一个排序数组，找众数的下标（出现次数大于等于数组长度的一半），要求O(logN)。
* 算法题：
  LeetCode 102. 二叉树的层序遍历，需要自己建树验证。
* 算法题 会议室II，leetcode原题

算法题 二叉树最大宽度 leetcode原题
算法：二叉树Z形遍历
#### 其他

* 你来设计苹果iCloud共享图片是怎么做
* 平时写代码用什么东西管理
* go 垃圾回收过程
* docker 原理
  问了不了解分布式协议，答：不了解
  怎么学习的linux
  是否考虑怎么在KV数据库项目中加入事务
* 什么是回溯
* 有哪些搜索算法
* 什么是剪枝
* 设计模式自己有在项目中用过吗
* 日志系统为什么需要单例模式

加了一个系统设计题 设计一个id生成的中间件，考虑高可用，高并发


* 为什么不直接使用redis，而需要有本项目/RocksDB
* 项目中为什么既有epoll又有select
* 项目跨哪个平台
* 是否了解过IOCP
* IOCP和select，poll，epoll的区别
* 多路复用作用
* 项目中的多线程体现在哪里
* 为什么不把处理读写事件的多路io复用函数分散到线程中

* 项目有没有做过压测


* 排序两个有序链表。

part1，项目。问的很细腻，为啥用到消息队列，如果解决消息重复和消息丢失问题；
自己如何设计一个消息队列保证一个消息不会重复消费。
如何保证你的项目高可用？
项目为什么要使用N-Tree，不用有什么影响吗？
part2，基础。面试官也懂java，问了java相关。HashMap原理，扩容机制以及ConcurrentHashMap对比；HashMap如果存入元素很多会溢出吗怎么解决；volatile关键字作用以及和synchronized区别；线程池七大参数以及工作原理；阻塞队列了解过吗？（这里我答的很深，从ReentryLock到AQS那套全部说了涉及到些源码）。
死锁了解吗？谈谈死锁的必要条件？在项目中解决过死锁的问题吗？
垃圾回收算法了解吗？老年代回收担保机制是什么？
JVM对象什么时候被回收，G1垃圾回收器回收原理；G1用户自己设置停顿时间的参数是什么？
GC Roots有哪些？CMS和G1区别在哪？
算法题。算法题hard，挺难的，找到二叉树的路径和为target的所有路径并打印出来。（注意，不一定是从根节点出发）， AC。

part2，

自我介绍。问了项目不敢兴趣，直接做题。
三个线程依次轮流打印ABC，打印100次，说实话一直忙着刷高频题和记八股，这钟基础题写了半天没AC。 换道新题，将数组拆分成斐波那契数列，基本思想是回溯，但没AC。
智力题，一个卡车可以装多少个乒乓球，给个数量级。
聊天，问最近6年来自己认为最成功的事情是什么？

* 排序两个有序链表， AC。
* 智力题，问公交车15分钟来一趟，请问等5分钟等到公交车等概率是多少？我答的是使用指数分布去计算，面试官觉得还行。

抖音杭州
一面

* 口述解题思路：判断数组A是否包含于数组B；给定n对括号，返回所有合法排列

* 一个赌博网站，A时刻网站发布一个数，B时刻赌客下注，C时刻开盘。如何让赌客相信该数没有被网站修改过？

* 做题，打印出一个数组A中和等于k的整数倍的最短长度的子数组

reentrantlock、阻塞队列，AQS底层实现

JVM内存模型、GC算法

* 智力题 两个人轮流投硬币，正为赢，求先投的人的胜率

具体业务场景，都干了啥

微服务、微服务治理

项目的架构、用了哪些中间件（redis、es、mq）、怎么用的，为什么

docker和虚拟机的区别

三面
主要是聊项目，聊了二十多分钟

智力题，A和B都可能在3h内任意时刻到达，求两人到达时刻间隔小于1h的概率

淘宝杭州
一面
自我介绍

java基础、static之类的

CAP原理

JWT

docker

线程池

其他都是常规八股文，忘了

二面
自我介绍

mysql什么时候用不到索引

hashmap和concurrenthashmap的key和value可以为null吗？为什么

如何维护不同域名的登录态

mybatis中的$和#的区别

分布式锁

reentrantlock和synchronizated的区别

项目中最大的挑战和解决办法，给自己带来什么思考和感悟




项目干了啥，遇到什么困难，怎么解决的

算法题：给一个排序数组，找众数的下标（出现次数大于等于数组长度的一半），要求O(logN)。

* new和malloc的区别
* mysql索引相关
* mysql事务
* B+树
* 三次握手，四次挥手
* 场景题

* 视频面试这种形式的网络通信，用哪种协议比较好？为什么？
* 登陆网站后，发现网站打不开，这个时候可能会是什么地方出了问题？


* 算法题：143. 重排链表

算法题

*
    704. 二分查找
*
    56. 合并区间
* 剑指 Offer II 051. 节点之和最大的路径

设计题：

有一个图片查看器的app，服务器定时替换图片查看器中的图片，现在有两个要求：
（1）程序启动时查看图片列表。
（2）启动程序后，服务器会定时的去替换客户端的图片列表中的图片，以实现下滑。

如果是你，你会怎么实现?

* 介绍一下c++的多态
* 运行时多态与编译时多态的区别？

* c++的静态多态是怎么做到的？为什么函数名相同却可以调到不同的实现呢？

* C++ 是如何做到函数重载的？
  -C++代码在编译时会根据参数列表对函数进行重命名，例如 void Swap(int a, int b) 会被重命名为 _Swap_int_int ， void Swap(float x, float y) 会被重命名为 _
  Swap_float_float 。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做 重载决议（ Overload Resolution ） 。
  -不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。
  -从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

* 函数返回值类型不同也能实现重载吗？
  和返回值类型无关

* 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

* 类内部的成员变量：
  普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
  static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
* 类内部的成员函数：
  普通函数：不占用内存。
  虚函数：要占用4个字节（32位系统）或8个字节（64位系统），用来指定虚函数的虚拟函数表的入口地址。
  所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。
* C++编译系统中，数据和函数是分开存放的(函数放在代码区；数据主要放在栈区和堆区，静态/全局区以及文字常量区也有)，
  实例化不同对象时，只给数据分配空间，各个对象调用函数时都都跳转到(内联函数例外)找到函数在代码区的入口执行，可以节省拷贝多份代码的空间
  类的静态成员变量编译时被分配到静态/全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间。
  内联函数(声明和定义都要加inline)也是存放在代码区，内联函数在被调用时，编译器会用内联函数的代码替换掉函数，避免了函数跳转和保护现场的开销。不要将成员函数的这种存储方式和inline(内联)
  函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。不论是否用inline声明(或默认为inline)
  ，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在调用该函数时，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。inline与成员函数是否占用对象的存储空间无关

同一个类创建的多个对象，其数据成员是各用各的，互不相通（静态成员变量是共享的）。
成员函数是共享共用的，多个对象共用一份代码，所有类成员函数和非成员函数代码存放在代码区。
不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。

* 两个一模一样的函数，一个使用const修饰，一个不使用const修饰，这两个函数可以进行重载吗？

* const修饰函数起到了什么作用？哪些变量不能修

* const除了修饰函数，还可以修饰什么？

* 顶层const和底层const的区别

* 指针和引用有什么区别？

* 对同一个变量的指针和引用进行sizeof操作，会有什么区别吗？

* 指针为什么会是4个字节，一定是4个字节吗？对指针做sizeof的结果与什么相关？
* 子类的大小是本身成员变量的大小加上父类的大小

* 在32位系统分配指针大小为4字节

* 继续回到动态多态，构造函数可以是virtual吗？为什么不可以是virtual？
  -必要性分析：
  当定义派生类对象时，它会主动依次调用构造函数，顺序为基类的构造函数->一级派生类构造函数->二级派生类构造函数….直到当前派生类的构造函数调用完毕为止，到此派生类对象生成。
  而虚函数存在的意义为动态绑定，从上一段话可知，它会从基类开始依次自动调用相应的构造函数，根本就不存在动态绑定的必要。
  -内存角度分析：
  构造函数的作用是生成相应的类对象。虚函数的动态绑定是依据一张虚函数表来确认的最终绑定到哪一个虚函数版本。
  而调用构造函数之前，我们对类对象所做的操作仅限于分配内存，还没有对内存进行初始化。此时，内存空间上也不存在虚函数表，
  因此，按照这样的执行顺序，虚函数的动态绑定是实现不了的

```c++
#include <iostream>
using namespace std;

class Father
{
  public:
    Father(){
        cout<<"contructor Father!"<<endl;
    }
    ~Father(){
        cout<<"destructor Father!"<<endl;
    }
};

class Son:public Father
{
  public:
    Son(){
        cout<<"contructor Son!"<<endl;
    }
    ~Son(){
        cout<<"destructor Son!"<<endl;
    }
};

int main()
{
    Father *pfather=new Son;
    delete pfather;
    pfather=NULL;
    return 0;
}
/*输出结果为：
contructor Father!
contructor Son!
destructor Father!
*/
```

13、虚表指针是什么时候初始化的？

*
* 不考虑使用场景，除了构造函数，给所有函数都声明为virtual的，可以这样做吗？或者推荐这么做吗？有什么负面影响吗？

- 虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。
  这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，
  我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。
  这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。
-

* 介绍一下static关键字都有什么作用？都可以修饰什么？分别起到什么作用呢？function实现里面对一个局部变量定义static可以吗？
* c++单例模式，都有哪些实现？预加载和延迟加载各自都有什么问题？都存在安全问题吗？
* 预先加载有什么缺点吗？
*
有两个使用预先加载的单例类，一个类A一个类B，类B的初始化依赖于类A的初始化完成，使用预先加载的方式可以保证能够完成吗？类A类B在两个不同的文件里面（c++对不同文件（编译单元）里面定义的static变量初始化的顺序有保证吗？）不能够做到的话，这种情况知道怎么解决吗？
* 在一个函数内部定义一个static变量，不对其进行加锁，有线程安全的保证吗？c++11以前没有，c++11以后有了，通过c++11语言标准进行保证的。
* c++11里面用到了哪些东西？
* 引用坍缩的概念有了解吗？（指的就是forward解决的问题，右值引用变成左值的情况）
* 智能指针用过哪些？
* unique_ptr有哪些特性？
  24、shared_ptr有哪些特性？
  25、shared_ptr保证线程安全吗？为什么不是线程安全的？

* vector的扩容过程？
  -- 当向vector中插入元素时，如果元素有效个数size与空间容量capacity相等时，vector内部会触发扩容机制：

* 有什么方法能够避免vector的动态扩容过程呢？
  -- 如果要避免扩容而导致程序效率过低问题，其实非常简单：如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可
  -- 如果插入之前进行reserve，只要空间给足，则插入时不会扩容，如果没有reserve，则会边插入边扩容，效率极其低下。

* 虚基类的作用 --菱形继承

* 移动构造函数的优点
  --移动构造函数是c++11的新特性，移动构造函数传入的参数是一个右值 用&&标出。
  --首先讲讲拷贝构造函数：拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间

*
而移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。

```c++
    Str(const Str &s) {
cout<<"拷贝构造函数..."<<endl;
str = NULL;
int len = strlen(s.str);
str = (char *)malloc(len + 1);
memset(str, 0, len + 1);
strcpy(str, s.str);
}
demo(const demo &d):num(new int(*d.num)) {
cout<<"copy construct!"<<endl;
}
Str(Str &&s) {
cout<<"移动构造函数..."<<endl;
str = NULL;
str = s.str;
s.str = NULL;
}
//添加移动构造函数
demo(demo &&d):num(d.num) {
d.num = NULL;
cout<<"move construct!"<<endl;
}
A(A&x) {
this->num = new int(*x.num);
cout << "拷贝构造函数" << endl;
}
A(A&&x) {
this->num = x.num;
x.num = nullptr;
cout << "移动构造函数" << endl;
}

```

* 线程安全的单例模式

-

* 从C++源文件到可执行程序有几步

#### 第二部分：操作系统

* 进程和线程有什么区别？

* 哪些资源是线程独占的？

* 线程死循环会导致所在进程（单线程进程和多线程进程）出现什么问题，有什么影响？出现假死现象（一定会出现假死吗？）
  CPU会飙升吗？
* 线程崩溃会导致进程崩溃吗？一定会导致进程崩溃吗？

* 线程崩溃之后会使用什么方式通知进程呢？

* fork()之前创建的socket，父子进程能否同时读/写此socket？
  fork()创建的socket，父子进程可以同时读/写此socket，父子进程会轮流获得socket读/写权，这点好像和1）冲突，需要详细研究内因。

第三部分：计算机网络

* TCP、UDP可以绑定相同的端口吗？
  -TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP
  -所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。
  -因此，TCP/UDP 各自的端口号也相互独立，互不影响。

* 多个TCP进程可以绑定同一个端口吗？
  如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。
  如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。

* 什么情况下，可以重新利用这个端口？

* 如何解决服务端重启时，报错“Address already in use”的问题？
  当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。
  当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行
  bind() 函数的时候，就会返回了 Address already in use 的错误。
  要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。
  这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。

* 如果没有开启 net.ipv4.tcp_tw_reuse 内核参数，那么内核就会选择下一个端口，然后继续判断，直到找到一个没有被相同四元组的连接使用的端口
* 如果端口资源耗尽还是没找到，那么 connect 函数就会返回错误。
  如果开启了 net.ipv4.tcp_tw_reuse 内核参数，就会判断该四元组的连接状态是否处于 TIME_WAIT 状态，如果连接处于 TIME_WAIT 状态并且该状态持续的时间超过了 1 秒，
* 那么就会重用该连接，于是就可以使用 2222 端口了，这时 connect 就会返回成功。
  再次提醒一次**，开启了 net.ipv4.tcp_tw_reuse 内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用**，所以在服务端开启这个参数是没有效果的。

* 客户端的端口可以重复使用吗？
  -在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。
  -TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。
  -所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP
  连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。

* 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？
  -要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。
  -如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT
  状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。

* 如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？
  -打开 net.ipv4.tcp_tw_reuse 这个内核参数。
  -因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。
  -如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

* 介绍一下time_wait是一个什么状态，为什么需要这个状态，有什么作用？

* time_wait状态会带来什么副作用吗？
  --如果客户端（发起连接方）的 TIME_WAIT 状态过多，占满了所有端口资源
  --那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。

* 但是 TIME_WAIT 状态也不是摆设作用，它的作用有两个：
  --防止具有相同四元组的旧数据包被收到，也就是防止历史连接中的数据，被后面的连接接受，否则就会导致后面的连接收到一个无效的数据，
  --保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭;

* Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：
* net.ipv4.tcp_tw_reuse
  --如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，如果内核选择到的端口，已经被相同四元组的连接占用的时候
  --就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。
  --所以该选项只适用于连接发起方。
* net.ipv4.tcp_tw_recycle
  --如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；
  --要使得这两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1)）。
* 同步IO和异步IO介绍一下？

* PAWS
  --PAWS 就是为了避免这个问题而产生的，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，
  --PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，
  --如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。

* 那什么是 per-host 的 PAWS 机制呢？

per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查。

但是如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。

Per-host PAWS 机制利用TCP option里的 timestamp 字段的增长来判断串扰数据，而 timestamp 是根据客户端各自的 CPU tick 得出的值。

当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后
客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，
所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，
那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。

因此，tcp_tw_recycle 在使用了 NAT 的网络下是存在问题的，
如果它是对 TCP 四元组做 PAWS 检查，而不是对「相同的 IP 做 PAWS 检查」，那么就不会存在这个问题了。

tcp_tw_recycle 在 Linux 4.12 版本后，直接取消了这一参数。

#### accpet 队列满了

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

半连接队列，也称 SYN 队列；
全连接队列，也称 accepet 队列；
服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列
并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除
然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。

#### 半连接队列满了

当服务器造成syn攻击，就有可能导致 TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃。

但是，如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。

syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。

syncookies 参数主要有以下三个值：

0 值，表示关闭该功能；
1 值，表示仅当 SYN 半连接队列放不下时，再启用它；
2 值，表示无条件开启功能；
那么在应对 SYN 攻击时，只需要设置为 1 即可：

#### 这里给出几种防御 SYN 攻击的方法：

* 增大半连接队列；
* 开启 tcp_syncookies 功能
* 减少 SYN+ACK 重传次数
  方式一：增大半连接队列

要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列。否则，只单纯增大 tcp_max_syn_backlog 是无效的。
增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：
增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：
最后，改变了如上这些参数后，要重启 Nginx 服务，因为半连接队列和全连接队列都是在 listen() 初始化的。

方式二：开启 tcp_syncookies 功能

开启 tcp_syncookies 功能的方式也很简单，修改 Linux 内核参数：

方式三：减少 SYN+ACK 重传次数

当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。

那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

#### 全连接队列满了

在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了
这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。

我们可以通过 ss 命令来看 accpet 队列大小，在「LISTEN 状态」时，Recv-Q/Send-Q 表示的含义如下：

Recv-Q：当前 accpet 队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接个数；
Send-Q：当前 accpet 最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务进程，accpet 队列的最大长度为 128；
如果 Recv-Q 的大小超过 Send-Q，就说明发生了 accpet 队列满的情况。

要解决这个问题，我们可以：

调大 accpet 队列的最大长度，调大的方式是通过调大 backlog 以及 somaxconn 参数。
检查系统或者代码为什么调用 accept() 不及时；

做题：
LeetCode：剑指offerⅡ76
LeetCode：剑指offer 35

#### 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间

* 虚函数表的特征：
  --虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
  --虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
  --虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，
  --不必动态分配内存空间存储虚函数表，所以不在堆中

* 根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：
* 虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别
  由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。
  一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区
  C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码

#### 构造函数、析构函数、虚函数可否声明为内联函数

首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。

* register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率

举个例子：

```c
#include <iostream>
using namespace std;
class A
{
public:
    inline A() {
		cout << "inline construct()" <<endl;
	}
    inline ~A() {
		cout << "inline destruct()" <<endl;
	}
    inline virtual void  virtualFun() {
		cout << "inline virtual function" <<endl;
	}
};
 
int main()
{
	A a;
	a.virtualFun();
    return 0;
}
//输出结果
//inline construct()
//inline virtual function
//inline destruct()

```

* 构造函数和析构函数声明为内联函数是没有意义的

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，
即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），
致使构造函数/析构函数并不像看上去的那么精简。

### 其次，类中的函数默认是内联型的，编译器也只是有选择性的内联，将构造函数和析构函数声明为内联函数是没有什么意义的。

* 将虚函数声明为inline，要分情况讨论
  有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，
* 即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，* 如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，
答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开
综上，当是指向派生类的指针（多态性）调用声明为内联的虚函数时，不会内联展开；
当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

#### C++模板是什么，你知道底层怎么实现的？

* 编译器并不是把函数模板处理成能够处理任意类的函数
* 编译器从函数模板通过具体类型产生不同的函数；
* 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，
最终导致链接错误。

#### C++中基类采用virtual虚析构函数是为了防止内存泄漏。

* 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
* 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
* 那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
  所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

#### 析构函数的作用，如何起作用？

构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。
规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。

析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。
析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。

每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。

#### 构造函数和析构函数可以调用虚函数吗，为什么

在C++中，提倡不在构造函数和析构函数中调用虚函数；
构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；

因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；

析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数
所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。

#### 构造函数或者析构函数中可以调用虚函数吗

简要结论：

从语法上讲，调用完全没有问题。
但是从效果上看，往往不能达到需要的目的。
《Effective C++》的解释是：
派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。

#### 构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？

* 构造函数顺序
  --基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
  --成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
  --派生类构造函数。

* 析构函数顺序
  --调用派生类的析构函数；
  --调用成员类对象的析构函数；
  --调用基类的析构函数。

#### 什么是虚拟继承

由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：

* 虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。
* 虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格
* 表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。

#### 虚析构函数的作用，父类的析构函数是否要设置为虚函数？

C++中基类采用virtual虚析构函数是为了防止内存泄漏。
具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。

假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。

那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。
因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。

#### 构造函数析构函数可否抛出异常

C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。
因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。

用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；

如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；

如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。

#### 构造函数的几种关键字

* default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错

```c++
#include <iostream>
using namespace std;

class CString
{
public:
    CString() = default; //语句1
    //构造函数
    CString(const char* pstr) : _str(pstr){}
    void* operator new() = delete;//这样不允许使用new关键字
    //析构函数
    ~CString(){}
public:
     string _str;
};


int main()
{
   auto a = new CString(); //语句2
   cout << "Hello World" <<endl;
   return 0;
}
//运行结果
//Hello World
```

如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题

* delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示

```c++
#include <iostream>
using namespace std;

class CString
{
public:
    void* operator new() = delete;//这样不允许使用new关键字
    //析构函数
    ~CString(){}
};


int main()
{
   auto a = new CString(); //语句1
   cout << "Hello World" <<endl;
   return 0;
}
```

在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法

* = 0
  将虚函数定义为纯虚函数
  --纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处
  --当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。

#### 构造函数一般不定义为虚函数的原因

* 创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型

* 虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，
  --若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数

* 虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数
  --而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数

#### 类什么时候会析构？

* 对象生命周期结束，被销毁时；

* delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；

* 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

#### 为什么析构函数一般写成虚函数

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，
而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，
这样就会造成派生类对象析构不完全，造成内存泄漏。

* 所以将析构函数声明为虚函数是十分必要的。
  --在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

#### 虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表

虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针

#### 下面阐述实现多态的过程：

* 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址

* 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。
  --在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数

* 在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。
  --在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；
  --当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表

* 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；
* 当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；
* 当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

#### 什么情况会自动生成默认构造函数？

* 具有存在默认构造函数的类成员对象：
  如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。
  不过这个合成操作只有在构造函数真正被需要的时候才会发生

* 如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；

* 带有默认构造函数的基类：
  如果一个没有构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；

* 带有一个虚函数的类

* 带有一个虚基类的类

* 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

#### 抽象基类为什么不能创建对象？ 仅作为接口

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，
派生类将具体实现在其基类中作为接口的操作。

抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。
如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。

纯虚函数引入原因 ： 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数
在很多情况下，基类本身生成对象是不合情理的。
例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。
若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。
同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。

#### 多态性

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作
C++支持两种多态性：编译时多态性，运行时多态性
a.编译时多态性：通过重载函数实现
b.运行时多态性：通过虚函数实现。
虚函数 ： 在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载
抽象类 ： 包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

### 模板类和模板函数的区别是什么？

* 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定
* 即函数模板允许隐式调用和显式调用，而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必；

#### 多继承的优缺点，作为一个开发者怎么看待多继承

* C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
* 多重继承的优点:使对象可以调用多个基类中的接口；
* 问题：如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
  --因此，需要加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
  --或者使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

#### 模板和实现可不可以不写在一个文件里面？为什么？

因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现
在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。

但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，

它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

#26、将字符串“hello world”从开始到打印到屏幕上的全过

#### 静态函数能定义为虚函数吗？常函数呢？说说你的理解

* 静态函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
* 虚函数的调用关系：this -> vptr -> vtable ->virtual function
* 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，
* 因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。

#### 虚函数的代价是什么？

* 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类的空间大小；
* 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
* 不能再内联，因为内联函数在编译阶段进行替代，而虚函数在运行阶段才能确定是采用哪种函数，虚函数不能是内联函数。

#### 什么情况下会合成构造函数？都说一说，你知道的都说一下

* 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数
* 因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；

* 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；
* 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；
* 带有一个虚基类的类

还有一点需要注意的是：
并不是任何没有构造函数的类都会合成一个构造函数
编译器合成出来的构造函数并不会显示设定类内的每一个成员变量

* 哪些函数不能是虚函数？

* 虚函数和纯虚函数区别？
  纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
  纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。
  既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。
  一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象

#### 关于this指针你知道什么？全说出来

* this指针是类的指针，指向对象的首地址。
* this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
* this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

this指针的用处

* 一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。
* this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）
* 编译器会自动将对象本身的地址作为一个隐含参数传递给函数。
* 也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行

this指针的使用

* 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
* 当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）

类的this指针有以下特点

* this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，传入参数为当前对象地址，成员函数第一个参数为为T * const this
  class A{public:    int func(int p){}};
  其中，func的原型在编译器看来应该是：
  int func(A * const this,int p);

* 由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。
* 这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

A a;a.func(10);//此处，编译器将会编译成：A::func(&a,10);

看起来和静态函数没差别，对吗？不过，区别还是有的。
编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。

#### 几个this指针的易混问题

* this指针是什么时候创建的？
  this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。
采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。
采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。
之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答

* this指针存放在何处？堆、栈、全局变量，还是其他？
  this指针会因编译器不同而有不同的放置位置。
* 可能是栈，也可能是寄存器，甚至全局变量。
* 在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

* this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？
  大多数编译器通过ecx寄存器传递this指针。
* 事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。
this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。
自从类的函数定义完成后，它就在那儿，不会跑的

* this指针是如何访问类中的变量的？
  如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构的指针了。

* 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？
* *this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。
* 所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。
* 当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

感谢网友勘误：https://github.com/forthespada/InterviewGuide/issues/10 ，标准情况下this为右值，无法通过&符号获取地址-2021.09.03

* 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？
  普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。
* 只有虚函数才会被放到函数表中。
* 但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。
* 正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

#### 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

* 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。
* 在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。
* 当调用delete this时，类对象的内存空间被释放。
* 在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。
* 一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

#### 为什么是不可预期的问题？

delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。
照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。
delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。
此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。
当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

#### 如果在类的析构函数中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。
显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

### 你知道空类的大小是多少吗？

C++空类的大小不为0，不同编译器设置不一样，vs设置为1；
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。

#### 请说一下以下几种情况下，下面几个类的大小各是多少？

class A {};
int main(){
cout<<sizeof(A)<<endl;// 输出 1;
A a;
cout<<sizeof(a)<<endl;// 输出 1;
return 0;
}

空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。
具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，
这样空类实例化之后就会拥有独一无二的内存地址。
当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。

class A { virtual Fun(){} };
int main(){
cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
A a;
cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
return 0;
}

因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节

class A { static int a; };
int main(){
cout<<sizeof(A)<<endl;// 输出 1;
A a;
cout<<sizeof(a)<<endl;// 输出 1;
return 0;
}

静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小

class A { int a; };
int main(){
cout<<sizeof(A)<<endl;// 输出 4;
A a;
cout<<sizeof(a)<<endl;// 输出 4;
return 0;
}

class A { static int a; int b; };;
int main(){
cout<<sizeof(A)<<endl;// 输出 4;
A a;
cout<<sizeof(a)<<endl;// 输出 4;
return 0;
}

静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节

#### this指针调用成员变量时，堆栈会发生什么变化？

当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。

即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。

例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

#### 类对象的大小受哪些因素影响？

* 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
* 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
* 虚函数的话，会在类对象插入vptr指针，加上指针大小；
* 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展

#### C++从代码到可执行程序经历了什么？

* 预编译
  主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：
  删除所有的#define，展开所有的宏定义。
  处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
  处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
  删除所有的注释，“//”和“/**/”。
  保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。
  添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。

* 编译
  把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。

词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。
语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。
语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。
优化：源代码级别的一个优化过程。
目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。
目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。

* 汇编
  将汇编代码转变成机器可以执行的指令(机器码文件)。
* 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，
* 汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。

* 链接
  将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：
  --静态链接
  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。

--动态链接
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

#### 为什么友元函数必须在类内部声明？

因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。
有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。

勘误

本题问题表达有误，实际上：
友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。
只有友元工厂才必须用到类内声明友元函数。

#### 友元函数和友元类的基本情况

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。
通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。
友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

* 友元函数
  友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。

```c
#include <iostream>
    using namespace std;
    class A
    {
      public:
      friend void set_show(int x, A &a);      //该函数是友元函数的声明
      private:
      int data;
    };
    
    void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员
    {
      a.data = x;
      cout << a.data << endl;
    }
    int main(void)
    {
      class A a;
  
      set_show(1, a);
  
      return 0;
    }
```

一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。

2）友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
但是另一个类里面也要相应的进行声明
```c++
#include <iostream>

using namespace std;

class A
{
public:
friend class C; //这是友元类的声明
private:
int data;
};

class C //友元类定义，为了访问类A中的成员
{
public:
void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}
};

int main(void)
{
class A a;
class C c;

c.set_show(1, a);

return 0;
}

```
使用友元类时注意：
* 友元关系不能被继承。
*  友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
* 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

#### 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针

char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。

#### volatile关键字的作用？
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
而且读取的数据立刻被保存。

volatile用在如下的几个地方：

中断服务程序中修改的供其它程序检测的变量需要加volatile；
多任务环境下各任务间共享的标志应该加volatile；
存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

#### 如果有一个空类，它会默认添加哪些函数？
1)  Empty(); // 缺省构造函数//
2)  Empty( const Empty& ); // 拷贝构造函数//
3)  ~Empty(); // 析构函数//
4)  Empty& operator=( const Empty& ); // 赋值运算符//


#### C++中标准库是什么？
C++ 标准库可以分为两部分：
标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。

面向对象类库： 这个库是类及其相关函数的集合。

输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数

标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库

#### 你知道const char* 与string之间的关系是什么吗？
string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化

三者的转化关系如下所示：
```c
a)  string转const char* 

string s = "abc"; 

const char* c_s = s.c_str(); 

b)  const char* 转string //直接赋值即可 

const char* c_s = "abc"; 
 string s(c_s); 

c)  string 转char* 
 string s = "abc"; 
 char* c; 
 const int len = s.length(); 
 c = new char[len+1]; 
 strcpy(c,s.c_str()); 

d)  char* 转string 
 char* c = "abc"; 
 string s(c); 

e)  const char* 转char* 
 const char* cpc = "abc"; 
 char* pc = new char[strlen(cpc)+1]; 
 strcpy(pc,cpc);

f)  char* 转const char* //直接赋值即可 
 char* pc = "abc"; 
 const char* cpc = pc;

```

#### 将引用作为函数参数有哪些好处？
传递引用给函数与传递指针的效果是一样的。
这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

* 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；
而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；

* 如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；
* 在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

#### 你知道数组和指针的区别吗？
数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；

用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。

编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。

在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；

在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。

#### 如何阻止一个类被实例化？有哪些方法？
将类定义为抽象基类或者将构造函数声明为private；

不允许类外部创建类对象，只能在类内部创建对象

#### 如何禁止程序自动生成拷贝构造函数？
为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，
为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用。

类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；

针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。

#### 模板会写吗？写一个比较大小的模板函数
```c++
#include<iostream>

using namespace std;
template<typename type1,typename type2>//函数模板

type1 Max(type1 a,type2 b)
{
  return a > b ? a : b;
}

void main()
{
  cout<<"Max = "<<Max(5.5,'a')<<endl;
}
```

其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a > b 这一步是会报错的。

这个时候往往需要对于 > 号进行重载，这代码量瞬间上来了。

感谢微信好友“江河”指出a、b转型bug，已采纳-2021.06.28

#### strcpy函数和strncpy函数的区别？哪个函数更安全？
函数原型
char* strcpy(char* strDest, const char* strSrc)
char *strncpy(char *dest, const char *src, size_t n)

strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。

strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。

如果目标长>指定长>源长，则将源长全部拷贝到目标长，自动加上’\0’
如果指定长<源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’
如果指定长>目标长，运行时错误 ；
### C++中有几种类型的new
在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new
* plain new

言下之意就是普通的new，就是我们常用的new，在C++中定义如下：
```c++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此plain new在空间分配失败的情况下，抛出异常std::bad_alloc而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：
```c++

#include <iostream>
#include <string>
using namespace std;
int main()
{
try
{
char *p = new char[10e11];
delete p;
}
catch (const std::bad_alloc &ex)
{
cout << ex.what() << endl;
}
return 0;
}
//执行结果：bad allocation

```

* nothrow new
nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：

void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();


举个例子：
```c++


#include <iostream>
#include <string>
using namespace std;

int main()
{
char *p = new(nothrow) char[10e11];
if (p == NULL)
{
cout << "alloc failed" << endl;
}
delete p;
return 0;
}
//运行结果：alloc failed
```
* placement new

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。
placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：

void* operator new(size_t,void*);
void operator delete(void*,void*);


使用placement new需要注意两点：

palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，
这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

举个例子：
```c++

#include <iostream>
#include <string>
using namespace std;
class ADT{
int i;
int j;
public:
ADT(){
i = 10;
j = 100;
cout << "ADT construct i=" << i << "j="<<j <<endl;
}
~ADT(){
cout << "ADT destruct" << endl;
}
};
int main()
{
char *p = new(nothrow) char[sizeof ADT + 1];
if (p == NULL) {
cout << "alloc failed" << endl;
}
ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
//delete q;//错误!不能在此处调用delete q;
q->ADT::~ADT();//显示调用析构函数
delete[] p;
return 0;
}
//输出结果：
//ADT construct i=10j=100
//ADT destruct

```

#### C++的异常处理的方法
在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：

数组下标越界
除法计算时除数为0
动态分配空间时空间不足
...
如果不及时对这些异常进行处理，程序多数情况下都会崩溃。

（1）try、throw和catch关键字

C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：
```c++


#include <iostream>
using namespace std;
int main()
{
double m = 1, n = 0;
try {
cout << "before dividing." << endl;
if (n == 0)
throw - 1;  //抛出int型异常
else if (m == 0)
throw - 1.0;  //拋出 double 型异常
else
cout << m / n << endl;
cout << "after dividing." << endl;
}
catch (double d) {
cout << "catch (double)" << d << endl;
}
catch (...) {
cout << "catch (...)" << endl;
}
cout << "finished" << endl;
return 0;
}
//运行结果
//before dividing.
//catch (...)
//finished

```

代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。**当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。

* 函数的异常声明列表

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：

int fun() throw(int,double,A,B,C){...};



这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常

* C++标准异常类 exception
C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示

bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：
```c++

#include <iostream>
#include <typeinfo>
using namespace std;

class A{
public:
virtual ~A();
};

using namespace std;
int main() {
A* a = NULL;
try {
cout << typeid(*a).name() << endl; // Error condition
}
catch (bad_typeid){
cout << "Object is NULL" << endl;
}
return 0;
}
//运行结果：bject is NULL


```
bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常
### static的用法和作用？
1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0（static变量）

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4.static的第四个作用：C++中的类成员声明static

函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；

在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；

在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；

在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

类内：

static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；

static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

#### 指针和const的用法
当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。

int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量

int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。

底层指针表示指针所指向的变量是一个常量。

#### 形参与实参的区别？
形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。

实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。

实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。

当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

#### 值传递、指针传递、引用传递的区别和效率
值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）

指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）

引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）

效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。

#### 静态变量什么时候初始化
初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，
但在C和C++中静态局部变量的初始化节点又有点不太一样
在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，
所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。

而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，
在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。
所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。
在程序结束，按照构造顺序反方向进行逐个析构。
所以在C++中是可以使用变量对静态局部变量进行初始化的