



如何查看cpu，问了top命令里的指标的含义（二面问过，当时答得不好）

12. 代码：判断二叉树是否对称
13. 代码：有效括号

 代码，找到链表的中间节点
21. 代码，找到倒数第n个节点
22. 交换整数第n个节点和倒数第n个节点
23. 要去一次循环内解决
手撕：找出非空无序数组中第三大的数字 10mins
手撕 lc 253
394字符串解码，思路是递归和栈，没写出来
反转链表，说一下它的时间o(n)和空间复杂度o(1)
    二分查找  和大于等于target的最短子数组

算法 最长不重复子串长度





算法题：将阿拉伯数字转换成中文，如输入110010，输出 十一万零一十


MYSQL索引，走不走索引的判断

Redis常见数据类型，如何保证数据一致性

两道题目一道SQL题，一道算法题（找出数组中重复次数第二大的元素）；

字节二面
面试官很好，会及时给反馈，体验良好，必须赞

RPC项目，介绍项目大体情况，然后介绍项目难点以及怎么解决的

在线教育项目，实际就是聊Spring

Spring IOC和DI

Spring中的设计模式

索引相关知识，回表，索引失效

两道算法题：字母异位词，子集

字节三面
后来才知道是交叉面，怪不得没算法题

链表排序

MySQL索引InnoDB中B+树一颗节点的大小

B+树和二叉排序树，数据量不大的情况下使用哪个

session，cookie，token

RPC一般需要监控哪些指标

Http的状态码，Http和Socket区别 无算法题

字节四面
leader面，难熬的一面，不知道是不是压力面，根据我的介绍，提取关键词进行提问，一直问到你不会，不会的时候就很尴尬，面试官也不给任何反馈，就等着你说话，很难受的一面，加上算法题面了一小时二十分钟，好在最后的算法题做出来了，虽然前面答的确实不咋的。。

介绍项目，介绍了在线教育网站的项目，说到微服务，问微服务

微服务是什么有什么好处，相对于单体服务来说有什么优势，为什么要用微服务巴拉巴拉

Nacos有哪些竞品，都有什么区别，做过调研没有

Redis相关场景题，做一个热点课程的榜单功能该怎么实现

Linux日志过滤，chmod命令

64匹马，8个赛道，找最快的四匹，做少需赛几次

射击比赛，一枪可中环数0-10，m枪，打中n环的组合数。动态规划
介绍项目
建议能够提前准备，将项目的亮点能够说清楚
2、牛客上代码运行的过程，换句话说点击QQ到页面打开的过程，从操作系统的层面思考
操作系统检测类型是否是可执行文件，Windows的可执行文件是PE
创建进程，并且将可执行文件映射到该进程
为该进程设置CPU上下文环境
将代码和数据从磁盘读入内存
运行过程中发生缺页异常则重复4
执行相关系统调用函数，在显示器上显示图标        
3、浏览器输入URL到页面打开的过程如何加速
使用http3.0协议（多路复用、tcp连接换成udp连接减少三次握手时间、0-RTT建连，向前纠错机制减少重传）
数据压缩，减少传输时间和次数
CDN服务器，地域分布式缓存静态资源
页面先呈现静态资源及框架，动态资源延迟加载，从使用者角度加速
每次打开做好缓存，例如DNS缓存、静态资源缓存
自己理解，有错请纠
4、先序遍历和中序遍历求后续遍历
5、一道编程题，k个一组翻转链表
6、领导给你一个任务一周时间，但你评估需要两周时间怎么办？

虽然我答的不怎么好，但是确实学到了很多，也学会了从宏观角度或者说大局角度去学习弄懂一些知识，以上回答是我自己的一些总结，谢谢观看！
自我介绍一下
- 介绍一下你的项目
- 哪一个项目你的收获最大
- epoll和select, poll区别是是什么
- 为什么epoll效率更高
- 了解惊群效应吗
- 进程和线程的区别
- 进程创建后的写时复制机制
- 讲讲C++的函数重载与函数重写的区别
- 简单介绍一下vector的内部实现和时间效率
- vector的动态扩容在多线程下有什么问题
- 什么是内存对齐
- 大端与小端的区别
- 了解什么中间件吗
- 介绍一下redis底层数据结构
- 跳表和红黑树有什么区别，为什么选择跳表而不是红黑树
- reset是哪种数据结构
- 如何优化DB瓶颈
- 为什么有时候单线程能够比多线程更快
- redis是哪种IO模型
- 做个题吧，不用写代码，就聊一下思路，10个盒子，1000个苹果，怎么摆放可以代表所有数字
- 来写道编程题吧，给一个链表1-2-3-4-5-6-null，和k = 3，返回一个链表4-5-6-1-2-3-null
- 你还有什么要问我的
- 自我介绍



HTTPS和HTTP的区别

HTTPS具体的连接流程

CA证书的作用

CA机构如何提供担保

CSRF跨域攻击

TCP如何保证可靠传输

Redis缓存穿透，缓存击穿，缓存雪崩以及解决方案

Redis分布式锁

如何保证加锁和释放锁是同一个线程操作的

Redis分布式锁容灾问题，如果一个Redis挂了会不会重复拿到这个锁

Redis主从同步

怎么决定主从同步是否需要强同步、异步同步或半同步

netstat的原理

chmod指令 777含义


自我介绍
介绍项目，我是做的对话系统，简单介绍了一下，感觉面试官蛮感兴趣的。
tcp三次握手，除了常规的过程、报文结构，还有觉得为什么要用三次，半连接队列、全连接队列，哪些握手能带数据？为什么第一次不可以？什么是syn攻击，举几个例子？这些分别怎么预防。
tcp四次挥手，介绍过程，为什么等待timewait才能断开？ 为什么要设置成2msl？
udp，报文结构、优缺点。
说了几个场景，让我判断适合tcp还是udp。
osi七层模型，每层都有哪些常见的协议。
刚才你说到有http协议，http请求连接的过程？和https的区别？你说到ssl，ssl加密过程可以说一下吗？你觉得非对称加密安全吗？数字证书你也有了解吗，介绍一下？
问我会不会数据库，我说不会，然后面试官愣了一下，就没问数据库的东西。
你觉得python高效吗（感觉他是想问静态语言和动态语言）？python的动态内存，介绍一下？
写了两段python代码让我看结果，长度中等，难度中等。顺便问了一下python的深浅拷贝，回答的时候举了例子。
python的字典是怎么实现的？
python的垃圾回收机制可以介绍下吗？你刚刚提到了标记清除，可以说他和引用计数机制比，能解决什么问题？好的，还有别的吗？分代回收，可以解释下他的思想吗？举个例子可以吗？




当天晚上七点约的二面。
1. 介绍一下字节序
2. vector插入的平均时间复杂度？如何扩容？
3. set的底层实现
4. 求两个不同大小set的交集，如何使时间复杂度最低？能否给出证明？
5. TCP/UDP区别
6. connect() 对UDP有作用吗？
7. 断开连接时TIME_WAIT状态的作用
8. HTTPS建立连接的过程说一下？证书的作用？
9. Linux进程空间从低到高的内容
10. 介绍一下线程池
11. （手撕）二分查找变形
12. 智力题
13. 反问


12、反射的应用场景跟优缺点？
13、list、map、set与queue四者的区别？
算法：小于n的最大数。
以下记录或多或少有疏漏，只能靠记忆大概回顾下。


算法：给定m个不重复字符。求一个字符串中刚好由这m个字符组成的连续子串的起始位置
#字节面试#  
本人情况，一般985硕，学的光电。本来想报后端的，手抖了点了客户端。发现改不了，rnm退钱!
硬着头皮面了，不过还好，面试官很照顾我，问的都是C++知识。
7.18抖音直播一面：
1. 上来介绍项目（10min）
   2 go的协程和线程有什么区别？
3. go的内存管理。
4. TCP和UDP有什么区别？
5. 列举常见的网络协议。
6. TCP长连接和短连接有什么区别？分别对应什么样的场景。（没答上来）
7. C++泛型和Java泛型有什么区别？
8. C++泛型的原理？
   题目：用泛型实现一个链表，并实现插入add(int index, T item)和删除del(int index)。非常简单！

7.20 抖音直播二面
1. 上来介绍项目（10min）
   1.1  项目提到了技术选型，面试官问怎么做技术选型。
   1.2  为什么想报客户端，你简历上写的是C++后端项目？
2. 问数据库（项目里面提到了），数据库事务是什么？
3. 你知道“脏读”和“幻读”吗？什么时候会发生。
4. C++虚函数知道吗？
5. 为什么父函数的析构函数会声明为虚函数？
6. 虚函数的原理。（虚表）。
7. 刷题（半小时）
   给你一个二叉树，然后统计每一层的宽度。宽度的定义是同一层第一个非null节点到最后一个非null节点的距离。
   比如：
   [3,2,4,null,3,null,6,null,3,null,5] ->返回{1,2,3,5}

8. 内核态和用户态区别。
9. 内核态和用户态地址转换是怎么样的。
   反问：
   你们部门是做什么的？
   能接收转岗吗？
   面试官说不知道，可以先实习或问hr。

7.25 抖音直播三面
1. 上路介绍项目（15min）（链路追踪）
   面试官对开发那块比较感兴趣，问比较了哪些产品？各有什么特点。
   在技术选型上最看重的指标是什么？（性能，通用性，无侵入）
   问链路追踪daemon是如何和tracepoint通信的。（消息队列）
   链路追踪中数据结构ring buffer是如何被进程间共享的。（共享内存）
2. 共享内存的原理清楚吗？
3. C++知道哪些数据结构？
4. list和set有什么区别？
5. set是如何做到去重的。
   ===========主观题===========
6. 你是如何学习一门新技术的。
7. 你在团队协作上遇到了什么问题，是怎么解决的？
8. 你学的印象最深的技术是什么？（我说google test）
9. 接上题，面试官问你怎么教新手google test。

10. 刷题（20min）
    给你一个链表，让你循环右移，打印新链表。
    比如：
    1->2->3->4,  k = 1
    得到新链表：4->1->2->3
    需要考虑边界条件。本来忘了把链表断开了，在面试官提醒下改正了。
    答完了，面试官说有更好的方法。我突然想到可以用快慢指针，面试官说是的。





python数据类型
元祖和列表的区别
GIL锁
TCP和UDP区别
3次握手4次挥手
进线程
3.代码
最长无重复子串
时间空间复杂度

python管理内存
装饰器
linux命令
shell会写吗
数据库会吗
4.测试基础：
对测试的了解
抖音搜索框测试用例
5.综合：

算法：给一个数组，假定分成m组，要求这m组数每组的和相等，求最大的m
字符串中最长连续递增数字串
两字符串最长公共子串
算法：螺旋矩阵
两道SQL


项目
对于Session和Cookie的理解

登录功能，主要是续期的实现，这样实现在高并发下是否会存在问题，如何优化

项目秒杀的技术要点：

token防止脚本提前请求：token是如何存放，如果秒杀是一段时间的，使用同一个token会有怎样的问题？如何解决

使用Redisson分布式锁解决超卖问题：是否了解Redisson分布式锁的实现原理，使用单个键作为分布式锁的热键问题，如何解决

使用消息队列进行业务解耦：为什么使用RabbitMQ？

计网
是否了解HTTPS，交互过程

HTTP2.0的特性

字节客户端面经一面
1个小时，没有问项目，C++

位图，像素与位图的关系
了解图片滤镜吗，怎么实现
内存回收，还问了JAVA的垃圾收集器


const和static关键字
刷题，K个链表一反转

二叉树的之字形遍历



5.13号 二面
时间：50分钟
自我介绍， 说完自我介绍之后 面试官一直在点头，面试官评价很好
问的问题：
1.osi七层模型
2.http协议， https和http， https的流程，嗓子都讲冒烟了
3.vim编辑模式，常用快捷键，我说了些然后就开始说我不太喜欢用...
4.排序算法中堆排序，是否是不稳定排序，为什么是不稳定，已经一些排序相关扩展
5.redis数据模型，重点问跳表，跳表跟平衡二叉树的优劣

手撕代码：
岛屿数量
正方形

体验：说实话面试官一直在安慰我，让我别紧张，我有点愧疚呜呜

过了一小时跟我约了三面
1. 自我介绍
2. 介绍一个自己参与度最高的项目
3. 进程与线程你了解吗？
4. 并发和并行的区别？
5. 虚拟地址和物理地址你了解吗？
6. 锁，你了解那些锁？读写锁？
7. 有哪些同步方式？
8. 为什么Synchronized是重量级的锁？
9. 计算机网络中为什么三次握手却需要四次挥手？
10. http和https的区别？你能说下ssl的握手过程嘛？
11. 拥塞控制你了解吗？
12. python你用的多吗？你知道迭代器和生成器的区别吗？
13. Django你有使用过吗？
14. 你有使用python进行过网络编程嘛？



聊天室项目
项目怎么实现的？通过很多个goroutine

用户的消息是怎么转发给其他用户的？通过服务器的广播协程

登录注册怎么实现？

通过什么登录（电话，邮箱）？

服务器怎么知道是你（客户端）？网络地址

http长连接还是短连接，请求的全过程（链路）

go语言
GMP模型？

怎么偷取其他的goroutine？详细说一下？

垃圾回收机制是怎么实现的？

乐观锁？

计算机基础




心得
面试官问项目问的特别细，所以吸取的教训就是一定要对项目十分熟悉不然就不要写在简历上

大厂不一定需要实习经验，只要对计算机基础和算法掌握的足够深，也可以拿到offer

掌握一些前沿技术（Redis，Docker，K8S）会让自己更有竞争力

项目的网址有吗：
还没上线，计划6月份上线

对redis的理解，项目中的使用：
后端和数据库之间的缓存，存取速度比从数据库快。

redis的hash结构，以及博客中如何具体使用

直接说了具体用法，应该在前面先介绍hash的结构，然后再说如何使用。

hash的底层数据结构：
说了ziplist和hashtable，介绍了一下ziplist，hashtable说了数组加链表/红黑树。

有没有用集群：
说了一下自己没用，但是说明了自己之前实操过集群的使用。

缓存雪崩：
同一时间多个key失效，导致大量请求直接达到数据库上。有两种场景：过期时间设置的一样；redis宕机。解决方法分别说了一下。

如何理解数据库的事务：
概念介绍(ACID)；具体用innodb实现，有redologo和undologo，底层实现没让说。

B+树了解吗：
自平衡的二叉树，属于聚集索引。

mysql为什么用B+树：
搜索速度快，属于聚簇索引，索引和数据放在一起，加载索引时按页加载，直接把数据也加载进去了。不需要二次回表。

内存回收机制：
判断对象是否存活，引用计数和可达性分析，具体原理和缺陷；3中清理算法，标记清除/复制/整理，具体原理；实现的收集器，serial系列，parnew，parallel，CMS，G1，各自对应的情况和特点；java的分区，新生代、老年代，suvivor、edon、old，

进程，线程，协程的区别(这一块需要再看看，没说全)：
概念上讲，进程最大，线程次之，协程是轻量级线程；从内存角度看；通信方式；耗费的资源。

虚拟内存的理解(需要再看八股完善)：
首先介绍了虚拟内存是什么；和计算机的位数有关；虚拟内存和物理内存的转化用MMU。

通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。
另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。
分页和分段(需要再看八股完善)：
分页的概念，分段的概念。

页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。
浏览器输入网址，从网络层面描述过程:
dns域名解析，http协议，SSL加密协议等转化协议，tcp协议分成不同段，IP协议，路由选择协议。

tcp和udp的区别：
速度方面；可靠性方面；场景

tcp保证稳定的手段：
校序重流拥。

tcp的三次握手和四次挥手(需要复习一下)：
可以完善一下每次发送的具体ACK,SYN，seq

四次握手的timewaited的原因：
消除对网络的影响；确保双方都发送完整信息

哪些排序方法是稳定的：
插入，归并，堆（不稳定）

相对1g的数字排序，有哪些方法：桶排序，具体的原理忘了

针对上面的问题，如果内存很小不够全部放怎么处理：采用缓冲池，用bufferedreader读取，每次读取固定字节数的内容。


#字节面试##实习##面经##Java##字节跳动##后端开发#
项目15分钟
项目中遇到的问题以及解决的方法
实时音视频的评价指标
实时音视频的整体流程
实时音视频的编码压缩和编码
MPEG中的I帧、P帧和B帧
UDP和TCP的特点和使用场景
三次握手、四次挥手
进程和线程的关系和区别
python的装饰器
python多线程和多进程
RTP、RTCP、RTSP等协议
图像、视频的评价指标
实时音视频中如何使用图像评价指标进行测试，如何进行对齐
如何对发送视频流进行打标签
如果出现漏帧的情况，该如何测试指标
前向纠错 和 漏包重传
智力题：5L和7L桶得到6L水
飞书美颜新功能该如何测试
base选择
代码题：最长公共前缀
反问：部门工作


mysql
聊一聊mysql 你对索引的认识。
其实比较大众化的问题，基本上是往着数据结构B+树角度去谈，为什么是B+。

比如可以聊hash表、二叉树、多叉树等等，各自的优缺点；

同时基础更好的同学可以围绕着 io ，page，innodb，b树b+树区别上聊，可以说很多。

提到了聚簇索引，非聚簇索引。那非聚簇索引存的是什么？
首先是要回答出，聚簇索引、非聚簇索引的区别，以及各自的存储引擎 是否涉及聚簇索引这个事情。然后才是存什么。

概括上来说，跟数据绑定在一起的，就是聚簇索引；没有绑定在一起的就是非聚簇索引。

可以接着延伸，回表，覆盖索引等等。

网络
osi 七层模型描述一下。
描述每一个层，大概干什么作用，有什么协议即可。同理可以扩展5层，5层是把哪些合并了等等。

当时复习没注意这个点，网络层传输层还说反了，答得不是很好。

tcp udp有哪些区别？对应哪些应用场景？
这个建议好好读计算机网络自顶向下，说的挺清楚的。

最起码的有链接无连接，tcp的一些特性（可靠数据传输、拥塞机制、流量控制），比如应用场景 实时通信，比如报文头区别等等，可以涉及很多。

tcp udp 哪个传输效率更高？
效率更高这个我无从下手，当时就说 咱们评判效率标准是什么？比如我是追求传输的快？还是追求质量？按照我的框架下给出对应的答案。

能不能基于udp完成可靠数据传输呢？
这个问题就是顺着我说的质量，接着往下问的。应用层上可以做到的，书上也会讲到。

多线程
进程 线程 协程的区别
这个是因为我的简历上有go语言，协程，所以问了这个问题。

多进程 多线程的区别
本科老师教授过openmp和mpi，我就按照这两个的区别回答了一下。其实网上面经回答应该也挺好的，没有固定答案，可能是看个人思考吧。

​ 比如多个之间如何合作，共享变量怎么办，消息通信等等。java的也可以聊聊thread local，锁啊，进程通信（ip+port）等等。

算法 最大栈
最大栈，最大队列。和剑指offer的题目应该类似吧。

最大栈就是新建一个额外的栈，保存最大值；最大队列这样干的不是最好，得有一些操作，反正当时是没想到。

然后灵机一动，讨了个巧，用两个栈 实现一个队列，原来o(n)，用两个栈的话最多也就o(2n)=o(n)，符合要求，实现出来了。

3、其他
欢迎收藏点赞~有问题可以评论区指出哈
. 自我介绍
2. 介绍一个自己参与度最高的项目
3. 进程与线程你了解吗？
4. 并发和并行的区别？
5. 虚拟地址和物理地址你了解吗？
6. 锁，你了解那些锁？读写锁？
7. 有哪些同步方式？
8. 为什么Synchronized是重量级的锁？
9. 计算机网络中为什么三次握手却需要四次挥手？
10. http和https的区别？你能说下ssl的握手过程嘛？
11. 拥塞控制你了解吗？
12. python你用的多吗？你知道迭代器和生成器的区别吗？
13. Django你有使用过吗？
14. 你有使用python进行过网络编程嘛？
15. 排序算法你有了解吗？讲一下快速排序的思想，分析下时间复杂度？
    字节上周末投的，有点晚了，原本投的部门挂了，现在是被其他部门捞起来的
    实习印象深刻的项目(针对其中一个详细问了下)
    Linux命令
    接口和抽象类
    浅拷贝深拷贝
    redis项目中用来做什么
    缓存雪崩击穿穿透以及区别
    垃圾回收算法以及区别
    inode是什么(元信息)，有几种(这个没答出来)
    select poll epoll(这个地方介绍有点卡壳)
    项目中认证是如何做的
    (我学过安全)sql注入，crsf攻击

字节二面（9.28 1小时20min）
交叉面，面试官还在日本出差，面试官人很nice，体验不错
（问题回忆版）
论文内容介绍
实习内容介绍
自定义延迟队列如何实现，是否可以使用redis解决等
linux内核有什么功能
coding：(1) SQL题 (2) 旋转有序数组求target logn复杂度 【lc 33】
有几天了部分内容忘记了，抱歉。

字节三面（9.29 1小时左右）
接口和抽象类
多态的底层实现
线程池的状态有哪些
多人协同开发冲突
实习学习到了什么
分布式消息队列的消费数据如何保证幂等性
未来的职业规划

字节四面（10.8 ）
自我介绍（没有偏技术）
实习内容介绍（有点卡顿，面试官说没有突出亮点，介绍的也不全面）
微服务构建的流程
容器相关知识和常用命令
垃圾回收的过程
引用计数和GC Roots
Redis用途，持久化（RDB和AOF），启动数据加载流程（回答反了）
Mysql InnoDB和myISAM区别，事务隔离级别，幻读本质
职业规划
选择是在一个领域专精，还是涉猎广泛
没想到还是技术面，看牛客有人说可能是前面面评差异较大加面，但自己感觉上面中规中矩，也就个别问题没有答好，算法也全部手撕了。
一直以为是HR面，没有准备技术相关，直接定在今天面试，许多内容回答的不太好，感觉凉的可能性有点大
作者：孝陵卫赵神的室友
链接：https://www.nowcoder.com/discuss/1013610?type=0&order=7&pos=3&page=1&source_id=discuss_center_0_nctrack&channel=1009&ncTraceId=3b01b98eb9684f1ebc137cddaf639b40.633.16652479116578846&gio_id=295FCE3724A38CF13F2462214C78A939-1665247932077
来源：牛客网

一面
Http状态码：301 302 304 403 499  502  503
Http/1.1 http/2，https的传输过程
进程，线程区别，线程调度
进程内存模型
同步  阻塞 非阻塞
异步，以及它们的区别
Utf-8与unicode的区别
MySql的执行流程
Innodb的行锁是怎么实现的，
隔离级别
Limit分页的执行流程
一道sql（自连接）
一道算法（打家劫舍改编版）

二面（已凉）
项目交流
C++与Go语言的区别
C和C++的内存模型
栈和堆的区别
什么变了量会存栈里面，什么变量会存堆里面
静态对象放在什么区
C++代码从编写到最后执行的流程
C++里面怎么实现线程
网络分层以及代表协议
Mysql数据库的常用引擎以及它们的区别
为了保证网络接口的安全性，需要做哪些措施
代码题，K组翻转链表（全部写出来，定义数据结构，创建链表，然后链表翻转）
###秋招进度交流#
一面：~~1h~~
了解字典树吗？给一个单词前缀，找符合该前缀的单词个数（口述实现）
mybatis 分页插件原理实现
redis能存什么类型数据
redis是单线程吗
redis单线程为什么高效
redis过期策略
多路复用select,epoll原理
缺页中断，页面置换算法
python字典key能存什么类型值（讲了hashashcode相关的东西）
java深拷贝
http请求头的一些参数：host,agent,referer等
http1.1一些特性
5xx状态码
java线程池
线程池中无限长的队列有什么应用场景
线程池拒绝策略

写代码：带过期时间的lru

二面： 1.5h
记得不太清了，全是业务场景+系统设计
大概是：权限系统模型设计对比
spu, sku 如何在数据库表中设计，方便扩展
MQ的对比和场景选型
伪代码+系统设计：观察者模式，服务注册中心
最后5分钟为了支撑下面试让写了个归并排序



八股
TCP/UDP区别，线程进程区别，url到页面返回到过程，函数hook（不了解）

手撕：二进制数中有多少个1

概率题：54张牌分三堆大小王在一堆的概率

三面 没录音很多都忘记了 50min
1.内存什么时候会出现一个锯齿状的波动，举一例子，为什么会造成这种情况
2.为什么垃圾回收次数发生很多会不好。
2.那内存的波形图是很小的锯齿形，很很大的锯齿形那种好，为什么好，为什么不好
这一块记不清楚了，问了超级多
3.那波动很大怎么解决？
4.在一个for循环中每次都需要建立一个很大的对象，这一个对象就快把内存占满了，不想每次都发生GC又不想每次都重新设置该怎么办。
4.redis的三大缓存问题



2. Redis io模型

3. 解释select和epoll，和他们的区别
   4.epoll水平触发和边缘触发

5.mysql的四大隔离级别，分别解释，并会出现什么问题

6. 解释什么是幻读

7.解释mvcc

8.解释 当前读怎么解决幻读问题

8.mysql 的锁有哪几种除了表锁和行锁

9.两道sql 题

1.从借阅表中查询出每个人借了多少本书. 思路 count()+group by

2.从借阅表和用户表中查出人名和借了多少本书。思路 count（） + group by + join

10.编程题。

一个N*M的的数组里面有0和1, 1代表障碍，求从左上角到右下角最短路径，并打印。可以上下左右走。思路 dfs+回溯


SQL题的第二题和最后一道编程题都是我先猜一种方法，然后问面试官这样行不行，面试官说不行，然后从面试官里面套思路才写出来的，不懂可以向面试官问思路。

最后面试官说让我等 HR电话通知。

二面 2022-7-25 50 min

1. 你们推荐系统项目技术选型怎么做的

2. 除了flink和kafka你还做的哪些流式计算框架和消息队列

3. Kafka怎么保证顺序读写

4. Kafka采用分布式的吗

5. 你们怎么实现kafka对mysql进行异步写操作

6. 用户如何知道异步的时候mysql 写操作失败

7. Mysql采用的分布式集群吗

8. C为啥比java 快

9. Java 有哪些垃圾回收算法

10. 这些垃圾回收算法分别适用哪些场景

11. 怎么保证多个微服务之间如果出现一个失败，回滚的问题（我说这属于分布式事务，我说有框架解决）

12. Sql题一张表包含id name saray managerid，员工和manager都在这张表里面怎么怎么查出员工工资高于manger工资的人。同一张表join两次+ having 或者子查询都行

13. 二叉树的最大高度

这轮面试相对较轻松，sql和coding题都是没一面难。面完20分钟收到三面预约通知

三面 2022-7-27 35 min

2.自我介绍
3.问项目
4.kafka和其他消息队列的比较
5. kafka怎么保证消息不丢失
   6.http和https
   7.线程和进程
   8.数据库事务的四大特性
   9.一道sql题 查询每科成绩都及格的学生姓名，思路group by having min
10. 场景题 mysql 中有一万条数据，每个 redis 最多只能存一千条，怎么设计这个redis集群。
    11.反问环节
    面试官进来没有开视频，而且那边比较吵，前9个基础问题都答上来了，场具题答的面试官并不是非常满意。
    面试的时候就感觉有点不对劲，除了场景题其他问题问的都非常简单，而且没有有coding环节。
    第二天晚上八点收到感谢信，问了hr面评说一面二面都没啥问题，三面是面评是团队沟通能力不足。

操作系统

1. 进程和线程的理解，（它们）地址空间有什么区别

2. 进程之间的通信

3. 了解过死锁，怎么避免

计算机网络

4. OSI七层的TCP和UDP，讲讲理解，应用场所，怎么保证TCP的可靠，展开说说拥塞避免

5. 浏览器敲下URL发生了什么

6. DNS基于TCP还是UDP，为什么，了解过DNS劫持吗

7. HTTPS了解过吗，TSL握手里面的哈希函数用来干什么（校验完整性），加密的过程是怎么样的，TSL握手的过程中怎么确定对方的身份

数据库

8. 讲讲索引，索引优缺点，索引随机变化影响插入性能还是数据库整体性能，索引和数据库的源数据结构是耦合的吗，索引怎么提高查询效率

9. 使用mysql的过程中有什么感受，三大范式

JAVA

10. 抽象类和接口的了解，在多继承单继承的角度呢

11. 非静态内部类和静态内部类的区别，静态内部类会持有外部类的引用吗，比如说外部类A，里面有一个静态内部类B，B可以调用A的方法吗？非静态内部类可以访问吗？

12. 非静态内部类可以直接访问外部方法，编译器是怎么做到的？

13. JAVA类的初始化顺序，构造函数，静态代码块，包括有父类的情况。

14. JVM装载一个类的过程，什么样的行为会触发类的初始化？一个静态类的静态变量初始化赋值一个类的对象，会触发类的初始化吗？假设静态变量是一个数组，数组里包含对一个类的声明，会触发类的装载吗？

15. HashMap,内部实现，什么时候会转成红黑树，以及为什么是这个长度？HashMap是线程安全的吗，你用过它的线程安全版本吗？ConcurrenHashmap怎么实现线程安全？分段锁怎么加锁的？了解CAS吗？为什么不能所有的锁都用CAS？JVM对Synchornized的优化？

16. JVM的内部模型，虚拟机栈有两类异常，栈溢出和OOM。程序计数器的作用，为什么是私有的

手撕链表重排

面试官引导式发问，体验很好。



字节客户端-互娱8.31二面 1h

1. openID，APPID（不懂，）

2. 事务是干嘛用的，单线程没必要用事务吗？多线程为什么要用事务解决，锁不是可以解决吗？

3. Java的四种引用，内存泄漏，垃圾回收可以解决内存泄漏吗？怎么发现内存泄漏，（Jconsole）怎么看出来内存泄漏，怎么解决内存泄漏？内存满了我们能知道吗？OOM？OOM怎么处理？

4. 新建线程的方法，new和实现runable有什么区别？线程池的核心线程数和最大线程数区别。

5. 线程的通讯，子线程怎么传数据给主线程？Wait和sleep的区别。怎么唤醒wait的线程。

6. 非阻塞的socket怎么实现的？基于轮询吗？讲一下select poll epoll。

7. 快排的过程，时间复杂度，最坏情况，最坏情况是什么情况?

8. Java注解，编译期读注解还是运行时？Override是注解吗？它是运行时做的吗？

9. 智力题，1000苹果放到十个篮子，任意报一个数N<=1000，要求能用1-10个篮子的几个篮子之和等于N，求分配方案。

手撕1.字符串转数字2.target为t的连续数组

面试官有点严肃，问问题只想听我的理解。



字节客户端-互娱9.8 三面 40m

1.介绍RPC，RPC和其他协议HTTP有什么区别，然后扣项目细节。。。（录像都不敢看，不想写了）


手撕lc17电话号码的字母组合

9.13感谢信

#字节跳动##字节面试##字节客户端##2023秋招##客户端#
面了两个部门，5轮技术面 + 1轮 HR 面，流程花了一个多月，最后拿的offer是字节上海data商业化下的一个部门
时间太长记得不清楚，大致回忆下，算法题都还记得
前两轮其实是面的字节商业化广告后端，挂了

商业化广告第一轮：
自我介绍，问了百度实习的项目细节，qps是多少？怎么优化？回答：项目qps只有几千，直接用的mysql，理论上可以用redis做缓存，Nginx做负载均衡
go语言里面异常是怎么处理的：考 panic 的用法，和 if err != nil 这种错误处理
go语言开发函数返回值用什么接收：我说了map，后来补充了可以用channel
问了下协程的基础用法：go + 函数名，带缓存的不带缓存的
然后问一个系统设计需要注意些什么和各自的作用：答了低耦合性，可拓展性，并发性什么的（说实话我不确定这是考的什么，哪里有整理的比较好的答案谁可以分享下？？？）
大概就这些，可能遗忘了一点点

dfs很快解决了，深搜的规则是：左括号数量大于等于右括号，左右括号数量都是n的时候返回结果

商业化广告第二轮：
自我介绍，问百度实习的项目，问TCP握手挥手，然后追问CLOSE_WAIT是对应哪一次，我没背这个当时随便回答了一个，现在都不记得答的对不对了
问进程和线程的区别，答了个大概，但是没有仔细背所以不详细，估计又被差评了
问 go 语言怎么实现定时执行任务? 答: time.sleep，追问别的方法：应该是要问Timer和Ticker，当时没反应过来（本来也不熟悉这个），就开始说用WaitGroup和defer，应该是答偏了……

算法题：
LeetCode 链表求和的变型 面试题 02.05. 链表求和 https://leetcode-cn.com/problems/sum-lists-lcci/
比如说1 -> 2 -> 3 + 4 -> 5 -> 6 表示123加456输出这种形式的和，要求O(1)空间复杂度，需要先反转两个链表，再找出长的链表，把短的链表加到长的链表上，然后再反转结果， 不能新建结点
有点麻烦，我第一遍写新建了结点，相当于另外生成了第三个链表返回了，不满足O(1)空间复杂度，提示后改对了
LeetCode 146 LRU缓存机制，见过原题，自定义一个数据结构，模拟一个双向链表，左右各需要一个哨兵，用hash存key和Node方便查找，每次把最近访问的移动到最左边，删除的时候删最右边的
面试官看出来我做过这个，又问了LFU怎么实现，这是hard难度了……当时只想出来了用小根堆，时间复杂度是logN，其实有O(1)的做法，挺复杂的有兴趣可以去看下题解
这里的教训是：遇到做过的题要装作没做过，当场思考推理一段时间，不然面试官会觉得你背题了，换更难的新题考……
最后重磅的来了：
智力题：一盒扑克牌一共有10张朝上，42张朝下，分成两堆，怎么用最优的方法让两堆正面朝上的数量一样？ 描述就这样
答案是：把牌分成10张一堆，42张一堆，10张的全部翻面这样两堆朝上的数量就一样了（简直是脑经急转弯，特别是已经面试50分钟比较疲倦的时候，实在很难想出来）
没答上来面试结束，果不其然挂掉了，当然这一轮答的确实问题比较多，有自己的问题

data商业化第一轮： 介绍实习项目和自己负责的部分 问比较常规的八股文 数据库ACID特性 数据库聚簇索引和非聚簇索引的区别：主要是数据和索引是不是放在一起，是否需要回表 数据库b+树的特性，优点，和b树的比较 https和http的区别，https的详细过程 对称加密和非对称加密 https用的是对称加密还是非对称加密：其实是都用到了，这里我只说了对称加密 tcp和udp的区别 http用的是tcp还是udp：一般书上说的是tcp，但是http3.0开始用udp了，我说了这一点，面试官表示了肯定 应该漏了一些，我记不得了 还有一些go语言的基础问题，也是协程channel什么的，然后问gpm模型会不会，我只略微看过一点，忘的差不多了就说不会 然后开始写算法题：让我二分和动态规划选一个，我选了二分 题目是一个已排序的数组除了一个数字出现一次其他的都出现了两次，要求logN的时间找出 136. 只出现一次的数字 https://leetcode-cn.com/problems/single-number/
异或是O(N)的不行，需要根据下标的奇偶性判断要找的数字在前面或者后面，整数二分的模板不能直接套，需要根据边界和奇偶性改一下，写完跑了几个case就过了

data商业化第二轮：
几乎没怎么问常规八股文，先自我介绍
问怎么自己实现一个哈希表
答：数组 + 一个映射函数，如果冲突可以顺序往后再散列，但查找效率会降低， 追问怎么优化：用链表优化，如果链表很长，改用红黑树。问红黑树的优点：主要是跟链表比较查找深度变小了

问go里面的哈希表是不是线程安全的

答：线程不安全

追问线程不安全具体会出现什么样的问题，我本来说不知道，面试官说让我自己想下场景，然后就答了可能会覆盖数据丢失数据之类的，自己举例分析了一下，其实我现在都不知道对不对，改天一定去找博客看看……

问怎么实现一个队列 答：用stl的queue，或者用两个stack模拟，追问go语言怎么实现：定义一个结构体，用一个数组和两个指针表示队列头和队列尾，数组尾部和头部看成是连在一起的一个环形数组的形式。
问百度实习项目： 问项目中的CRON表达式的定时任务如果自己去模拟实现，要怎么做？ 答：用消息队列 + 一个表示时间的字段 如果不用消息队列，怎么做？
答：用一个双向链表，每个结点有一个下一次执行的时间字段，执行完成后更新时间，插入到双向链表中，维持链表结点下一次执行时间是递增的，链表不能随机访问，所以每次插入需要O(N)的时间复杂度， 
面试官没理解我的意思追问了几遍 问时间复杂度能不能优化？ 我一开始没理解这个提问，回答可以用协程 + WaitGroup实现， 
后来明白了意思，答：用小根堆，每次取堆顶的任务执行，执行完增加一个单位时间间隔再放回堆中 ，这样时间复杂度是O(logN) 
算法题： 122. 买卖股票的最佳时机 II https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
123. 买卖股票的最佳时机 III https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/ 两道买卖股票的题目，前面一个很快写出来了
124. ，后面一个是hard讲了个错误的贪心思路，自己推出来不对，然后开始想动态规划怎么做，大致写了一下，
125. 但是还没写对时间就到了，面试结束 二面基本上全程在问算法设计，好在答的还不错，实习项目里面的一个很小的点被拿出来深入提问设计方面的问题是我比较意外的，算法的hard题没见过有点难想，但还是给我过了

data商业化第三轮：
看出来了是主管级别的面试官，迟到了10分钟才来，我都准备给HR打电话了
面试开始后他说要去回消息，于是直接给了一道算法题我先写：给一个非负整数，找比这个数字大的最小的回文数字
564. 寻找最近的回文数 https://leetcode-cn.com/problems/find-the-closest-palindrome/是这个题的简化版本，原题更难，思路是：分数字位数奇偶讨论，比如说偶数位数的数字，1234，把左边一半和右边一半提取出来，12和34，把左边的翻转，12翻转成21，如果翻转后的数字比右边一半大，返回1221，否则返回1331，详细描述很麻烦，意会一下
     小于10的数要单独判断，然后奇数位数的数字需要对中间的那一位单独处理。如果越界还有大数的问题，好在给的case比较小没有这种问题，一开始有边界问题，提示之后，case都过了
     然后就是聊人生环节，比如说北京的学生怎么来上海实习？前一段实习的收获是什么？没什么参考性就不细说了

最后的HR面：
确认了一下入职时间，沟通了一下实习的各种信息，然后就发offer了

2. 字节跳动飞书后端一面 已凉凉

全程暴力拷问数据库长达45+min，很变态


2. 
3. 一面（1h30min）
   一面上来就是两道算法题，第一道是给两颗二叉树，判断B是不是A的子树。
   第二道是合并三个有序数组。 写完之后开始问问题。
   计网
   内网和外网的区别？
   讲一下NAT。
   思考这样一个场景，宿舍有一个路由器，寝室有你的电脑和你舍友的电脑，当你往你舍友电脑发包和往百度服务器发包底层的协议过程有什么不同。
   操作系统
   我们知道操作系统定义了进程和线程，那么区别出进程和线程的目的是什么？
   讲一下epoll,select,poll三者的区别和适用的场景。
   数据库
   联合索引(a,b)和(b,a)有什么区别
   一条sql语句慢怎么排查？
   场景题
   充值卡原先使用卡号和卡密来充值。现在要升级系统，去除掉卡号，需要怎么升级才能保证安全性？
   银行卡原先的验证身份方式是磁条，现在发现磁条可以伪造，要将磁条验证升级为IC卡验证，只考虑ATM机器和银行卡，给出一套不影响用户使用的升级方式（即不能强制用户换卡，升级要考虑到ATM机和银行卡）。其实后来本质上就是一个接口升级的问题。
   二面（45min）
   自我介绍
   从项目开始问（主要是websever和CS144的lab）
   目前你的服务器的连接数是1w，你觉得瓶颈在哪里？你有什么优化的方法？
   你在简历当中提到了事件处理模式是reactor模式，那么你觉得怎么样才能利用多线程提高服务器的处理效率呢？
   可以讲一下你项目中是怎么样实现超时重传的吗？
   TCP协议中超时重传能保证数据的可靠传输，但是丢包之后一定会有延迟，有没有什么办法来降低这个延迟？
   讲一下Linux的文件系统
   讲一下Mysql的索引是什么？索引怎么让加快查询的？
   索引可以加快查询，那么使用索引有什么缺点吗？
   算法
   找出数组的第K大元素。

三面（45min）
自我介绍。


算法
非递归前序遍历二叉树。

四面（45min）
自我介绍。
结合实习在的组问了两个场景。游戏里面像集市或者公共区域的时候会无法避免的有很多玩家，服务器这个时候是怎么处理玩家的视野可见问题的？要是把所有可见玩家的信息都下发会不会太大？如果只选择一部分的话又是哪些可见哪些不可见？

我看你在实习的时候主要是做了技能相关的模块，大概讲一下技能在服务器这边的执行逻辑大概是些啥？玩家释放一个技能之后要是网络卡顿了3s后包才传到服务器你们是怎么处理这种情况的？会不会出现服务器和客户端状态不一致的情况？

问项目的实现细节，然后问了下压测的原理和改进的地方（从二面开始就在问这个东西了。。）。

问了下项目流量控制的实现。

我们调试程序的时候会打断点，可以讲一下断点在底层是怎么实现的吗？
我们在控制台按下ctrl+c的时候发生了什么？在一个进程收到信号退出的时候我们可能希望做一些数据写回保存等操作，怎么实现？

我们在下载东西的时候会发现刚开始网速很慢，然后逐渐变快，可以讲一下TCP连接底层对应的变化吗？

讲一下HTTP报文的组成？

我们用HTTP协议下载一个很大的东西的时候下到一半暂停了，第二天重新下载的时候会接着从当前进度下载，HTTP是怎么实现这样的功能的？

访问中国银行网站的时候，我们怎么确保当前的这个网站是正规的而不是不法分子伪造的服务器呢？

C++的虚函数的多态是编译时还是运行时？怎么实现运行时多态的？

这段程序执行会有错吗？
char* fun(){
char *p="123";
return p;
}
int main() {
cout<<fun();
}
算法
39. 组合总和

字节一面（9.23 40min）
字节上周末投的，有点晚了，原本投的部门挂了，现在是被其他部门捞起来的
实习印象深刻的项目(针对其中一个详细问了下)
Linux命令
接口和抽象类
浅拷贝深拷贝
redis项目中用来做什么
缓存雪崩击穿穿透以及区别
垃圾回收算法以及区别
inode是什么(元信息)，有几种(这个没答出来)
select poll epoll(这个地方介绍有点卡壳)
项目中认证是如何做的
(我学过安全)sql注入，crsf攻击
算法：跳楼梯(简单题)
题目也很基础，算法题也简单，却心里觉得虚虚的

字节二面（9.28 1小时20min）
交叉面，面试官还在日本出差，面试官人很nice，体验不错
（问题回忆版）
论文内容介绍
实习内容介绍
自定义延迟队列如何实现，是否可以使用redis解决等
linux内核有什么功能
coding：(1) SQL题 (2) 旋转有序数组求target logn复杂度 【lc 33】
有几天了部分内容忘记了，抱歉。

字节三面（9.29 1小时左右）
接口和抽象类
多态的底层实现
线程池的状态有哪些
多人协同开发冲突
实习学习到了什么
分布式消息队列的消费数据如何保证幂等性
未来的职业规划
算法题：实现限流算法

字节四面（10.8 ）
自我介绍（没有偏技术）
实习内容介绍（有点卡顿，面试官说没有突出亮点，介绍的也不全面）
微服务构建的流程
容器相关知识和常用命令
垃圾回收的过程
引用计数和GC Roots
Redis用途，持久化（RDB和AOF），启动数据加载流程（回答反了）
Mysql InnoDB和myISAM区别，事务隔离级别，幻读本质
职业规划
选择是在一个领域专精，还是涉猎广泛
没想到还是技术面，看牛客有人说可能是前面面评差异较大加面，但自己感觉上面中规中矩，也就个别问题没有答好，算法也全部手撕了。
一直以为是HR面，没有准备技术相关，直接定在今天面试，许多内容回答的不太好，感觉凉的可能性有点大


redis的zset是怎么实现的？（哈希表＋跳表），跳表的节点有什么内容？跳表的查询过程是什么样的？复杂度是多少？redis的跳表是双向的，这样设计是为什么？

redis怎么设置过期的？（答给每个数据添加一个属性，过期时间，到了过期时间就删除，猜的）。怎么检查？（周期检查，惰性检查）。

redis是单线程的，为什么这么设计呢？（基于内存，瓶颈不在cpu， 加锁反而会带来性能损失）。 单线程一定比多线程好吗？为什么新版本的redis还要变成多线程的？（答 读多写少的时候，加共享锁多线程性能更好）， 那不考虑这种场景，读写差不多的情况下呢？

锁在内核中是怎么实现的呢？（瞎说了个锁总线）

多线程竞争一把锁，会不会出现一个线程永远抢不到锁的情况？这种问题该怎么解决？（答的是 等待久的优先级提升）

讲一下什么是非阻塞socket

阻塞，非阻塞，同步和异步之间是什么关系？（答了一大堆）

讲一下epoll，它在内核中是怎么实现的？（红黑树）

为什么是红黑树呢？（查询效率吧）

我们知道红黑树是一个有序的，那epoll树是依靠什么排序的呢？（不知道）

客户端多个线程发送请求，在读取响应结果时，怎么和每一个请求线程对应呢？（瞎说了个消息和tid绑定）

tcp和ip层的关系？（ip层只负责主机与主机之间的通信，tcp需要绑定端口实现进程间的通信。tcp是可靠传输的，ip只能尽力交付）

那就仅考虑主机与主机之间的通信？没有可靠保证，是不是就会有大量丢包呢？整个网络的可靠性全部由传输层来保证吗？（答，可靠这个概念不仅仅是包是都按序全部到达，每一层都有自己的差错控制机制）

怎么理解你说的差错控制这个概念呢？（主要是校验，保证接受到的包和发送的包的数据是一致的）

（1）给你一堆坐标，求这一堆数据中两两之间的曼哈顿距离之和，曼哈顿距离定义为 |x_i - x_j| + |y_i - y_j|， 要求时间复杂度小于n^2 (写出来了)
(2) leecode 863 （没写出来）分布式系统的性质，及其实现原理。
我从CAP入手，讲了一下在CA之间的平衡策略。
分布式系统的几种一致性（强一致性、最终一致性、弱一致性）。
Java相关
ThreadLocal的原理？应用场景？
sleep()和wait()方法的区别是什么？如何唤醒？
线程的生命周期
synchronized和lock的区别？发生异常时 synchronized和lock锁的占用情况？synchronized升级过程？
线程池了解多少？
乐观锁和悲观锁，CAS带来的问题
==和equals的区别，Stringbuilder和StringBuffer的区别
垃圾回收算法？CMS回收器的过程？
Java的内存模型，可见性是什么？
Java线程不安全的问题，还有如何实现线程安全
volatile关键字的作用是什么
强引用 弱引用 虚引用 软引用
HashMap的不安全原因？
AQS的原理
数据库
MySQL慢查询如何优化？
数据库的索引结构是什么？
为什么使用B+树？对比B树，哈希。
聚簇索引和非聚簇索引的区别。
数据库的三大范式
事务的隔离级别
事务的ACID分别是什么？怎么保证的？
为什么B+树高度就小，是因为什么，B树为什么就高一些？千万行的数据这个B+树索引大概多高？
数据库什么时候需要建立索引？什么时候索引会失效
联合索引（a,b,c） where 条件之后分别走c,b,a 用and连接会走索引吗
索引为什么能加速查询？B+树作索引的优势。
什么是回表
binlog，redolog，undolog三者的区别了解吗？
MVCC
中间件
Redis是否了解过底层？
zset的跳表如何实现的？
Redis如何实现分布式锁
Redis怎么实现限制用户请求的？怎么计数+1的？如果多条线程过来怎么保证线程安全？
AOF和RDB有啥优缺点？AOF重写了解过吗？
缓存穿透，缓存击穿，缓存雪崩，什么概念和解决方案
Redis如何淘汰过期数据？
Kafka使用场景？为什么用？为什么吞吐量高？
MQ如何保证消息不丢失
计算机基础
计算机网络
HTTP session和cookie的区别？
TCP 三次握手/四次挥手，流量控制，拥塞控制？
TCP和UDP的区别？
ARP协议工作原理？ARP攻击？如何解决？
DNS的解析过程
HTTPS ,客户端如何验证证书，HTTPS不能防止什么攻击
网络分层结构
浏览器输入网址，返回error：服务不存在，如何排查？
一次HTTPS的请求过程
介绍HTTP各个版本(1.0、1.1、1.x、2.0、3.0)的区别
HTTP中的长链接如何实现的
Time wait和Close wait的区别
HTTP的状态码有哪些？http请求头有哪些？
Dos和XSS攻击是什么？如何防止？
中间人攻击知道吗？怎么做https的抓包？https怎么篡改？
输入一个URL都发生了什么？
操作系统
虚拟地址和内存地址
进程和线程的区别？通信方式？线程间切换怎么做
了解IO模型吗？介绍select/poll/epoll的区别
僵尸进程和孤儿进程
进程调度算法，哪些是抢占式，哪些是非抢占式？
死锁产生的条件，如何避免？
fork一个子进程发生了什么？
水平触发和边沿触发
用户态与内核态的区别
项目相关
项目中遇到的难点
有没有用过授权登录，第三方登录，了解过OAuth2.0吗？
牛客论坛项目如何识别热点数据？如何计算？如何更新热度？
JWT说说？
找个印象最深的项目说说？(简历中不止一个项目)
你项目中遇到的最大的问题是什么？你是怎么解决的？
你项目中用到的技术栈是如何学习的？
为什么做这个项目，技术选型为什么是这样的？
登录怎么做的？单点登录说说你的理解？
项目遇到的最大挑战是什么？(类似问题2)
说说项目中的闪光点和亮点？
项目怎么没有尝试部署上线呢？
介绍项目具体做了什么？(项目背景)
如果让你对这个项目优化，你会从哪几个点来优化呢？



分布式协议中paxos存在的问题
项目中的难点
根据难点进行深挖
3.IO多路复用
4.零拷贝
5.虚拟内存缺页异常
6.页面置换算法
7.算法：二叉树锯齿形遍历，只需要讲思路


拥塞控制
服务器挂掉了，客户端会怎么做
tcp三次握手和accept函数
数据库隔离级别，脏读和幻读的区别
虚拟内存、请求调页的具体过程
select语句的存储引擎执行过程
算法：给定m个不重复字符。求一个字符串中刚好由这m个字符组成的连续子串的起始位置

1.网络分层的结构
2.常见的协议有哪些？
3.pop3属于哪个层的协议（上一个问题答了pop3协议）
4.http和https的区别？
5.https如何实现数据加密传输的？
6.403是什么含义？具体的
7.502具体的错误指什么？
8.一个url地址键入后整个的过程，越详细越好
9.8的基础上，服务器处理请求说的详细一点，怎么接收请求的，系统内部如何处理，cpu是怎么工作的？(任何系统处理请求都有工作单元，工作单元叫什么名字)
10.进程，线程和协程
11.线程之间如何实现通信，有没有用到过？
12.mysql一个select语句的执行过程
13.mysql存储引擎
14.InnoDB和myISARM的区别
15.聚簇索引和非聚簇索引的区别
16.MySQL事务的特性
17.有没有做过SQL优化吗？
18.水平切分和垂直切分，分别在什么场景下用？
19.Redis的优点，Redis在数据持久化的时候用的是哪个代码实现的？
20.windows系统如何实现内存分配？CPU切换和分配的原理？
21.查看系统里CPU和内存使用情况，用哪些命令执行？
22.如果想统计一个服务的请求文件，统计每个接口的QPS的话，用什么命令能实现？

----------------------------------------------------------
算法题：带有括号的逆波兰表达式(结果输出的不是最后值，是等式)
一、指针和引用的区别

本质：指针是一个实体，需要分配内存空间，引用只是变量的别名，不需要分配内存空间
内存分配：指针与引用都需要分配内存区域，引用在定义的时候必须初始化，一旦引用与某个变量绑定后就不再改变
级数：有多级指针，没有多级引用
自增含义：指针自增代表指向下一个空间，引用自增代表引用的变量值加1
sizeof 大小：sizeof引用得到的是指向变量的大小，sizeof 指针得到的是指针本身的大小
访问方式：引用访问一个变量是直接访问，指针访问一个变量是间接访问
安全检查：使用指针前最好做类型检查，防止野指针的出现，引用可以防止野指针的出现
引用底层是通过指针实现的
作为参数时的不同：传指针的实质是传值，传递的值是指针的地址，传引用的实质是传地址，传递的是变量的地址
二、static 关键字的用法和作用

告知编译器讲变量存放在程序的静态存储区而非 栈上/堆上 空间（编译时初始化）
同时编译多个文件时，所有未加static前缀的全局变量都有全局可见性，即a.cpp可以使用extern 调用b.cpp里面的全局变量；若加了static 修饰，则该全局变量只对该文件有效，可以解决命名冲突的问题
优势：可以节省内存，因为它是所有对象所公有的
注意：
函数体内的static 变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次
模块内的static 变量可以被模块内的所有函数访问，但不能被其他模块使用
static 类成员函数不能访问非 static 成员变量 ---> static 函数内没有this 指针，无法访问私有变量
三、const 关键字

阻止一个变量被修改

函数声明内可以使用const 修饰形参，表明其是一个输入参数，在函数内部不可以改变其值

const 的几种用法：

const int *p ---- 常量指针，不可以通过这个指针改变其所指向的变量的值
int * const p ---- 指针常量，p的值不可变
const int* const p ---- 指向常量的常指针
四、虚函数、内联函数

虚函数用于实现运行时的多态，实现方式：C++ 内存模型规定最开始的四个字节（32位机器）为指向虚函数表的指针(vptr), 当把子类的实例赋值给基类指针，基类的vptr就会指向子类的虚函数表

内联函数在编译时将所有运用内联函数的地方替换为代码块

五、构造函数不可以为虚函数，析构函数需要为虚函数

虚函数表是在构造函数内初始化的，构造函数设置为虚函数，会导致对应类无法初始化一个对象
析构函数如果不设置为虚函数，则在多态情况下，析构基类的同时，无法析构基类指向的子类
六、容器内部元素的删除

顺序容器
erase 迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效，不可以使用erase(it++) 的方式，但是 erase(it)的返回值是下一个迭代器，it=erase(it)
关联容器
erase 迭代器只是使得被删除元素的迭代器失效，返回值为void, 采用 erase(it++)的形式删除迭代器
七、c++ 对struct进行了进一步的扩展，使struct在c++中可以和class一样当作类使用，唯一与class不同的地方在于struct 的成员默认访问权限是public， class 是private

八、c/c++ 内存分配

栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值，其操作方式类似于数据结构中的栈
堆区：由程序员分配释放，若程序员不释放，程序结束时由os回收（比较危险，程序员自己不回收容易引起内存泄漏）
全局区(静态区)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量，在相邻的另一块区域
文字常量区：常量字符串就是放置在这里的，程序结束后由系统释放
程序代码区：存放程序的二进制代码
九、野指针和内存泄漏

野指针：指向被释放的内存或者没有访问权限的内存
内存泄漏：由于程序员的疏忽或错误导致程序未能释放掉不再使用的内存的情况，解决办法：智能指针
十、new 和 malloc 区别

new 运算符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，malloc 需要显示给出所需内存的大小
new 操作符分配成功时，返回对象类型的指针，malloc内存分配成功，则返回void *,必须要通过强转变成所需要的类型
十一、空类的大小

空类的大小是1，c++ 要求对于每个类的实例都要有独一无二的地址，编译器会自动为空类分配一个字节大小，这样子保证了每个实例均有独一无二的地址
带虚函数的c++ 空类大小不为1，因为有vptr的存在
十二、虚函数的代价

带有虚函数的类，每一个虚函数类会产生一个虚函数表，用来存放指向虚成员函数的指针，从而增加类的大小
带有虚函数的类的每一个对象，都会有一个指向虚表的指针，会增加对象的占用空间大小
虚函数不可以作为内联函数
十三、c++ 类型转换

static_cast ----- 一般的转换
dynamic_cast ----- 通常用于基类派生类之间的转换
const_cast ----- 主要用于针对const的转换
reinterpret_cast ----- 用于没有任何关联的转换，比如一个字符指针转换为一个整数
十四、空类有哪些默认的函数

缺省构造函数
拷贝构造函数
析构函数
operator= 赋值运算符重载函数
取地址运算符重载函数
十五、代码段从0地址开始的吗
否，0地址开始处的空间是不被使用的（逻辑地址）

十六、c++11 新特性

右值引用
初始化列表
类型推导
基于范围的for循环
lamda 表达式
空指针 nullptr
智能指针
正则表达式
十七、迭代器失效的几种情况

对于序列式容器，删除当前的iterator，会使得后面所有元素的迭代器失效
使用pushback后，导致vector扩容，进而导致迭代器失效
list中，元素的删除操作会导致指向该元素的迭代器失效
十八、模板函数不可以是虚函数
模板函数需要根据调用情况生成不同的实例，虚函数表的大小却需要在编译时确定

十九、虚函数可以定义为static吗？
不可以，虚函数是通过this指针调用的，而static函数内部没有this指针

二十、静态库与动态库区别
静态库在编译时就被载入可执行程序，体积较大，动态库在编译时加入标记，在运行时才加载动态库，体积较小，而且可以提高代码的可复用度

二十一、一个进程可以创建多少线程，和什么有关
一个进程可以创建的线程数由可用虚拟空间和线程的栈大小共同决定
只要虚拟空间足够，那么新线程的创建就会成功

二十二、线程间什么是共享的，什么是不共享的
堆，全局变量，静态变量是共享的
栈与寄存器不是共享的

二十三、线程间通信机制

锁机制
信号量机制
信号机制
volatile 全局变量
二十四、实例化一个对象要经过哪几个阶段

分配空间：对于全局对象，静态对象，以及分配在栈区域的对象，他们的内存分配在编译时已经确定了，堆上的对象，它们的内存分配是在运行时动态进行的
初始化虚函数表，虚函数指针
赋值，执行构造函数体
二十五、const和宏定义的区别

类型与安全检查不同，宏定义是字符串替换，const是常量的声明，需要在编译时进行类型检查
存储方式不同：宏定义是直接替换，不分配内存，存储在程序的代码段内；const常量需要进行内存分配，存储在数据段
定义域不同，宏定义不受定义域限制，const定义域为该函数体
define 定义后可以通过 undef 取消，const常量定义后在定义域内永远有效
二十六、std::move
将左值转化为右值，右值仍为右值,常配合 std::forward使用实现完美转发
实现：

template <class T>
typename tinySTL::remove_reference<T>::type&& move(T&& t) noexcept {
using return_type = typename tinySTL::remove_reference<T>::type&&;
return static_cast<return_type>(t);
}
如果一个函数模板参数类型为T&&，其中T是需要推到的类型，那么T&&表示万能引用。
万能引用实际用到的技术是引用折叠。
引用折叠的规则可以概括为：
X& &、X& && 和 X&& & 折叠成 X&；
X&& && 折叠成 X&&。
如果T = X&是左值引用，则展开后得到了X& &&，根据上面的规则，最终得到X&。
如果T = X&&是右值引用，则展开后得到了X& &&，根据上面的规则，最终得到X&&。
所以，当t为左值或者左值引用时，进过引用折叠，得到的类型是T&。最后就是将左值转换为右值并返回了。
字节抖音电商三面凉经
1. 两个线程交替打印1-100
   多个线程交替打印 1-100  我用的go 飞书不会自动导包 难受，后面用sync.waitGroup 报错undefined
   2.update加锁方式  加在哪儿 会导致全表锁定吗
   3.redis 的set 等集合最多可以存储多少个元素
   4.数据库和redis如何保证一致性 （我回答了双写和binlog日志通过消息队列异步同步，但似乎不满意）
   5.索引失效 你遇到过哪些（最左前缀和group by）这里埋了个坑，group by我自己忘了为啥会失效我还讲出来，不过的确是真的遇到过。
   6.
   7.redis的list set 等集合最多可以存储多少个元素
   8.热key 在数据一致性同步时如何处理，（我回答双写可能导致db被打爆，就说如果不考虑数据实时一致性的话，就用binlog日志去异步同步。）但是好像也不满意
   9.项目里的redis 如何代替raft实现数据一致性
10. innodb加锁方式 对行的锁定如何锁定的


编程：找两个有序数组的第K大，没让写，说了下思路
编程：在排序数组中查找元素的第一个和最后一个位置

编程题：组合总数II
三面
介绍一下科研项目
编程题：快排
Arrays.sort()的原理了解吗？数据量不大的时候，冒泡和快排哪个更快？
编程题：表达式求值（加减乘除，无括号）
表达式求值还有别的解法吗？学过编译原理吗？(类似语法树的解法)


sql：表 人员id 歌id 找到被不同人听了两次以上的歌（每个人可能会听很多次）








go 协程如何实现


sql语句
（1）查询每个班级的平均分
（2）查询班级平均分 排名前三的班。

### 算法题
手撕代码
组合总和III（LeetCode 216）
n个节点的有向无环图，找到所有从0→n-1的路径。
最长的回文子串（LeetCode 5）
根据前中序重构二叉树（LeetCode 剑指offer 07）
螺旋矩阵（LeetCode 54）
手写单例模式
二叉树的最近公共祖先（LeetCode 236）
删除排序链表中的重复元素II（LeetCode 82）
手写LRU
不递归实现树的后序遍历
链表右移k位
二叉树的锯齿形遍历（LeetCode 103）
接雨水 （LeetCode 42）
打开转盘锁（LeetCode 752）
每K个一组反转链表
两个升序数组求交集
TOPK （LeetCode 215）
反转链表
重排链表 （LeetCode 143）
返回链表的环入口
两个字符串找最长公共子串
两个有序数组找中位数
二叉树的最大宽度 （LeetCode 662）
链表内指定区域反转
数组求前K大的数
k个有序链表合并
完全平方和
二叉树的路径和
树的右视图
手写快排
有序链表转平衡二叉树
交叉链表求第一个公共点
硬币兑换
课程表（LeetCode 207）
给一个升序数组，部分掉换，例：[4, 5, 6, 7, 0, 1, 2]，给一个target：0，找到位置
最长递增子序列（LeetCode 300）
前序遍历+中序遍历构建树，在返回树的右视图
树的z字型遍历
给定一个字符数组，和一个字符串，在字符串里找到任意一个完全由字符数组组成的子串，字符顺序无所谓
给一个数组，建一颗最小高度的二叉树（递归和非递归）
反转链表II（LeetCode 92）
求从一个树的左边的叶子节点到一个树右边的叶子节点的最短路径
分割数组的最大值（LeetCode 410）
复原IP地址（LeetCode 93）
判断无向图是否存在环路
* 算法：一个有序重复数组，一个target；数组中两两一组，合为target的个数
  手撕题目 a是否是b的子树

算法：奇正序偶倒序链表重排
算法题是：leetcode 22题 https://leetcode-cn.com/problems/generate-parentheses/
算法题：实现限流算法
算法：跳楼梯(简单题)
题目也很基础，算法题也简单，却心里觉得虚虚的
一道算法题：最长递增子序列，没做出来，执着于在O(n)内解决了，其实不难，后面看了一下力扣原题复杂度需要O(n^2)，归根到底还是自己最近没怎么刷题，确实有些忘了。
算法题
环链
算法题：给定一个二叉树和target，输出所有和为target的路径(不一定从根节点出发)
算法题：1~26映射为A~Z，给定一串数字，输出所有可能的字母组合
五、算法题（48min看了一下时间，这么快）
全排列（LC46）
算法题：滑动窗口最大值
15. 排序算法你有了解吗？讲一下快速排序的思想，分析下时间复杂度？
16. 三个线程依次轮流打印ABC，打印100次，说实话一直忙着刷高频题和记八股，这钟基础题写了半天没AC。 换道新题，将数组拆分成斐波那契数列，基本思想是回溯，但没AC。
    做题：二叉树中序遍历 （我写了递归和非递归）
3. 做题 最小覆盖子串但是不太一样思路差不多
4. 做题：四个无序数组排成一个有序数组（我用的快排+归并）
   岛屿数量
   最长升序子序列
17. 做题
- 如何判断一个链表是否有环（构建有环的链表出了点问题，双指针，hashset两种解法）
- 爬楼梯（动态规划）
17. 做题
- 如何判断一个链表是否有环（构建有环的链表出了点问题，双指针，hashset两种解法）
- 爬楼梯（动态规划）
  算法题
  二叉树层序遍历

基于上面的代码如何实现左视图和右视图，如何垂直输出？
* 拉链法实现个 map
之后问给实现的 map 加上 lru 怎么加，随便答了答
下来之后自己好好写了个，看这里：https://codetop.cc/discuss/232
* 递归和非递归前序遍历二叉树
* 二叉树的最大直径
* 手撕：反转链表
* 剑指 Offer 42. 连续子数组的最大和
* 124. 二叉树中的最大路径和
* 64. 最小路径和
* 剑指 Offer 28. 对称的二叉树
  分析复杂度
* 3. 无重复字符的最长子串
  分析复杂度及优化
* 手撕：给一个等差数列，其中有一项缺失，找出这一项
* 了解哪些排序算法，其中哪些是稳定的
* 排序的时间复杂度
* 什么排序的时间复杂度下限可以突破O(nlogn)
* 基数排序的场景
* 剑指 Offer II 074. 合并区间
* 找到二叉树路径和为target的所有路径并打印出来（不一定是从根节点出发）。
* 最长回文串；全排列。
* 实现多种方式三个线程依次轮流打印ABC，打印100次；leetcode842，将数组拆分成斐波那契数列。
* 最长回文串；
* 全排列
* 不重复的全排列
* 全排列 2、岛屿数量，leetcode原题
* 给一个排序数组，找众数的下标（出现次数大于等于数组长度的一半），要求O(logN)。
* LeetCode 102. 二叉树的层序遍历，需要自己建树验证。
* 会议室II，leetcode原题
* 二叉树最大宽度 leetcode原题
* 二叉树Z形遍历

* 判断是否是二叉搜索树
* k值的最小字典序列
* 股票问题 一次买卖？多次买卖？
* 字典树  
* leetcode3  middle 无重复字符的最长子串
* 寻找无序数组的中位数
* 逆转链表
* 输出一个有序数组中一个数字的第一次出现的位置或者返回-1
* 一个序列，先增后减，例如 1，4，6，9，13，10，6，2 找某一个数是否在其中。[二分查找]
* 二叉树的镜像。
* 给两个数 求他们的平均数 只能用int
* 两数之和
* N个长度为K的有序链表合并，时间复杂度，空间复杂度
* 找出一个字符串最长不包含重复字符的字串的长度。
* 股票买卖一次最大利润、买卖多次最大利润

* 二叉树层次遍历
* 一个二维数组，左到右、上到下递增，找到目标值的位置。
* （只说思路）：
一维数组里是正整数，会重复，求其中连续增长的最长子串的长度？如果不是连续子串呢？
41个正整数，找出其中出现次数最多的数
* 找到二叉树的路径和为target的所有路径并打印出来。（注意，不一定是从根节点出发）， AC。
* 给一个排序数组，找众数的下标（出现次数大于等于数组长度的一半），要求O(logN)。
* 143. 重排链表
反问：具体做些啥
熟悉什么语言？使用中遇到的问题
golang map【循环】两次打印 结果一样吗？map使用注意事项？不一样。多线程访问。不安全。



文件里面 两亿个数，找到最大100个的
系统的文件日志，几千万条，怎么找出出现最多的ip地址。



设计一个栈 ，pop push getMax 时间复杂度o
一个数组，除了一个数出现一次，其他都是两次，求该数？如果有两个数呢 ？[异或位运算]
开始-结束时间，好多组，问给定一段时间，能最大干完多少个任务。说思路


const和define的区别，有什么优势？
  --编译阶段
  define是在编译的预处理阶段起作用，属于文本插入替换，而const是在编译、运行的时候起作用
  --安全性
  define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
  const常量有数据类型，编译器可以对其进行类型安全检查
  --内存占用
* define只是将宏名称进行替换，在内存中会产生多分相同的备份。
* const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
* 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间
指针和引用的区别

数组和链表的区别 

继承与多态

vector的实现
**static关键字的作用**

**explicit关键字的作用**
防止类构造函数的隐式转换


hashmap的实现，冲突时除了链表还有什么方法，读的时间复杂度
所读过的开源框架及其原理

overflow和out of memory的区别

智力题:64匹马，8个赛道，最少多次求出TOP5
智力题，A和B都可能在3h内任意时刻到达，求两人到达时刻间隔小于1h的概率
智力题 两个人轮流投硬币，正为赢，求先投的人的胜率
智力题：A、B两人轮流扔一个硬币，先扔到正面的为赢，A先扔，问A赢得概率为多少？
智力题，问公交车15分钟来一趟，请问等5分钟等到公交车等概率是多少？我答的是使用指数分布去计算，面试官觉得还行。
智力题，一个卡车可以装多少个乒乓球，给个数量级。



项目的权限管理如何实现

为什么要MD5要加盐

接口和抽象类的区别

finally不执行的情况

ThreadLocal



LRU、LFU原理




套接字

场景题：一个类有三个方法，三个线程分别访问该类的对象的三个方法中各一个，如何按顺序执行？只对类进行操作，不对线程进行操作。（方法之间设置标志位，first执行完之后再改变标志位，让second跳出循环执行）
```c++
class Foo{

boolean flag = flase;

public void first(){

sout(xxx);

flag = true;

}

public void secnod(){

while(flag == flase){

}

sout(xxx);

}

}
```




返回res{

state，//返回数据的类型

content //返回数据的具体内容

}






自我介绍

项目都是自己做的吗？

介绍一下你最擅长的项目？-分布式对象存储

数据存放在哪里？ES用在哪？

直接问数据的一致性？

怎么保证数据的一致性？

恢复的时候怎么知道谁的数据是正确的？

如果最后是3对3，怎么少数服从多数？

如果多个节点垮掉了怎么办？

怎么进行数据恢复？

Linux用过吗？说一下哪些指令？

HTTP状态码？502和504什么意思？

go语言的slice和数组有什么区别？slice是有序的吗？

协程用到异常panic怎么办？怎么捕获，具体的语句怎么写？

怎么查询go语言的性能？

两个比较大的数相加怎么做？写代码？


删除链表第 k 个节点，后改为删除链表的倒数第 k 个节点

TCP 三次握手

反问




项目中 JWT 存什么？

日志 AOP 怎么实现的？具体代码说一说

日志如果太大太长怎么办？

序列化手段有什么？（上个问题回答了序列化）

怎么避免重复点击导致数据库中出现重复数据？

Nacos 有什么功能？

注册中心的流程？

配置中心有什么用？

注册中心有什么用？



Redis 的分布式锁
深拷贝、浅拷贝
单例的缺点
堆和栈、栈内存如何管理

* weakptr是怎么实现监控的？
weak_ptr 弱智能指针
Effecvive Modern C++
使用std::weak_ptr 来代替可能空悬的 std:: shared_ptr 。
std::weak_ptr 可能的用武之地包括缓存，观察者列表，以及避免 std::shared_ptr 指针环路 。

weak_ptr 弱智能指针
weak_ptr 观察者 —— 基本功能
weak_ptr解决循环引用问题 —— 引用对象，用weak_ptr
线程安全的对象回调与析构 —— 弱回调
替代方案
std: :weak_ptr 一般者是通过 std: : shared _ptr 来创建的。
当使用 std: :shared_ptr 完成初始化 std::weak_ptr 的时刻，两者就指涉到了相同位置

弱智能指针weak_ptr区别于shared_ptr之处在于：

weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在
weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数
weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源
weak_ptr 观察者 —— 基本功能
weak_ptr内几个重要成员函数：

成员函数use_count() 观测资源引用计数

成员函数expired() 功能相当于 use_count()==0 表示被观测的资源(也就是shared_ptr的管理的资源)是否被销毁

成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 进而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr
```
class CTxxx {
public:    
CTxxx() {printf( "CTxxx cst\n" );}
~CTxxx() {printf( "CTxxx dst\n" );    
};

int main() {
std::shared_ptr<CTxxx> sp_ct(new CTxxx);
std::weak_ptr<CTxxx> wk_ct = sp_ct;
std::weak_ptr<CTxxx> wka1;
{
std::cout << "wk_ct.expired()=" << wk_ct.expired() << std::endl;
std::shared_ptr<CTxxx> tmpP = wk_ct.lock();
if (tmpP) {
std::cout << "tmpP usecount=" << tmpP.use_count() << std::endl;
} else {
std::cout << "tmpP invalid" << std::endl;
}
std::shared_ptr<CTxxx> a1(new CTxxx);
wka1 = (a1);
}
std::cout << "wka1.expired()=" << wka1.expired() << std::endl;
std::cout << "wka1.lock()=" << wka1.lock() << std::endl;

    std::shared_ptr<CTxxx> cpySp = wka1.lock();
    if (cpySp) std::cout << "cpySp is ok" << std::endl;
    else std::cout << "cpySp is destroyed" << std::endl;
    return 1;
}
```
weak_ptr解决循环引用问题 —— 引用对象，用weak_ptr
请注意强弱智能指针的一个重要应用规则：定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。
```
class B; // 前置声明类B
class A
{
public:
A() { cout << "A()" << endl; }
~A() { cout << "~A()" << endl; }
weak_ptr<B> _ptrb; // 指向B对象的弱智能指针。引用对象时，用弱智能指针
};
class B
{
public:
B() { cout << "B()" << endl; }
~B() { cout << "~B()" << endl; }
weak_ptr<A> _ptra; // 指向A对象的弱智能指针。引用对象时，用弱智能指针
};
int main()
{
// 定义对象时，用强智能指针
shared_ptr<A> ptra(new A());// ptra指向A对象，A的引用计数为1
shared_ptr<B> ptrb(new B());// ptrb指向B对象，B的引用计数为1

    // A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变
	ptra->_ptrb = ptrb;
	// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变
	ptrb->_ptra = ptra;

	cout << ptra.use_count() << endl; // 打印结果:1
	cout << ptrb.use_count() << endl; // 打印结果:1

	/*
	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和
	B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象
	被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”
	*/
	return 0;
}
```
线程安全的对象回调与析构 —— 弱回调
有时候我们需要“如果对象还活着，就调用它的成员函数，否则忽略之”的语意，就像Observable::notifyObservers()那样，我称之为“弱回调”。这也是可以实现的，利用weak_ptr，我们可以把weak_ptr绑到boost::function里，这样对象的生命期就不会被延长。然后在回调的时候先尝试提升为shared_ptr，如果提升成功，说明接受回调的对象还健在，那么就执行回调；如果提升失败，就不必劳神了。

muduo的源代码，该源码中对于智能指针的应用非常优秀，其中借助shared_ptr和weak_ptr解决了这样一个问题，多线程访问共享对象的线程安全问题，解释如下：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。

class Test
{
public:
// 构造Test对象，_ptr指向一块int堆内存，初始值是20
Test() :_ptr(new int(20))
{
cout << "Test()" << endl;
}
// 析构Test对象，释放_ptr指向的堆内存
~Test()
{
delete _ptr;
_ptr = nullptr;
cout << "~Test()" << endl;
}
// 该show会在另外一个线程中被执行
void show()
{
cout << *_ptr << endl;
}
private:
int *volatile _ptr;
};
void threadProc(weak_ptr<Test> pw) // 通过弱智能指针观察强智能指针
{
// 睡眠两秒
std::this_thread::sleep_for(std::chrono::seconds(2));
/*
如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升
为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存
的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象
已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。
```
*/
shared_ptr<Test> ps = pw.lock();
if (ps != nullptr)
{
ps->show();
}
}
int main()
{
// 在堆上定义共享对象
shared_ptr<Test> p(new Test);
// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针
std::thread t1(threadProc, weak_ptr<Test>(p));
// 在main线程中析构Test共享对象
// 等待子线程运行结束
t1.join();
return 0;
}
```
运行上面的代码，show方法可以打印出20，因为main线程调用了t1.join()方法等待子线程结束，此时pw通过lock提升为ps成功，见上面代码示例。

如果设置t1为分离线程，让main主线程结束，p智能指针析构，进而把Test对象析构，此时show方法已经不会被调用，因为在threadProc方法中，pw提升到ps时，lock方法判定Test对象已经析构，提升失败！main函数代码可以如下修改测试：
```
int main()
{
// 在堆上定义共享对象
shared_ptr<Test> p(new Test);
// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针
std::thread t1(threadProc, weak_ptr<Test>(p));
// 在main线程中析构Test共享对象
// 设置子线程分离
t1.detach();
return 0;
}
```
该main函数运行后，最终的threadProc中，show方法不会被执行到。以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用。

替代方案
除了使用shared_ptr/weak_ptr，要想在C++里做到线程安全的对象回调与析构，可能的办法：
用一个全局的façade来代理Foo类型对象访问，所有的Foo对象回调和析构都通过这个façade来做，也就是把指针替换为objId/handle，每次要调用对象的成员函数的时候先check-out，用完之后再check-in16。
这样理论上能避免race condition，但是代价很大。因为要想把这个façade做成线程安全的，那么必然要用互斥锁。这样一来，从两个线程访问两个不同的Foo对象也会用到同一个锁，让本来能够并行执行的函数变成了串行执行，没能发挥多核的优势。当然，可以像Java的ConcurrentHashMap那样用多个buckets，每个bucket分别加锁，以降低contention。

* move了解吗，为什么要有move
左值、左值引用、右值、右值引用
左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。
一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。
引用
引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。
引用可以改变指针的指向，还可以改变指针所指向的值。
引用的基本规则：
声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义；
对引用的一切操作，就相当于对原对象的操作。
左值引用和右值引用
左值引用的基本语法：type &引用名 = 左值表达式；
右值引用的基本语法type &&引用名 = 右值表达式；
右值引用在企业开发人员在代码优化方面会经常用到。
右值引用的“&&”中间不可以有空格。

std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。
从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);
C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 
本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
std::move是为性能而生。
std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。
用法:
原lvalue值被moved from之后值被转移,所以为空字符串.
```c++
#include <iostream>
#include <utility>
#include <vector>
#include <string>
int main()
{
std::string str = "Hello";
std::vector<std::string> v;
//调用常规的拷贝构造函数，新建字符数组，拷贝数据
v.push_back(str);
std::cout << "After copy, str is \"" << str << "\"\n";
//调用移动构造函数，掏空str，掏空后，最好不要使用str
v.push_back(std::move(str));
std::cout << "After move, str is \"" << str << "\"\n";
std::cout << "The contents of the vector are \"" << v[0]
<< "\", \"" << v[1] << "\"\n";
}

After copy, str is "Hello"
After move, str is ""
The contents of the vector are "Hello", "Hello"
```
* 说说宏和内联函数

* 写一个宏函数看看
* 内联函数是干了什么
* c++里的类型转换了解几个 说说

* 指针和引用说说
* 引用占空间吗 为什么

* 堆和栈的区别
* 为什么堆慢
* malloc里面填size 我free的时候是怎么知道释放多少的
我说了下new的、说不太清楚malloc 让我猜猜看 让我设计会怎么设计：
我就说要我设计我就肯定得每malloc就记录在某个表里 free的时候查表就行了
* 说说多态
* 虚函数表是属于谁的
* 对象怎么知道调用了什么函数
* 怎么传的this指针
* 构造函数可以虚函数吗 为什么
* 写了个指向空的类指针 问输出什么
* 说说类的继承权限



#### c++
* define宏定义和const的区别
--编译阶段
define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
--安全性
define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
const常量有数据类型，编译器可以对其进行类型安全检查
--内存占用
define只是将宏名称进行替换，在内存中会产生多分相同的备份。
* const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
宏不检查类型；const会检查数据类型。
宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间

* C++虚函数，纯虚函数，虚析构函数

* C++的vector的底层实现

* C++独有特性，和C的区别，描述面向对象，虚函数怎么实现，为什么需要虚函数，虚基类有接触吗

* 纯虚函数和虚函数区别，有一个大规模项目需要合作，纯虚函数有什么好处

* 函数指针和指向指针的指针是什么，有什么用

* 有哪些设计模式，单例模式是为了解决什么问题，解释一下工厂和抽象工厂

* 学过的数据结构有什么用，堆栈用处大吗，树是干什么用的，为什么要用红黑树不用其他树

* 指针和引用的区别
 

* 介绍虚函数、纯虚函数
* C++的面向对象的特点
* 多态的实现形式
* 讲一讲Python语言和C++语言的区别
* Socket什么时候可读?（没有回答好）
* 构造函数是否能为虚函数，为什么。
* 动态多态。
* 静态多态?（只回答了重载，其实还有函数模板）
* 重载、重写以及隐藏各自是什么。

* 如何避免内存泄漏。
* （其实面试官想问如何定位内存泄漏，我说可以使用工具valgrind，又问如何使用这个工具定位内存泄漏，我也没用过，所以回答不上来，然后就换了一个问题）


* OS，怎么看虚拟内存，我这里也给他答了很深，把八股串起来了，面试官觉得还行。
* 问计算机网络，从浏览器输入一个url到渲染到浏览器这之间经过了哪些缓存。我答了DNS缓存，架构，以及业务代码的缓存。

* C++11新特性
* 智能指针
* 循环引用问题及解决
* 手写shared_ptr，就大概哪些成员变量和成员函数实现
* move有了解过吗
* 给出了智能指针一段代码的用法，找错
* C++内存管理
* STL的一些容器
* 一个程序从预处理到运行经历了那些过程（详细说，编译过程中还包含词法分析、语法分析、语义分析......

然后问 set 怎么实现？答：拉链法


http 500状态码
如何使用 Wireshark 抓自己写的服务的数据包

自我介绍。
你所做的项目中最困难的两件事。
用优先队列实现小根堆。
你所使用Thrift接口又有哪些。
枚举的定义，什么又是枚举类型。

* 说说STL常见的容器，以及各自适用的场景。
* map中的元素为什么是有序的。
* 实现一个类模板。
* 用类模板的方式去实现一个单例模式。
* 一般懒汉式存在什么问题。
* 除了单例模式还知道什么模式，各自的含义又是什么。
* c++11新特性有哪些。
* 线程同步的方式。
* 条件变量的作用，和互斥锁相比又有什么区别。

一堆C/C++的基础（经典的 small ending、big ending、sizeof()、strlen()）
从c语言到c++再到c++11新特性，以及STL

接下来就是给小姐姐讲项目了，问了两个编程项目和自己做的实验室项目~

反问阶段：问了三个问题问问自己面试有啥缺点?知识点上学习有啥不足？再就是实习结果啥时候出来之类的？实习转正之类的问题？

#### 其他

* 你来设计苹果iCloud共享图片是怎么做
* 平时写代码用什么东西管理
* go 垃圾回收过程
* docker 原理
  问了不了解分布式协议，答：不了解
  怎么学习的linux
  是否考虑怎么在KV数据库项目中加入事务
* 什么是回溯
* 有哪些搜索算法
* 什么是剪枝
* 设计模式自己有在项目中用过吗
* 日志系统为什么需要单例模式

加了一个系统设计题 设计一个id生成的中间件，考虑高可用，高并发


* 为什么不直接使用redis，而需要有本项目/RocksDB
* 项目中为什么既有epoll又有select
* 项目跨哪个平台
* 是否了解过IOCP
* IOCP和select，poll，epoll的区别
* 多路复用作用
* 项目中的多线程体现在哪里
* 为什么不把处理读写事件的多路io复用函数分散到线程中

* 项目有没有做过压测


* 排序两个有序链表。

part1，项目。问的很细腻，为啥用到消息队列，如果解决消息重复和消息丢失问题；
自己如何设计一个消息队列保证一个消息不会重复消费。
如何保证你的项目高可用？
项目为什么要使用N-Tree，不用有什么影响吗？
part2，基础。面试官也懂java，问了java相关。HashMap原理，扩容机制以及ConcurrentHashMap对比；HashMap如果存入元素很多会溢出吗怎么解决；volatile关键字作用以及和synchronized区别；线程池七大参数以及工作原理；阻塞队列了解过吗？（这里我答的很深，从ReentryLock到AQS那套全部说了涉及到些源码）。
死锁了解吗？谈谈死锁的必要条件？在项目中解决过死锁的问题吗？
垃圾回收算法了解吗？老年代回收担保机制是什么？
JVM对象什么时候被回收，G1垃圾回收器回收原理；G1用户自己设置停顿时间的参数是什么？
GC Roots有哪些？CMS和G1区别在哪？

part2，

自我介绍。问了项目不敢兴趣，直接做题。

聊天，问最近6年来自己认为最成功的事情是什么？

* 排序两个有序链表， AC。

抖音杭州
一面

* 口述解题思路：判断数组A是否包含于数组B；给定n对括号，返回所有合法排列

* 一个赌博网站，A时刻网站发布一个数，B时刻赌客下注，C时刻开盘。如何让赌客相信该数没有被网站修改过？


reentrantlock、阻塞队列，AQS底层实现

JVM内存模型、GC算法


具体业务场景，都干了啥

微服务、微服务治理

项目的架构、用了哪些中间件（redis、es、mq）、怎么用的，为什么

docker和虚拟机的区别

三面
主要是聊项目，聊了二十多分钟

淘宝杭州
一面
自我介绍

java基础、static之类的

CAP原理

JWT

docker

线程池

其他都是常规八股文，忘了

二面
自我介绍

mysql什么时候用不到索引

hashmap和concurrenthashmap的key和value可以为null吗？为什么

如何维护不同域名的登录态

mybatis中的$和#的区别

分布式锁

reentrantlock和synchronizated的区别

项目中最大的挑战和解决办法，给自己带来什么思考和感悟




项目干了啥，遇到什么困难，怎么解决的


* new和malloc的区别
* mysql索引相关
* mysql事务
* B+树
* 三次握手，四次挥手
* 场景题

* 视频面试这种形式的网络通信，用哪种协议比较好？为什么？
* 登陆网站后，发现网站打不开，这个时候可能会是什么地方出了问题？






*
    704. 二分查找
*
    56. 合并区间
* 剑指 Offer II 051. 节点之和最大的路径

设计题：

有一个图片查看器的app，服务器定时替换图片查看器中的图片，现在有两个要求：
（1）程序启动时查看图片列表。
（2）启动程序后，服务器会定时的去替换客户端的图片列表中的图片，以实现下滑。

如果是你，你会怎么实现?

* 介绍一下c++的多态
* 运行时多态与编译时多态的区别？

* c++的静态多态是怎么做到的？为什么函数名相同却可以调到不同的实现呢？

* C++ 是如何做到函数重载的？
  -C++代码在编译时会根据参数列表对函数进行重命名，例如 void Swap(int a, int b) 会被重命名为 _Swap_int_int ， void Swap(float x, float y) 会被重命名为 _
  Swap_float_float 。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做 重载决议（ Overload Resolution ） 。
  -不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。
  -从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

* 函数返回值类型不同也能实现重载吗？
  和返回值类型无关

* 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

* 类内部的成员变量：
  普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
  static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
* 类内部的成员函数：
  普通函数：不占用内存。
  虚函数：要占用4个字节（32位系统）或8个字节（64位系统），用来指定虚函数的虚拟函数表的入口地址。
  所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。
* C++编译系统中，数据和函数是分开存放的(函数放在代码区；数据主要放在栈区和堆区，静态/全局区以及文字常量区也有)，
  实例化不同对象时，只给数据分配空间，各个对象调用函数时都都跳转到(内联函数例外)找到函数在代码区的入口执行，可以节省拷贝多份代码的空间
  类的静态成员变量编译时被分配到静态/全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间。
  内联函数(声明和定义都要加inline)也是存放在代码区，内联函数在被调用时，编译器会用内联函数的代码替换掉函数，避免了函数跳转和保护现场的开销。不要将成员函数的这种存储方式和inline(内联)
  函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。不论是否用inline声明(或默认为inline)
  ，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在调用该函数时，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。inline与成员函数是否占用对象的存储空间无关

同一个类创建的多个对象，其数据成员是各用各的，互不相通（静态成员变量是共享的）。
成员函数是共享共用的，多个对象共用一份代码，所有类成员函数和非成员函数代码存放在代码区。
不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。

* 两个一模一样的函数，一个使用const修饰，一个不使用const修饰，这两个函数可以进行重载吗？

* const修饰函数起到了什么作用？哪些变量不能修

* const除了修饰函数，还可以修饰什么？

* 顶层const和底层const的区别

* 指针和引用有什么区别？

* 对同一个变量的指针和引用进行sizeof操作，会有什么区别吗？

* 指针为什么会是4个字节，一定是4个字节吗？对指针做sizeof的结果与什么相关？
* 子类的大小是本身成员变量的大小加上父类的大小

* 在32位系统分配指针大小为4字节

* 继续回到动态多态，构造函数可以是virtual吗？为什么不可以是virtual？
  -必要性分析：
  当定义派生类对象时，它会主动依次调用构造函数，顺序为基类的构造函数->一级派生类构造函数->二级派生类构造函数….直到当前派生类的构造函数调用完毕为止，到此派生类对象生成。
  而虚函数存在的意义为动态绑定，从上一段话可知，它会从基类开始依次自动调用相应的构造函数，根本就不存在动态绑定的必要。
  -内存角度分析：
  构造函数的作用是生成相应的类对象。虚函数的动态绑定是依据一张虚函数表来确认的最终绑定到哪一个虚函数版本。
  而调用构造函数之前，我们对类对象所做的操作仅限于分配内存，还没有对内存进行初始化。此时，内存空间上也不存在虚函数表，
  因此，按照这样的执行顺序，虚函数的动态绑定是实现不了的

```c++
#include <iostream>
using namespace std;

class Father
{
  public:
    Father(){
        cout<<"contructor Father!"<<endl;
    }
    ~Father(){
        cout<<"destructor Father!"<<endl;
    }
};

class Son:public Father
{
  public:
    Son(){
        cout<<"contructor Son!"<<endl;
    }
    ~Son(){
        cout<<"destructor Son!"<<endl;
    }
};

int main()
{
    Father *pfather=new Son;
    delete pfather;
    pfather=NULL;
    return 0;
}
/*输出结果为：
contructor Father!
contructor Son!
destructor Father!
*/
```

* 虚表指针是什么时候初始化的？


* 不考虑使用场景，除了构造函数，给所有函数都声明为virtual的，可以这样做吗？或者推荐这么做吗？有什么负面影响吗？

- 虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。
  这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，
  我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。
  这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。
-

* 介绍一下static关键字都有什么作用？都可以修饰什么？分别起到什么作用呢？function实现里面对一个局部变量定义static可以吗？

* c++单例模式，都有哪些实现？预加载和延迟加载各自都有什么问题？都存在安全问题吗？

* 预先加载有什么缺点吗？

* 有两个使用预先加载的单例类，一个类A一个类B，类B的初始化依赖于类A的初始化完成，使用预先加载的方式可以保证能够完成吗？

* 类A类B在两个不同的文件里面（c++对不同文件（编译单元）里面定义的static变量初始化的顺序有保证吗？）不能够做到的话，这种情况知道怎么解决吗？

* 在一个函数内部定义一个static变量，不对其进行加锁，有线程安全的保证吗？c++11以前没有，c++11以后有了，通过c++11语言标准进行保证的。

* c++11里面用到了哪些东西？

* 引用坍缩的概念有了解吗？（指的就是forward解决的问题，右值引用变成左值的情况）

* 智能指针用过哪些？

* C++智能指针怎么解决循环引用

* unique_ptr有哪些特性？

* shared_ptr有哪些特性？

* shared_ptr保证线程安全吗？为什么不是线程安全的？
--智能指针shared_ptr本身（底层实现原理是引用计数）是线程安全的
智能指针的引用计数在手段上使用了atomic原子操作，只要shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了。首先原子是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。
--智能指针指向的对象的线程安全问题，智能指针没有做任何保障
遇到的问题
对于智能指针shared_ptr的引用计数本身是安全且无锁的，但对象的读写则不是，因为 shared_ptr 有两个数据成员，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象，当智能指针发生拷贝的时候，标准库的实现是先拷贝智能指针，再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子操作，隐患就出现在这里。两个线程中智能指针的引用计数同时++或--，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。
下多线程编程中的三个核心概念，可以作为面试中原因分析的讲解
-- 原子性的举例
这一点，跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。
-- 可见性的举例
可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。
CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。
这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。
-- 顺序性举例
顺序性指的是，程序执行的顺序按照代码的先后顺序执行。处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。

解决办法——加入互斥锁
使用互斥锁对多线程读写同一个shared_ptr进行加锁操作（多个线程访问同一资源时，为了保证数据的一致性，最简单的方式就是使用 mutex（互斥锁））

一旦一个线程获得了锁对象，那么在临界区时一直是受保护的，具体表现为该线程一直占着资源不放。
-- 临界区的说明
有时我们会遇到两个进/线程共同使用同一个资源的情况，这个资源就称为临界区。临界区是指某一时间只能有一个线程执行的一个代码段

-- 加入互斥锁的代码展示
方法1：直接操作 mutex，即直接调用 mutex 的 lock / unlock 函数
```c++
#include <iostream>
#include <boost/thread/mutex.hpp>
#include <boost/thread/thread.hpp>
 
boost::mutex mutex;
int count = 0;
 
void Counter() {
  mutex.lock();
 
  int i = ++count;
  std::cout << "count == " << i << std::endl;
 
  // 前面代码如有异常，unlock 就调不到了。
  mutex.unlock();
}
 
int main() {
  // 创建一组线程。
  boost::thread_group threads;
  for (int i = 0; i < 4; ++i) {
    threads.create_thread(&Counter);
  }
 
  // 等待所有线程结束。
  threads.join_all();
  return 0;
}
```
-- 方法2：使用 lock_guard 自动加锁、解锁。原理是 RAII，和智能指针类似
C++利用了一个非常好的特性：当一个对象初始化时自动调用构造函数，当一个对象到达其作用域结尾时，自动调用析构函数。所以我们可以利用这个特性解决锁的维护问题：把锁封装在对象内部！此时，在构造函数时获得锁，在语句返回前自动调用析构函数释放锁。其实这种做法有个专有的名称，叫做RAII
```c++
#include <iostream>
#include <boost/thread/lock_guard.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/thread.hpp>
 
boost::mutex mutex;
int count = 0;
 
void Counter() {
  // lock_guard 在构造函数里加锁，在析构函数里解锁。
  boost::lock_guard<boost::mutex> lock(mutex);
 
  int i = ++count;
  std::cout << "count == " << i << std::endl;
}
 
int main() {
  boost::thread_group threads;
  for (int i = 0; i < 4; ++i) {
    threads.create_thread(&Counter);
  }
 
  threads.join_all();
  return 0;
}
```

* vector的扩容过程？
  -- 当向vector中插入元素时，如果元素有效个数size与空间容量capacity相等时，vector内部会触发扩容机制：

* 有什么方法能够避免vector的动态扩容过程呢？
  -- 如果要避免扩容而导致程序效率过低问题，其实非常简单：如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可
  -- 如果插入之前进行reserve，只要空间给足，则插入时不会扩容，如果没有reserve，则会边插入边扩容，效率极其低下。

* 虚基类的作用 --菱形继承

* 移动构造函数的优点
  --移动构造函数是c++11的新特性，移动构造函数传入的参数是一个右值 用&&标出。
  --首先讲讲拷贝构造函数：拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间

* 
而移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。

```c++
    Str(const Str &s) {
cout<<"拷贝构造函数..."<<endl;
str = NULL;
int len = strlen(s.str);
str = (char *)malloc(len + 1);
memset(str, 0, len + 1);
strcpy(str, s.str);
}
demo(const demo &d):num(new int(*d.num)) {
cout<<"copy construct!"<<endl;
}
Str(Str &&s) {
cout<<"移动构造函数..."<<endl;
str = NULL;
str = s.str;
s.str = NULL;
}
//添加移动构造函数
demo(demo &&d):num(d.num) {
d.num = NULL;
cout<<"move construct!"<<endl;
}
A(A&x) {
this->num = new int(*x.num);
cout << "拷贝构造函数" << endl;
}
A(A&&x) {
this->num = x.num;
x.num = nullptr;
cout << "移动构造函数" << endl;
}

```

* 线程安全的单例模式

-

* 从C++源文件到可执行程序有几步

#### 第二部分：操作系统

* 进程和线程有什么区别？

* 哪些资源是线程独占的？

* 线程死循环会导致所在进程（单线程进程和多线程进程）出现什么问题，有什么影响？出现假死现象（一定会出现假死吗？）
  CPU会飙升吗？
* 线程崩溃会导致进程崩溃吗？一定会导致进程崩溃吗？

* 线程崩溃之后会使用什么方式通知进程呢？

* fork()之前创建的socket，父子进程能否同时读/写此socket？
  fork()创建的socket，父子进程可以同时读/写此socket，父子进程会轮流获得socket读/写权，这点好像和1）冲突，需要详细研究内因。

第三部分：计算机网络

* TCP、UDP可以绑定相同的端口吗？
  -TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP
  -所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。
  -因此，TCP/UDP 各自的端口号也相互独立，互不影响。

* 多个TCP进程可以绑定同一个端口吗？
  如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。
  如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。

* 什么情况下，可以重新利用这个端口？

* 如何解决服务端重启时，报错“Address already in use”的问题？
  当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。
  当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行
  bind() 函数的时候，就会返回了 Address already in use 的错误。
  要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。
  这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。

* 如果没有开启 net.ipv4.tcp_tw_reuse 内核参数，那么内核就会选择下一个端口，然后继续判断，直到找到一个没有被相同四元组的连接使用的端口
* 如果端口资源耗尽还是没找到，那么 connect 函数就会返回错误。
  如果开启了 net.ipv4.tcp_tw_reuse 内核参数，就会判断该四元组的连接状态是否处于 TIME_WAIT 状态，如果连接处于 TIME_WAIT 状态并且该状态持续的时间超过了 1 秒，
* 那么就会重用该连接，于是就可以使用 2222 端口了，这时 connect 就会返回成功。
  再次提醒一次**，开启了 net.ipv4.tcp_tw_reuse 内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用**，所以在服务端开启这个参数是没有效果的。

* 客户端的端口可以重复使用吗？
  -在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。
  -TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。
  -所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP
  连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。

* 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？
  -要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。
  -如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT
  状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。

* 如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？
  -打开 net.ipv4.tcp_tw_reuse 这个内核参数。
  -因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。
  -如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

* 介绍一下time_wait是一个什么状态，为什么需要这个状态，有什么作用？

* time_wait状态会带来什么副作用吗？
  --如果客户端（发起连接方）的 TIME_WAIT 状态过多，占满了所有端口资源
  --那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。

* 但是 TIME_WAIT 状态也不是摆设作用，它的作用有两个：
  --防止具有相同四元组的旧数据包被收到，也就是防止历史连接中的数据，被后面的连接接受，否则就会导致后面的连接收到一个无效的数据，
  --保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭;

* Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：
* net.ipv4.tcp_tw_reuse
  --如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，如果内核选择到的端口，已经被相同四元组的连接占用的时候
  --就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。
  --所以该选项只适用于连接发起方。
* net.ipv4.tcp_tw_recycle
  --如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；
  --要使得这两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1)）。
* 同步IO和异步IO介绍一下？

* PAWS
  --PAWS 就是为了避免这个问题而产生的，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，
  --PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，
  --如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。

* 那什么是 per-host 的 PAWS 机制呢？

per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查。

但是如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。

Per-host PAWS 机制利用TCP option里的 timestamp 字段的增长来判断串扰数据，而 timestamp 是根据客户端各自的 CPU tick 得出的值。

当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后
客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，
所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，
那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。

因此，tcp_tw_recycle 在使用了 NAT 的网络下是存在问题的，
如果它是对 TCP 四元组做 PAWS 检查，而不是对「相同的 IP 做 PAWS 检查」，那么就不会存在这个问题了。

tcp_tw_recycle 在 Linux 4.12 版本后，直接取消了这一参数。

#### accpet 队列满了

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

半连接队列，也称 SYN 队列；
全连接队列，也称 accepet 队列；
服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列
并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除
然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。

#### 半连接队列满了

当服务器造成syn攻击，就有可能导致 TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃。

但是，如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。

syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。

syncookies 参数主要有以下三个值：

0 值，表示关闭该功能；
1 值，表示仅当 SYN 半连接队列放不下时，再启用它；
2 值，表示无条件开启功能；
那么在应对 SYN 攻击时，只需要设置为 1 即可：

#### 这里给出几种防御 SYN 攻击的方法：

* 增大半连接队列；
* 开启 tcp_syncookies 功能
* 减少 SYN+ACK 重传次数
  方式一：增大半连接队列

要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列。否则，只单纯增大 tcp_max_syn_backlog 是无效的。
增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：
增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：
最后，改变了如上这些参数后，要重启 Nginx 服务，因为半连接队列和全连接队列都是在 listen() 初始化的。

方式二：开启 tcp_syncookies 功能

开启 tcp_syncookies 功能的方式也很简单，修改 Linux 内核参数：

方式三：减少 SYN+ACK 重传次数

当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。

那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

#### 全连接队列满了

在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了
这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。

我们可以通过 ss 命令来看 accpet 队列大小，在「LISTEN 状态」时，Recv-Q/Send-Q 表示的含义如下：

Recv-Q：当前 accpet 队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接个数；
Send-Q：当前 accpet 最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务进程，accpet 队列的最大长度为 128；
如果 Recv-Q 的大小超过 Send-Q，就说明发生了 accpet 队列满的情况。

要解决这个问题，我们可以：

调大 accpet 队列的最大长度，调大的方式是通过调大 backlog 以及 somaxconn 参数。
检查系统或者代码为什么调用 accept() 不及时；

做题：
LeetCode：剑指offerⅡ76
LeetCode：剑指offer 35
* 做题，打印出一个数组A中和等于k的整数倍的最短长度的子数组
  做题：四个无序数组排成一个有序数组（我用的快排+归并）
  岛屿数量
  最长升序子序列
#### 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间

* 虚函数表的特征：
  --虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
  --虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
  --虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，
  --不必动态分配内存空间存储虚函数表，所以不在堆中

* 根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：
* 虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别
  由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。
  一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区
  C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码

#### 构造函数、析构函数、虚函数可否声明为内联函数

首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。

* register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率

举个例子：

```c
#include <iostream>
using namespace std;
class A
{
public:
    inline A() {
		cout << "inline construct()" <<endl;
	}
    inline ~A() {
		cout << "inline destruct()" <<endl;
	}
    inline virtual void  virtualFun() {
		cout << "inline virtual function" <<endl;
	}
};
 
int main()
{
	A a;
	a.virtualFun();
    return 0;
}
//输出结果
//inline construct()
//inline virtual function
//inline destruct()

```

* 构造函数和析构函数声明为内联函数是没有意义的

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，
即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），
致使构造函数/析构函数并不像看上去的那么精简。

### 其次，类中的函数默认是内联型的，编译器也只是有选择性的内联，将构造函数和析构函数声明为内联函数是没有什么意义的。

* 将虚函数声明为inline，要分情况讨论
  有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，
* 即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，* 如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，
答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开
综上，当是指向派生类的指针（多态性）调用声明为内联的虚函数时，不会内联展开；
当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

#### C++模板是什么，你知道底层怎么实现的？

* 编译器并不是把函数模板处理成能够处理任意类的函数
* 编译器从函数模板通过具体类型产生不同的函数；
* 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，
最终导致链接错误。

#### C++中基类采用virtual虚析构函数是为了防止内存泄漏。

* 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
* 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
* 那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
  所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

#### 析构函数的作用，如何起作用？

构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。
规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。

析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。
析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。

每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。

#### 构造函数和析构函数可以调用虚函数吗，为什么

在C++中，提倡不在构造函数和析构函数中调用虚函数；
构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；

因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；

析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数
所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。

#### 构造函数或者析构函数中可以调用虚函数吗

简要结论：

从语法上讲，调用完全没有问题。
但是从效果上看，往往不能达到需要的目的。
《Effective C++》的解释是：
派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。

#### 构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？

* 构造函数顺序
  --基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
  --成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
  --派生类构造函数。

* 析构函数顺序
  --调用派生类的析构函数；
  --调用成员类对象的析构函数；
  --调用基类的析构函数。

#### 什么是虚拟继承

由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：

* 虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。
* 虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格
* 表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。

#### 虚析构函数的作用，父类的析构函数是否要设置为虚函数？

C++中基类采用virtual虚析构函数是为了防止内存泄漏。
具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。

假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。

那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。
因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。

#### 构造函数析构函数可否抛出异常

C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。
因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。

用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；

如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；

如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。

#### 构造函数的几种关键字

* default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错

```c++
#include <iostream>
using namespace std;

class CString
{
public:
    CString() = default; //语句1
    //构造函数
    CString(const char* pstr) : _str(pstr){}
    void* operator new() = delete;//这样不允许使用new关键字
    //析构函数
    ~CString(){}
public:
     string _str;
};


int main()
{
   auto a = new CString(); //语句2
   cout << "Hello World" <<endl;
   return 0;
}
//运行结果
//Hello World
```

如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题

* delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示

```c++
#include <iostream>
using namespace std;

class CString
{
public:
    void* operator new() = delete;//这样不允许使用new关键字
    //析构函数
    ~CString(){}
};


int main()
{
   auto a = new CString(); //语句1
   cout << "Hello World" <<endl;
   return 0;
}
```

在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法

* = 0
  将虚函数定义为纯虚函数
  --纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处
  --当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。

#### 构造函数一般不定义为虚函数的原因

* 创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型

* 虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，
  --若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数

* 虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数
  --而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数

#### 类什么时候会析构？

* 对象生命周期结束，被销毁时；

* delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；

* 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

#### 为什么析构函数一般写成虚函数

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，
而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，
这样就会造成派生类对象析构不完全，造成内存泄漏。

* 所以将析构函数声明为虚函数是十分必要的。
  --在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

#### 虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表

虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针

#### 下面阐述实现多态的过程：

* 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址

* 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。
  --在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数

* 在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。
  --在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；
  --当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表

* 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；
* 当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；
* 当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

#### 什么情况会自动生成默认构造函数？

* 具有存在默认构造函数的类成员对象：
  如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。
  不过这个合成操作只有在构造函数真正被需要的时候才会发生

* 如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；

* 带有默认构造函数的基类：
  如果一个没有构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；

* 带有一个虚函数的类

* 带有一个虚基类的类

* 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

#### 抽象基类为什么不能创建对象？ 仅作为接口

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，
派生类将具体实现在其基类中作为接口的操作。

抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。
如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。

纯虚函数引入原因 ： 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数
在很多情况下，基类本身生成对象是不合情理的。
例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。
若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。
同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。

#### 多态性

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作
C++支持两种多态性：编译时多态性，运行时多态性
a.编译时多态性：通过重载函数实现
b.运行时多态性：通过虚函数实现。
虚函数 ： 在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载
抽象类 ： 包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

### 模板类和模板函数的区别是什么？

* 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定
* 即函数模板允许隐式调用和显式调用，而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必；

#### 多继承的优缺点，作为一个开发者怎么看待多继承

* C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
* 多重继承的优点:使对象可以调用多个基类中的接口；
* 问题：如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
  --因此，需要加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
  --或者使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

#### 模板和实现可不可以不写在一个文件里面？为什么？

因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现
在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。

但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，

它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

#26、将字符串“hello world”从开始到打印到屏幕上的全过

#### 静态函数能定义为虚函数吗？常函数呢？说说你的理解

* 静态函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
* 虚函数的调用关系：this -> vptr -> vtable ->virtual function
* 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，
* 因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。

#### 虚函数的代价是什么？

* 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类的空间大小；
* 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
* 不能再内联，因为内联函数在编译阶段进行替代，而虚函数在运行阶段才能确定是采用哪种函数，虚函数不能是内联函数。

#### 什么情况下会合成构造函数？都说一说，你知道的都说一下

* 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数
* 因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；

* 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；
* 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；
* 带有一个虚基类的类

还有一点需要注意的是：
并不是任何没有构造函数的类都会合成一个构造函数
编译器合成出来的构造函数并不会显示设定类内的每一个成员变量

* 哪些函数不能是虚函数？

* 虚函数和纯虚函数区别？
  纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
  纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。
  既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。
  一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象

#### 关于this指针你知道什么？全说出来

* this指针是类的指针，指向对象的首地址。
* this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
* this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

this指针的用处

* 一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。
* this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）
* 编译器会自动将对象本身的地址作为一个隐含参数传递给函数。
* 也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行

this指针的使用

* 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
* 当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）

类的this指针有以下特点

* this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，传入参数为当前对象地址，成员函数第一个参数为为T * const this
  class A{public:    int func(int p){}};
  其中，func的原型在编译器看来应该是：
  int func(A * const this,int p);

* 由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。
* 这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

A a;a.func(10);//此处，编译器将会编译成：A::func(&a,10);

看起来和静态函数没差别，对吗？不过，区别还是有的。
编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。

#### 几个this指针的易混问题

* this指针是什么时候创建的？
  this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。
采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。
采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。
之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答

* this指针存放在何处？堆、栈、全局变量，还是其他？
  this指针会因编译器不同而有不同的放置位置。
* 可能是栈，也可能是寄存器，甚至全局变量。
* 在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

* this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？
  大多数编译器通过ecx寄存器传递this指针。
* 事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。
this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。
自从类的函数定义完成后，它就在那儿，不会跑的

* this指针是如何访问类中的变量的？
  如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构的指针了。

* 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？
* *this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。
* 所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。
* 当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

感谢网友勘误：https://github.com/forthespada/InterviewGuide/issues/10 ，标准情况下this为右值，无法通过&符号获取地址-2021.09.03

* 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？
  普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。
* 只有虚函数才会被放到函数表中。
* 但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。
* 正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

#### 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

* 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。
* 在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。
* 当调用delete this时，类对象的内存空间被释放。
* 在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。
* 一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

#### 为什么是不可预期的问题？

delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。
照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。
delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。
此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。
当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

#### 如果在类的析构函数中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。
显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

### 你知道空类的大小是多少吗？

C++空类的大小不为0，不同编译器设置不一样，vs设置为1；
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。

#### 请说一下以下几种情况下，下面几个类的大小各是多少？

class A {};
int main(){
cout<<sizeof(A)<<endl;// 输出 1;
A a;
cout<<sizeof(a)<<endl;// 输出 1;
return 0;
}

空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。
具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，
这样空类实例化之后就会拥有独一无二的内存地址。
当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。

class A { virtual Fun(){} };
int main(){
cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
A a;
cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
return 0;
}

因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节

class A { static int a; };
int main(){
cout<<sizeof(A)<<endl;// 输出 1;
A a;
cout<<sizeof(a)<<endl;// 输出 1;
return 0;
}

静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小

class A { int a; };
int main(){
cout<<sizeof(A)<<endl;// 输出 4;
A a;
cout<<sizeof(a)<<endl;// 输出 4;
return 0;
}

class A { static int a; int b; };;
int main(){
cout<<sizeof(A)<<endl;// 输出 4;
A a;
cout<<sizeof(a)<<endl;// 输出 4;
return 0;
}

静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节

#### this指针调用成员变量时，堆栈会发生什么变化？

当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。

即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。

例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

#### 类对象的大小受哪些因素影响？

* 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
* 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
* 虚函数的话，会在类对象插入vptr指针，加上指针大小；
* 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展

#### C++从代码到可执行程序经历了什么？

* 预编译
  主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：
  删除所有的#define，展开所有的宏定义。
  处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
  处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
  删除所有的注释，“//”和“/**/”。
  保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。
  添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。

* 编译
  把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。

词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。
语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。
语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。
优化：源代码级别的一个优化过程。
目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。
目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。

* 汇编
  将汇编代码转变成机器可以执行的指令(机器码文件)。
* 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，
* 汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。

* 链接
  将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：
  --静态链接
  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。

--动态链接
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

#### 为什么友元函数必须在类内部声明？

因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。
有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。

勘误

本题问题表达有误，实际上：
友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。
只有友元工厂才必须用到类内声明友元函数。

#### 友元函数和友元类的基本情况

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。
通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。
友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

* 友元函数
  友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。

```c
#include <iostream>
    using namespace std;
    class A
    {
      public:
      friend void set_show(int x, A &a);      //该函数是友元函数的声明
      private:
      int data;
    };
    
    void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员
    {
      a.data = x;
      cout << a.data << endl;
    }
    int main(void)
    {
      class A a;
  
      set_show(1, a);
  
      return 0;
    }
```

一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。

2）友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
但是另一个类里面也要相应的进行声明
```c++
#include <iostream>

using namespace std;

class A
{
public:
friend class C; //这是友元类的声明
private:
int data;
};

class C //友元类定义，为了访问类A中的成员
{
public:
void set_show(int x, A &a) { a.data = x; cout<<a.data<<endl;}
};

int main(void)
{
class A a;
class C c;

c.set_show(1, a);

return 0;
}

```
使用友元类时注意：
* 友元关系不能被继承。
*  友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
* 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

#### 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针

char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。

#### volatile关键字的作用？
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
而且读取的数据立刻被保存。

volatile用在如下的几个地方：

中断服务程序中修改的供其它程序检测的变量需要加volatile；
多任务环境下各任务间共享的标志应该加volatile；
存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

#### 如果有一个空类，它会默认添加哪些函数？
1)  Empty(); // 缺省构造函数//
2)  Empty( const Empty& ); // 拷贝构造函数//
3)  ~Empty(); // 析构函数//
4)  Empty& operator=( const Empty& ); // 赋值运算符//


#### C++中标准库是什么？
C++ 标准库可以分为两部分：
标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。

面向对象类库： 这个库是类及其相关函数的集合。

输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数

标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库

#### 你知道const char* 与string之间的关系是什么吗？
string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化

三者的转化关系如下所示：
```c
a)  string转const char* 

string s = "abc"; 

const char* c_s = s.c_str(); 

b)  const char* 转string //直接赋值即可 

const char* c_s = "abc"; 
 string s(c_s); 

c)  string 转char* 
 string s = "abc"; 
 char* c; 
 const int len = s.length(); 
 c = new char[len+1]; 
 strcpy(c,s.c_str()); 

d)  char* 转string 
 char* c = "abc"; 
 string s(c); 

e)  const char* 转char* 
 const char* cpc = "abc"; 
 char* pc = new char[strlen(cpc)+1]; 
 strcpy(pc,cpc);

f)  char* 转const char* //直接赋值即可 
 char* pc = "abc"; 
 const char* cpc = pc;

```

#### 将引用作为函数参数有哪些好处？
传递引用给函数与传递指针的效果是一样的。
这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

* 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；
而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；

* 如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；
* 在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

#### 你知道数组和指针的区别吗？
数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；

用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。

编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。

在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；

在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。

#### 如何阻止一个类被实例化？有哪些方法？
将类定义为抽象基类或者将构造函数声明为private；

不允许类外部创建类对象，只能在类内部创建对象

#### 如何禁止程序自动生成拷贝构造函数？
为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，
为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用。

类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；

针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。

#### 模板会写吗？写一个比较大小的模板函数
```c++
#include<iostream>

using namespace std;
template<typename type1,typename type2>//函数模板

type1 Max(type1 a,type2 b)
{
  return a > b ? a : b;
}

void main()
{
  cout<<"Max = "<<Max(5.5,'a')<<endl;
}
```

其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a > b 这一步是会报错的。

这个时候往往需要对于 > 号进行重载，这代码量瞬间上来了。

感谢微信好友“江河”指出a、b转型bug，已采纳-2021.06.28

#### strcpy函数和strncpy函数的区别？哪个函数更安全？
函数原型
char* strcpy(char* strDest, const char* strSrc)
char *strncpy(char *dest, const char *src, size_t n)

strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。

strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。

如果目标长>指定长>源长，则将源长全部拷贝到目标长，自动加上’\0’
如果指定长<源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’
如果指定长>目标长，运行时错误 ；
### C++中有几种类型的new
在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new
* plain new

言下之意就是普通的new，就是我们常用的new，在C++中定义如下：
```c++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此plain new在空间分配失败的情况下，抛出异常std::bad_alloc而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：
```c++

#include <iostream>
#include <string>
using namespace std;
int main()
{
try
{
char *p = new char[10e11];
delete p;
}
catch (const std::bad_alloc &ex)
{
cout << ex.what() << endl;
}
return 0;
}
//执行结果：bad allocation

```

* nothrow new
nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：

void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();


举个例子：
```c++


#include <iostream>
#include <string>
using namespace std;

int main()
{
char *p = new(nothrow) char[10e11];
if (p == NULL)
{
cout << "alloc failed" << endl;
}
delete p;
return 0;
}
//运行结果：alloc failed
```
* placement new

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。
placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：

void* operator new(size_t,void*);
void operator delete(void*,void*);


使用placement new需要注意两点：

palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，
这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

举个例子：
```c++

#include <iostream>
#include <string>
using namespace std;
class ADT{
int i;
int j;
public:
ADT(){
i = 10;
j = 100;
cout << "ADT construct i=" << i << "j="<<j <<endl;
}
~ADT(){
cout << "ADT destruct" << endl;
}
};
int main()
{
char *p = new(nothrow) char[sizeof ADT + 1];
if (p == NULL) {
cout << "alloc failed" << endl;
}
ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
//delete q;//错误!不能在此处调用delete q;
q->ADT::~ADT();//显示调用析构函数
delete[] p;
return 0;
}
//输出结果：
//ADT construct i=10j=100
//ADT destruct

```

#### C++的异常处理的方法
在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：

数组下标越界
除法计算时除数为0
动态分配空间时空间不足
...
如果不及时对这些异常进行处理，程序多数情况下都会崩溃。

（1）try、throw和catch关键字

C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：
```c++


#include <iostream>
using namespace std;
int main()
{
double m = 1, n = 0;
try {
cout << "before dividing." << endl;
if (n == 0)
throw - 1;  //抛出int型异常
else if (m == 0)
throw - 1.0;  //拋出 double 型异常
else
cout << m / n << endl;
cout << "after dividing." << endl;
}
catch (double d) {
cout << "catch (double)" << d << endl;
}
catch (...) {
cout << "catch (...)" << endl;
}
cout << "finished" << endl;
return 0;
}
//运行结果
//before dividing.
//catch (...)
//finished

```

代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。**当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。

* 函数的异常声明列表

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：

int fun() throw(int,double,A,B,C){...};



这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常

* C++标准异常类 exception
C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示

bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：
```c++

#include <iostream>
#include <typeinfo>
using namespace std;

class A{
public:
virtual ~A();
};

using namespace std;
int main() {
A* a = NULL;
try {
cout << typeid(*a).name() << endl; // Error condition
}
catch (bad_typeid){
cout << "Object is NULL" << endl;
}
return 0;
}
//运行结果：bject is NULL


```
bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常
### static的用法和作用？
1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0（static变量）

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4.static的第四个作用：C++中的类成员声明static

函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；

在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；

在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；

在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

类内：

static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；

static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

#### 指针和const的用法
当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。

int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量

int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。

底层指针表示指针所指向的变量是一个常量。

#### 形参与实参的区别？
形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。

实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。

实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。

当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

#### 值传递、指针传递、引用传递的区别和效率
值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）

指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）

引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）

效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。

#### 静态变量什么时候初始化
初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，
但在C和C++中静态局部变量的初始化节点又有点不太一样
在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，
所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。

而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，
在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。
所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。
在程序结束，按照构造顺序反方向进行逐个析构。
所以在C++中是可以使用变量对静态局部变量进行初始化的