static的用法和作用


## 先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

解释：
非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的
而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它
由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误


## 保持变量内容的持久
static变量中的记忆功能和全局生存期
存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化
共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。
# 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期
# 把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围

## static的第三个作用是默认初始化为0（static变量）

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。



全局静态变量和局部静态变量的区别
# 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化
# 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期
# 把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围

静态局部变量具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，即它的生命周期是程序运行就存在，程序结束就结束，

他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。也就是在别的函数访问这个变量是错误的。

由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误

局部变量也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。

生命周期在函数结束后就结束了，作用域也仅限于该函数。

静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。

这样即使两个不同的源文件都定义了相同的静态全局变量，他们也是不同的变量。

从分配内存空间看：

全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

1、静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别，单例模式就是利用这个机制。

2、变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。

从以上分析可以看出，把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围，

因此static这个说明符在不同的地方起的作用是不同的。

TIPS：

1、若全局变量仅在单个文件中访问，则可以讲这个变量修改为静态全局变量。

2、若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。

3、全局变量、静态局部变量、静态全局变量都存放在静态数据存储区。

4、函数中必须要使用static变量的情况：当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，

因为他的生命周期是整个程序运行周期。

总结：
# static全局变量与普通的全局变量有什么区别：
static全局变量只初使化一次，防止在其他文件单元中被引用;

# static局部变量和普通局部变量有什么区别：
static局部变量只被初始化一次，下一次依据上一次结果值； 

# static函数与普通函数有什么区别：
static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。


## static的第四个作用：C++中的类成员声明static

函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；

在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；

在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；

在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

# 静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零
我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化；

# 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来
静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。
静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。
静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

类内：
static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；

static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；
静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function
