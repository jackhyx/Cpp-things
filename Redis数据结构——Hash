


typedef struct dict{
         //类型特定函数
         void *type;
         //私有数据
         void *privdata;
         //哈希表-见2.1.2
         dictht ht[2];
         //rehash 索引 当rehash不在进行时 值为-1
         int trehashidx; 
}dict;



散列表的负载因子 = 填入表中的元素个数/散列表的长度

散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。
对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降；
而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费；
因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash；
散列表的rehash过程类似于数组的收缩与扩容。

rehash操作需要满足以下条件:

服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。
服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。
当负载因子小于0.1时，程序自动开始执行收缩操作。
Redis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。

扩容

为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成
当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中
当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表
每次插入一个数据到散列表，都重复上面的过程
经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了
这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了



总结
字典在redis中广泛应用，包括数据库和hash数据结构。

每个字典有两个哈希表，一个是正常使用，一个用于rehash期间使用。

当redis计算哈希时，采用的是MurmurHash2哈希算法。

哈希表采用链表法解决散列冲突，被分配到同一个地址的键会构成一个单向链表：

Redis使用链表法解决散列冲突，每个散列表节点都有一个next指针
多个散列表节点next可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来；


在rehash对哈希表进行扩展或者收缩过程中，会将所有键值对进行迁移，并且这个迁移是渐进式的迁移。
