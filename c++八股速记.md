



### 结构体对齐：
2个原则
alignof->计算
alignas->指定 小于最小单位 忽略
单字节对齐：
#pragma pack(push, 1)
__attribute__(packed)

### 指针 vs 引用
* 变量：存储的是地址 引用变量的别名
* 声明 声明并初始化
* 可以为空  不可以
* sizeof
* 多级 一级
* 可以改变指向 不可以

### 传参： 指针？引用？
返回函数内局部变量的内存时用指针
栈空间敏感如递归时用引用，不需要创建零时变量，开销小
类对象作为参数传递时用引用

### 栈 vs 堆 -- 7点

**管理方式：** 编译器自动管理  程序员管理
**内存分配机制：** 
只要栈剩余空间大于申请使用，系统就可以提供内存 
系统有一个记录空闲内存的地址的链表，收到申请时，遍历链表，找到第一个大于申请空间的堆结点，删除结点，并将空间分配给程序
**内存大小**： 连续内存2M(windows) 不连续内存虚拟内存 3G(32位)
**碎片问题**： 不会 会
**生长方向**： 向低地址 向高地址
**分配方式**： 动态、静态  动态 手动释放
**分配效率**： 底层提供支持：专门的寄存器存放栈地址，专门指令 库函数 效率底

### malloc/free vs delete/new

库函数 头文件支持  c++运算符
malloc手动计算分配空间大小  自动
类型不安全 需要转换void*  返回类型的指针 类型安全
new 调用operate new 库函数 分配足够空间 ->调用对象的构造函数
delete 调用对象的析构函数-> 调用operate delete库函数释放空间

### 对于非基本类型对象创建需要构造函数，销毁需要析构函数 不能把构造函数和析构函数强加给malloc/free

### 宏  vs  函数
预编译阶段，文本插入替换 不存在函数调用  运行时需要跳转到具体函数
无返回值
没有类型 不需要类型检查  需要类型检查
分号
### 宏  vs typedef
定义常量和书写复杂的内容 定义类型别名
预编译，文本插入替换  编译
类型检查 需要类型检查
分号

### 宏 vs const
预编译 编译运行时确定

没有类型检查 需要类型检查

插入替换 没有分配内存  分配空间
### 变量声明和定义

仅仅告知编译器类型和位置不分配内存空间  需要分配内存空间
多出声明一次定义

### sizeof strlen

运算符  结果编译时得到  字符处理库函数

任何类型和数据参数不退化  字符指针 且 '0'结尾

不能得到动态分配变量的大小

### 指针常量 vs 常量指针

指针指向的对象是常量  指针是个常量 必须初始化 不能改变指向

### c++ vs python

编译语言 编译后特定平台 效率高   脚本语言 解释执行 跨平台效率底
花括号  缩进区分代码块
指定变量类型   不需要
python库函数多 调用方便

### c++ vs c
new/ delete  --- malloc/free
字符串类 --- 字符数组
try/catch/throw --- setjmp() longjmp()
允许同名函数重载 不允许
控制输出输出iostream --- stdio库
新增引用和关键字

### c++ 中 class struct

同 ： 都能拥有成员变量和成员函数 
任何 用 class完成 struct也能完成

异： 默认private private继承  默认public public继承

### struct  c  vs  c++
用户自定义数据结构  抽象数据类型
没有权限设置 可以封装而不可以隐藏 成员不可以是函数 
增加了权限 成员可以是函数

### static vs const

**static
不考虑类**：

不加static的全局变量和函数具有全局可见性 加了之后只能在该文件所在编译模块

默认初始化0 存在全局未初始化区

**考虑类：**

只与类关联 类中定义 类外初始化

static成员函数 没有this指针无法访问非static成员变量和非static成员函数

不能被const volatile 虚函数 可以被非static成员函数任意访问

const:
定义时初始化，之后无法更改
const形参可以接受const和非const实参

考虑类： const成员变量只能在类中用构造函数初始化列表初始化
const成员函数 const对象不能调用非const成员函数 不能改变非mutable数据的值

### 顶层const vs 底层const
const修饰变量本身是一个常量
const修饰变量所指的对象是要给常量
const_cats改变底层const

### override  final

表面函数是重写的父类的虚函数

不希望类被继承或函数被重写

### 直接初始化 vs  拷贝初始化
直接调用构造函数  调用拷贝构造函数

### 野指针 vs 悬空指针

没有被初始化的指针--及时初始化  内存已经被释放--及时置空

### 重载 vs 重写 vs 隐藏/重定义


### 构造函数

默认构造
初始化构造
移动构造
拷贝构造
委托构造
转换构造

### 深拷贝 vs 浅拷贝

### 判断大小端

### volatile mutable explicit

表示可以被编译器未知因素修改，使用时总是从内存读取数据，而不是寄存器的备份

突破const限制 在const函数中使用

修饰构造函数 不能发生隐式类型转换

### 调用拷贝构造函数
用类的实例化对象初始另一个对象时
函数参数是类对象（非引用
函数返回值是局部对象的类对象
NRV:linux不管是值返回还是引用返回都不会调用拷贝构造
windows值返回调用拷贝构造

### new
plain new 普通new 失败时std::bad_alloc
nothrow new 失败时返回nullptr
placement new 不分配内存 在已经分配成功的内存上调用构造函数

### c++异常处理

try throw catch
异常声明列表
标准异常类

### 值传递 vs 指针传递 vs 引用传递

值：发生形参向函数所属栈拷贝数据的过程 如果是对象或者大的结构体 耗费一定的空间和时间
指针：同样发生形参向函数所属栈拷贝数据， 此时拷贝的是一个地址 4字节
引用：传地址
效率上，指针和引用效率更高

### 形参 vs 实参

### 静态变量初始化
初始化一次，多次赋值，在主程序之前，编译器已经分配好了内存
和全局变量一样，存放在全局数据区

### const关键字
阻止一个变量被改变， 定义变量时初始化
修饰指针
修饰形参，表明在函数内部不能改变

修饰类的成员函数-- 常函数 不能修改类的成员变量，常对象只能访问常函数

#### 汇编层次 引用通过指针实现


#### new vs malloc

c++关键字 or 运算符  库函数 头文件支持

申请内存无需指定大小 编译器计算   手动计算
成功时返回对象类型的指针 无需类型转换，类型安全  返回void* 需要强制转换成我们需要的类型

失败bad_alloc  失败返回nullptr

先调用operate new 函数，申请足够内存，调用对象的构造函数

#### new和delete的实现原理， delete是如何知道释放内存的大小的
#### malloc与free的实现原理？

### 类成员初始化方式
赋值初始化， 函数体内赋值 分配空间后才初始化 产生临时对象
列表初始化，在冒号后使用初始化列表初始化 分配空间同时初始化 初始化时函数体还未执行
### 构造函数的执行顺序 
派生类：
虚拟基类
基类
类成员对象的构造函数
派生类自己

### 为什么用成员初始化列表会快一些
赋值初始化，多了一次默认构造
列表初始化，不会产生临时对象 只赋值

### 有哪些情况必须用到成员列表初始化？作用是什么？
初始化引用成员、 常量成员
调用基类构造函数 拥有一组参数
调用成员类的构造函数 拥有一组参数

编译器操作初始化列表 适合当的顺序在构造函数之内安插初始化操作
顺序由成员声明顺序决定

### c++ string vs c char*数组

对char*数组的封装 包含数组，容量，长度等
动态扩展

### 内存泄露
堆内存泄露：
避免：计数法 基类析构函数声明为虚，对象数组delete[] 成对出现
检测valgrind

### 对象复用
享元模式 对象存储到对象池避免多次创建重复对象
### 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。

### 强制转换
reinterpret_cast
const_cast
dynamic_cast
static_cast

### 如何获得结构成员相对于结构开头的字节偏移量
offsetof

### 动态类型静态类型动态绑定静态绑定
静态类型：对象声明时的类型，在编译器已经决定
动态：   指针或引用所指对象的类型，在运行期决定

静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型 发生在编译器
动态   ： 

### 全局变量和局部变量有什么区别

### 方法调用的原理

### 类如何实现只能静态分配和只能动态分配
把new、delete运算符重载为private属性
构造、析构函数设为protected属性，再用子类来动态创建

### 继承机制中对象之间如何转换？指针和引用之间如何转换？

### 在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。

### 隐式转换，如何消除隐式转换？
编译器行为
隐式转换发生在从小->大的转换中
如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制
explicit禁止隐式转换 只对一个实参的构造函数有效

### 如何在不使用额外空间的情况下，交换两个数


### strcpy vs memcpy

赋值字符串   任意内容
遇到'0' 指定长度

### 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，
数组是 argv[]，所有的参数在指针 char* 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。

### volatile
变量可以被编译器未知因素修改 系统总是从内存读取数据而不是寄存器的备份

中断服务程序中修改供其他程序检测的变量
多任务环境各任务间共享的标志
存储器隐射的硬件寄存器

### 空类默认添加
默认构造
拷贝构造
析构
拷贝赋值

### 模板会写吗？写一个比较大小的模板函数
# include＜bits/stdc++.h＞
using namespace std;
template<typename tpye1, typename type2>
type1 Max(type1 a, type2 b) {
    return a > b ? a : b;
}

### static_cast比C语言中的转换强在哪里？
更加安全；
更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；
可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图

### C++从代码到可执行程序经历了什么？
* 预编译 处理#开头的预编译指令
删除#define 展开宏定义
处理预编译指令
递归头文件
删除注释
保留#pragma编译器指令

* 编译 生成汇编代码
词法分析 语法分析 语义分析 优化 目标代码生成 目标代码优化

* 汇编 汇编代码->机器码
* 链接 不同源文件->可执行文件

### 静态链接  vs 动态链接


### 内联函数 代价
以代码复杂为代价 省去函数调用开销 提高执行效率
内联函数体内代码执行时间相比函数调用开销大 没有意义
每一处内联函数调用需要复制代码 代码长->内存开销大

### 垃圾回收机制
空间和时间
开辟空间保存指针的引用计数和标记
开辟单独进程在空间时释放内存

使c++不适合底层操作

