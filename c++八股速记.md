### 结构体对齐：
2个原则：

结构体成员其实地址应该为该成员sizeof大小的整倍数
结构体内存总大小为sizeof最大成员大小的整倍数

alignof->计算
alignas->指定 小于最小单位 忽略
单字节对齐：
#pragma pack(push, 1)
__attribute__(packed)

### 指针 vs 引用
* 变量：存储的是地址 引用变量的别名
* 声明 声明并初始化
* 可以为空  不可以
* sizeof
* 多级 一级
* 可以改变指向 不可以

### 传参： 指针？引用？
返回函数内局部变量的内存时用指针
栈空间敏感如递归时用引用，不需要创建零时变量，开销小
类对象作为参数传递时用引用

### 栈 vs 堆 -- 7点

**管理方式：** 编译器自动管理  程序员管理
**内存分配机制：** 
只要栈剩余空间大于申请使用，系统就可以提供内存 
系统有一个记录空闲内存的地址的链表，收到申请时，遍历链表，找到第一个大于申请空间的堆结点，删除结点，并将空间分配给程序
**内存大小**： 连续内存2M(windows) 不连续内存虚拟内存 3G(32位)
**碎片问题**： 不会 会
**生长方向**： 向低地址 向高地址
**分配方式**： 动态、静态  动态 手动释放
**分配效率**： 底层提供支持：专门的寄存器存放栈地址，专门指令 库函数 效率底

### malloc/free vs delete/new

库函数 头文件支持  c++运算符
malloc手动计算分配空间大小  自动
类型不安全 需要转换void*  返回类型的指针 类型安全
new 调用operate new 库函数 分配足够空间 ->调用对象的构造函数
delete 调用对象的析构函数-> 调用operate delete库函数释放空间

### 对于非基本类型对象创建需要构造函数，销毁需要析构函数 不能把构造函数和析构函数强加给malloc/free

### 宏  vs  函数
预编译阶段，文本插入替换 不存在函数调用  运行时需要跳转到具体函数
无返回值
没有类型 不需要类型检查  需要类型检查
分号
### 宏  vs typedef
定义常量和书写复杂的内容 定义类型别名
预编译，文本插入替换  编译
类型检查 需要类型检查
分号

### 宏 vs const
预编译 编译运行时确定

没有类型检查 需要类型检查

插入替换 没有分配内存  分配空间
### 变量声明和定义

仅仅告知编译器类型和位置不分配内存空间  需要分配内存空间
多出声明一次定义

### sizeof strlen

运算符  结果编译时得到  字符处理库函数

任何类型和数据参数不退化  字符指针 且 '0'结尾

不能得到动态分配变量的大小

### 指针常量 vs 常量指针

指针指向的对象是常量  指针是个常量 必须初始化 不能改变指向

### c++ vs python

编译语言 编译后特定平台 效率高   脚本语言 解释执行 跨平台效率底
花括号  缩进区分代码块
指定变量类型   不需要
python库函数多 调用方便

### c++ vs c
new/ delete  --- malloc/free
字符串类 --- 字符数组
try/catch/throw --- setjmp() longjmp()
允许同名函数重载 不允许
控制输出输出iostream --- stdio库
新增引用和关键字

### c++ 中 class struct

同 ： 都能拥有成员变量和成员函数 
任何 用 class完成 struct也能完成

异： 默认private private继承  默认public public继承

### struct  c  vs  c++
用户自定义数据结构  抽象数据类型
没有权限设置 可以封装而不可以隐藏 成员不可以是函数 
增加了权限 成员可以是函数

### static vs const

**static
不考虑类**：

不加static的全局变量和函数具有全局可见性 加了之后只能在该文件所在编译模块

默认初始化0 存在全局未初始化区

**考虑类：**

只与类关联 类中定义 类外初始化

static成员函数 没有this指针无法访问非static成员变量和非static成员函数

不能被const volatile 虚函数 可以被非static成员函数任意访问

const:
定义时初始化，之后无法更改
const形参可以接受const和非const实参

考虑类： const成员变量只能在类中用构造函数初始化列表初始化
const成员函数 const对象不能调用非const成员函数 不能改变非mutable数据的值

### 顶层const vs 底层const
const修饰变量本身是一个常量
const修饰变量所指的对象是要给常量
const_cats改变底层const

### override  final

表面函数是重写的父类的虚函数

不希望类被继承或函数被重写

### 直接初始化 vs  拷贝初始化
直接调用构造函数  调用拷贝构造函数

### 野指针 vs 悬空指针

没有被初始化的指针--及时初始化  内存已经被释放--及时置空

### 重载 vs 重写 vs 隐藏/重定义


### 构造函数

默认构造
初始化构造
移动构造
拷贝构造
委托构造
转换构造

### 深拷贝 vs 浅拷贝

### 判断大小端

### volatile mutable explicit

表示可以被编译器未知因素修改，使用时总是从内存读取数据，而不是寄存器的备份

突破const限制 在const函数中使用

修饰构造函数 不能发生隐式类型转换

### 调用拷贝构造函数
用类的实例化对象初始另一个对象时
函数参数是类对象（非引用
函数返回值是局部对象的类对象
NRV:linux不管是值返回还是引用返回都不会调用拷贝构造
windows值返回调用拷贝构造

### new
plain new 普通new 失败时std::bad_alloc
nothrow new 失败时返回nullptr
placement new 不分配内存 在已经分配成功的内存上调用构造函数

### c++异常处理

try throw catch
异常声明列表
标准异常类

### 值传递 vs 指针传递 vs 引用传递

值：发生形参向函数所属栈拷贝数据的过程 如果是对象或者大的结构体 耗费一定的空间和时间
指针：同样发生形参向函数所属栈拷贝数据， 此时拷贝的是一个地址 4字节
引用：传地址
效率上，指针和引用效率更高

### 形参 vs 实参

### 静态变量初始化
初始化一次，多次赋值，在主程序之前，编译器已经分配好了内存
和全局变量一样，存放在全局数据区

### const关键字
阻止一个变量被改变， 定义变量时初始化
修饰指针
修饰形参，表明在函数内部不能改变

修饰类的成员函数-- 常函数 不能修改类的成员变量，常对象只能访问常函数

#### 汇编层次 引用通过指针实现


#### new vs malloc

c++关键字 or 运算符  库函数 头文件支持

申请内存无需指定大小 编译器计算   手动计算
成功时返回对象类型的指针 无需类型转换，类型安全  返回void* 需要强制转换成我们需要的类型

失败bad_alloc  失败返回nullptr

先调用operate new 函数，申请足够内存，调用对象的构造函数

#### new和delete的实现原理， delete是如何知道释放内存的大小的
#### malloc与free的实现原理？

### 类成员初始化方式
赋值初始化， 函数体内赋值 分配空间后才初始化 产生临时对象
列表初始化，在冒号后使用初始化列表初始化 分配空间同时初始化 初始化时函数体还未执行
### 构造函数的执行顺序 
派生类：
虚拟基类
基类
类成员对象的构造函数
派生类自己

### 为什么用成员初始化列表会快一些
赋值初始化，多了一次默认构造
列表初始化，不会产生临时对象 只赋值

### 有哪些情况必须用到成员列表初始化？作用是什么？
初始化引用成员、 常量成员
调用基类构造函数 拥有一组参数
调用成员类的构造函数 拥有一组参数

编译器操作初始化列表 适合当的顺序在构造函数之内安插初始化操作
顺序由成员声明顺序决定

### c++ string vs c char*数组

对char*数组的封装 包含数组，容量，长度等
动态扩展

### 内存泄露
堆内存泄露：
避免：计数法 基类析构函数声明为虚，对象数组delete[] 成对出现
检测valgrind

### 对象复用
享元模式 对象存储到对象池避免多次创建重复对象
### 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。

### 强制转换
reinterpret_cast
const_cast
dynamic_cast
static_cast

### 如何获得结构成员相对于结构开头的字节偏移量
offsetof

### 动态类型静态类型动态绑定静态绑定
静态类型：对象声明时的类型，在编译器已经决定
动态：   指针或引用所指对象的类型，在运行期决定

静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型 发生在编译器
动态   ： 

### 全局变量和局部变量有什么区别

### 方法调用的原理

### 类如何实现只能静态分配和只能动态分配
把new、delete运算符重载为private属性
构造、析构函数设为protected属性，再用子类来动态创建

### 继承机制中对象之间如何转换？指针和引用之间如何转换？

### 在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。

### 隐式转换，如何消除隐式转换？
编译器行为
隐式转换发生在从小->大的转换中
如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制
explicit禁止隐式转换 只对一个实参的构造函数有效

### 如何在不使用额外空间的情况下，交换两个数


### strcpy vs memcpy

复制字符串   任意内容
遇到'0' 指定长度

### 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，
数组是 argv[]，所有的参数在指针 char* 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。

### volatile
变量可以被编译器未知因素修改 系统总是从内存读取数据而不是寄存器的备份

中断服务程序中修改供其他程序检测的变量
多任务环境各任务间共享的标志
存储器映射的硬件寄存器

### 空类默认添加
默认构造
拷贝构造
析构
拷贝赋值
### 模板会写吗？写一个比较大小的模板函数
# include＜bits/stdc++.h＞
using namespace std;
template<typename tpye1, typename type2>
type1 Max(type1 a, type2 b) {
    return a > b ? a : b;
}

### static_cast比C语言中的转换强在哪里？
更加安全；
更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；
可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图

### C++从代码到可执行程序经历了什么？
* 预编译 处理#开头的预编译指令
删除#define 展开宏定义
处理预编译指令
递归头文件
删除注释
保留#pragma编译器指令

* 编译 生成汇编代码
词法分析 语法分析 语义分析 优化 目标代码生成 目标代码优化

* 汇编 汇编代码->机器码
* 链接 不同源文件->可执行文件

### 静态链接  vs 动态链接


### 内联函数 代价
以代码复杂为代价 省去函数调用开销 提高执行效率
内联函数体内代码执行时间相比函数调用开销大 没有意义
每一处内联函数调用需要复制代码 代码长->内存开销大

### 垃圾回收机制
空间和时间
开辟空间保存指针的引用计数和标记
开辟单独进程在空间时释放内存

使c++不适合底层操作


### 构造函数虚函数，析构函数虚函数

析构函数可以是虚函数，并且一般需要是虚函数
当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
纯虚函数，抽象类，不能被实例化 但派生类可以重写

构造函数不能是虚函数
虚函数类中存在一个虚函数表，类对象中存储vptr指向虚函数表，如果构造函数是虚函数，需要vptr找到虚函数表，但是此时对象还没有初始化

### 绝不能在构造函数和析构函数中调用虚函数
父类的构造函数执行早于子类的构造函数，
当父类的构造函数执行时， 子类成员尚未初始化，此时调用虚函数会下降到子类层次，存在使用子类未初始化成员的风险；

### 虚函数表存放在内存的位置
* 虚函数特征：
全局共享，在编译时构造完成
虚函数表类似于一个数组，类对象中存储vptr指向vtable->虚函数表不是函数，不时程序代码，不存储在代码段
虚函数表的大小和空间分配在编译器确定，不需要动态分配，所以不在堆中
* 全局数据区
linux只读数据段rodata windows常量段
* 虚函数代码段

### register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率

### 构造函数和析构函数声明为内联函数是没有意义的
编译器不会对声明为内联的析构和构造函数真正进行内联，因为编译器会在构造和析构过程中添加额外的操作，致使析构构造函数不会向看上去那么精简
* 类中函数也是默认内联，但是编译器也只是选择性内联
* 虚函数：内联是编译器决定，虚函数是运行期才决定

### 模板的底层
编译器不是把函数模板处理成能处理任意类的函数，编译器从函数模板通过具体类型产生不同的函数，
编译器会对函数模板进行两次编译，在声明的地方对模板本身编译
在调用的地方对参数替换后的函数代码进行编译

函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件
如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误

### 构造函数顺序
基类构造函数，多个基类，按在派生类中出现的顺序而不是成员初始化列表中的顺序
成员类对象构造 按被声明的顺序
派生类构造函数
### 析构函数顺序
调用派生类构造
成员类对象
基类机构函数

### 纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。
因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数

### 类什么时候会析构
对象声明周期结束
delete对象的指针时， delete指向对象的基类指针，并且基类析构函数时虚函数
对象i是对象o的成员，o的析构函数被调用时,i的析构函数也调用

### = default
显示要求编译器合成构造函数
### = delete
删除构造函数，拷贝赋值运算符
### = 0 将虚函数定义为纯虚函数

### 构造函数
对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数
### 拷贝构造函数
对象不存在，但是使用别的已经存在的对象来进行初始化
### 赋值运算符
对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的

### 拷贝构造函数 vs 拷贝赋值运算符
函数  运算符重载
生成新的对象  不能
构造一个新的对象，初始化对象时不需要检查源对象和新建对象是否相同
需要提供不同策略，如果源对象有内存分配需要先释放

### 什么情况会自动生成默认构造函数
* 带有默认构造函数的类成员对象：如果一个类没有构造函数，但有一个成员对象，带有默认构造函数
* 带有默认构造函数的基类：如果一个没有默认构造函数的派生类派生自一个带有默认构造函数的基类，那么会合成一个构造函数调用上一层基类的默认构造函数
* 带有虚函数的类
* 带有虚基类的类
* 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化

### 多继承：
c++允许为一个派生类指定多个基类，对象可以调用多个基类的接口
如果多个基类有相同的基类，调用祖先的接口，容易出现二义性
加上全局符确定是哪一份拷贝
使用虚继承 只拥有一份虚基类一份拷贝

### 为什么拷贝构造函数必须传引用不能传值？

引用传递: 无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！
而地址总是指针类型(属于简单类型)
显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型)
拷贝构造函数使用值传递会产生无限递归调用，内存溢出。
拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数
而拷贝构造函数需要传递实参，所以会一直递归。

### 静态函数能定义为虚函数吗？常函数呢？
静态函数不属于任何类对象或类实例没有意义
没有this指针

### 虚函数代价
每个类有虚函数表
每个类对象有指向虚表的指针
不能再内联

### 哪些函数不能是虚函数？把你知道的都说一说
构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；
当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；
内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数

### 静态链接 vs 动态链接
-- 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序
* 函数和数据编译进一个二进制文件
空间浪费：每个可执行程序对所有需要的目标程序都有一分副本
更新困难：库函数代码修改了，需要重新编译链接

* 把程序按照模块拆分成各个独立模块，运行时才链接成一个完整程序
共享库：每个程序依赖一个库，多个程序在执行时共享同一份副本
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍
当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。


### 漏桶算法 令牌桶算法
强行限制数据的传输速率
限制数据的平均传输速率的同时 允许某种程度的突发传输