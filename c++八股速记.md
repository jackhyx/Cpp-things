



### 结构体对齐：
2个原则
alignof->计算
alignas->指定 小于最小单位 忽略
单字节对齐：
#pragma pack(push, 1)
__attribute__(packed)

### 指针 vs 引用
* 变量：存储的是地址 引用变量的别名
* 声明 声明并初始化
* 可以为空  不可以
* sizeof
* 多级 一级
* 可以改变指向 不可以

### 传参： 指针？引用？
返回函数内局部变量的内存时用指针
栈空间敏感如递归时用引用，不需要创建零时变量，开销小
类对象作为参数传递时用引用

### 栈 vs 堆 -- 7点

**管理方式：** 编译器自动管理  程序员管理
**内存分配机制：** 
只要栈剩余空间大于申请使用，系统就可以提供内存 
系统有一个记录空闲内存的地址的链表，收到申请时，遍历链表，找到第一个大于申请空间的堆结点，删除结点，并将空间分配给程序
**内存大小**： 连续内存2M(windows) 不连续内存虚拟内存 3G(32位)
**碎片问题**： 不会 会
**生长方向**： 向低地址 向高地址
**分配方式**： 动态、静态  动态 手动释放
**分配效率**： 底层提供支持：专门的寄存器存放栈地址，专门指令 库函数 效率底

### malloc/free vs delete/new

库函数 头文件支持  c++运算符
malloc手动计算分配空间大小  自动
类型不安全 需要转换void*  返回类型的指针 类型安全
new 调用operate new 库函数 分配足够空间 ->调用对象的构造函数
delete 调用对象的析构函数-> 调用operate delete库函数释放空间

### 对于非基本类型对象创建需要构造函数，销毁需要析构函数 不能把构造函数和析构函数强加给malloc/free

### 宏  vs  函数
预编译阶段，文本插入替换 不存在函数调用  运行时需要跳转到具体函数
无返回值
没有类型 不需要类型检查  需要类型检查
分号
### 宏  vs typedef
定义常量和书写复杂的内容 定义类型别名
预编译，文本插入替换  编译
类型检查 需要类型检查
分号

### 宏 vs const
预编译 编译运行时确定

没有类型检查 需要类型检查

插入替换 没有分配内存  分配空间
### 变量声明和定义

仅仅告知编译器类型和位置不分配内存空间  需要分配内存空间
多出声明一次定义

### sizeof strlen

运算符  结果编译时得到  字符处理库函数

任何类型和数据参数不退化  字符指针 且 '0'结尾

不能得到动态分配变量的大小

### 指针常量 vs 常量指针

指针指向的对象是常量  指针是个常量 必须初始化 不能改变指向

### c++ vs python

编译语言 编译后特定平台 效率高   脚本语言 解释执行 跨平台效率底
花括号  缩进区分代码块
指定变量类型   不需要
python库函数多 调用方便

### c++ vs c
new/ delete  --- malloc/free
字符串类 --- 字符数组
try/catch/throw --- setjmp() longjmp()
允许同名函数重载 不允许
控制输出输出iostream --- stdio库
新增引用和关键字

### c++ 中 class struct

同 ： 都能拥有成员变量和成员函数 
任何 用 class完成 struct也能完成

异： 默认private private继承  默认public public继承

### struct  c  vs  c++
用户自定义数据结构  抽象数据类型
没有权限设置 可以封装而不可以隐藏 成员不可以是函数 
增加了权限 成员可以是函数

### static vs const

**static
不考虑类**：

不加static的全局变量和函数具有全局可见性 加了之后只能在该文件所在编译模块

默认初始化0 存在全局未初始化区

**考虑类：**

只与类关联 类中定义 类外初始化

static成员函数 没有this指针无法访问非static成员变量和非static成员函数

不能被const volatile 虚函数 可以被非static成员函数任意访问

const:
定义时初始化，之后无法更改
const形参可以接受const和非const实参

考虑类： const成员变量只能在类中用构造函数初始化列表初始化
const成员函数 const对象不能调用非const成员函数 不能改变非mutable数据的值

### 顶层const vs 底层const
const修饰变量本身是一个常量
const修饰变量所指的对象是要给常量
const_cats改变底层const

### override  final

表面函数是重写的父类的虚函数

不希望类被继承或函数被重写

### 直接初始化 vs  拷贝初始化
直接调用构造函数  调用拷贝构造函数

### 野指针 vs 悬空指针

没有被初始化的指针--及时初始化  内存已经被释放--及时置空

### 重载 vs 重写 vs 隐藏/重定义


### 构造函数

默认构造
初始化构造
移动构造
拷贝构造
委托构造
转换构造

### 深拷贝 vs 浅拷贝

### 判断大小端

### volatile mutable explicit

表示可以被编译器未知因素修改，使用时总是从内存读取数据，而不是寄存器的备份

突破const限制 在const函数中使用

修饰构造函数 不能发生隐式类型转换

### 调用拷贝构造函数
用类的实例化对象初始另一个对象时
函数参数是类对象（非引用
函数返回值是局部对象的类对象
NRV:linux不管是值返回还是引用返回都不会调用拷贝构造
windows值返回调用拷贝构造

### new
plain new 普通new 失败时std::bad_alloc
nothrow new 失败时返回nullptr
placement new 不分配内存 在已经分配成功的内存上调用构造函数

### c++异常处理

try throw catch
异常声明列表
标准异常类

### 值传递 vs 指针传递 vs 引用传递

值：发生形参向函数所属栈拷贝数据的过程 如果是对象或者大的结构体 耗费一定的空间和时间
指针：同样发生形参向函数所属栈拷贝数据， 此时拷贝的是一个地址 4字节
引用：传地址
效率上，指针和引用效率更高

### 形参 vs 实参

### 静态变量初始化
初始化一次，多次赋值，在主程序之前，编译器已经分配好了内存
和全局变量一样，存放在全局数据区

### const关键字
阻止一个变量被改变， 定义变量时初始化
修饰指针
修饰形参，表明在函数内部不能改变

修饰类的成员函数-- 常函数 不能修改类的成员变量，常对象只能访问常函数

#### 汇编层次 引用通过指针实现


#### new vs malloc

c++关键字 or 运算符  库函数 头文件支持

申请内存无需指定大小 编译器计算   手动计算
成功时返回对象类型的指针 无需类型转换，类型安全  返回void* 需要强制转换成我们需要的类型

失败bad_alloc  失败返回nullptr

先调用operate new 函数，申请足够内存，调用对象的构造函数

#### new和delete的实现原理， delete是如何知道释放内存的大小的
#### malloc与free的实现原理？

### 类成员初始化方式
赋值初始化， 函数体内赋值 分配空间后才初始化 产生临时对象
列表初始化，在冒号后使用初始化列表初始化 分配空间同时初始化 初始化时函数体还未执行
### 构造函数的执行顺序 
派生类：
虚拟基类
基类
类成员对象的构造函数
派生类自己

### 为什么用成员初始化列表会快一些
赋值初始化，多了一次默认构造
列表初始化，不会产生临时对象 只赋值

### 有哪些情况必须用到成员列表初始化？作用是什么？
初始化引用成员、 常量成员
调用基类构造函数 拥有一组参数
调用成员类的构造函数 拥有一组参数

编译器操作初始化列表 适合当的顺序在构造函数之内安插初始化操作
顺序由成员声明顺序决定

### c++ string vs c char*数组

对char*数组的封装 包含数组，容量，长度等
动态扩展

### 内存泄露
堆内存泄露：
避免：计数法 基类析构函数声明为虚，对象数组delete[] 成对出现
检测valgrind

### 对象复用
享元模式 对象存储到对象池避免多次创建重复对象
### 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。

### 强制转换
reinterpret_cast
const_cast
dynamic_cast
static_cast

### 如何获得结构成员相对于结构开头的字节偏移量
offsetof

### 动态类型静态类型动态绑定静态绑定
静态类型：对象声明时的类型，在编译器已经决定
动态：   指针或引用所指对象的类型，在运行期决定

静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型 发生在编译器
动态   ： 

### 全局变量和局部变量有什么区别

### 方法调用的原理

### 类如何实现只能静态分配和只能动态分配
把new、delete运算符重载为private属性
构造、析构函数设为protected属性，再用子类来动态创建

### 继承机制中对象之间如何转换？指针和引用之间如何转换？

### 在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。

### 隐式转换，如何消除隐式转换？
编译器行为
隐式转换发生在从小->大的转换中
如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制
explicit禁止隐式转换 只对一个实参的构造函数有效

### 如何在不使用额外空间的情况下，交换两个数


### strcpy vs memcpy

复制字符串   任意内容
遇到'0' 指定长度

### 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，
数组是 argv[]，所有的参数在指针 char* 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。

### volatile
变量可以被编译器未知因素修改 系统总是从内存读取数据而不是寄存器的备份

中断服务程序中修改供其他程序检测的变量
多任务环境各任务间共享的标志
存储器映射的硬件寄存器

### 空类默认添加
默认构造
拷贝构造
析构
拷贝赋值
### 模板会写吗？写一个比较大小的模板函数
# include＜bits/stdc++.h＞
using namespace std;
template<typename tpye1, typename type2>
type1 Max(type1 a, type2 b) {
    return a > b ? a : b;
}

### static_cast比C语言中的转换强在哪里？
更加安全；
更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；
可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图

### C++从代码到可执行程序经历了什么？
* 预编译 处理#开头的预编译指令
删除#define 展开宏定义
处理预编译指令
递归头文件
删除注释
保留#pragma编译器指令

* 编译 生成汇编代码
词法分析 语法分析 语义分析 优化 目标代码生成 目标代码优化

* 汇编 汇编代码->机器码
* 链接 不同源文件->可执行文件

### 静态链接  vs 动态链接


### 内联函数 代价
以代码复杂为代价 省去函数调用开销 提高执行效率
内联函数体内代码执行时间相比函数调用开销大 没有意义
每一处内联函数调用需要复制代码 代码长->内存开销大

### 垃圾回收机制
空间和时间
开辟空间保存指针的引用计数和标记
开辟单独进程在空间时释放内存

使c++不适合底层操作

### Redis 主从复制第一次同步
三个阶段：
* 建立连接， 协商同步
从服务器：replicaof->psync:runID offset
主：FULLRESYNC 全量复制

* 主服务器同步数据给从服务器
主：bgsave:RDB 期间的写操作没有进来 造成主从服务器间数据不一致
三个时间间隙写入replication buffer:
主生成RDB
主发送RDB给从
从加载RDB

* 主服务器发送新写操作命令给从服务器
从收到RDB 先清空 然后加载RDB
主发送replication buffer 主从数据一致

### 基于长连接的命令传播

分摊主服务器的压力
两个方面 bgsave fork()子进程耗时阻塞主进程
传输RDB网络带宽
主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器。

### 增量复制： 网络断开又恢复
恢复网络后，从请求psync offset != -1
主：CONTINUE——> 发送从断线期间所执行的写命令
怎么知道发送那些增量数据：repl_backlog_buffer:默认1M 避免全量 应该尽可能大一些

从服务器要读取的数据还在里面 就增量复制——>写入replication buffer
不在了 就全量复制


### 怎么判断某个redis节点是否正常工作
心跳检测ping-pong 如果有一半以上节点Ping一个节点没有回应 集群就认为这个节点挂了

主：每个10s ping
从：每隔1s replconf ack{offset} 上报自身偏移量
实时检测主从节点网络状态；上报复制偏移量，检测复制数据是否丢失

#### 主从复制架构中，过期Key处理：
主节点处理或淘汰一个key后，模拟一条del命令发送给从

#### redis是同步复制还是异步复制
收到写命令后，先写到内部缓冲区，然后异步发送给从

#### replication buffer 、repl backlog buffer 区别如下：
repl backlog buffer：保存着最近传播的写命令。
出现的阶段不一样：
是在增量复制阶段出现，一个主节点只分配一个 repl backlog buffer；
在全量复制阶段和增量复制阶段都会出现，主节点会给每个新连接的从节点，分配一个 replication buffer；
这两个 Buffer 都有大小限制的，当缓冲区满了之后，发生的事情不一样：
当 repl backlog buffer 满了，因为是环形结构，会直接覆盖起始位置数据;
当 replication buffer 满了，会导致连接断开，删除缓存，从节点重新连接，重新开始全量复制。

### 为什么会出现主从数据不一致？ 异步复制 无法强一致性

### 如何应对主从数据不一致：
尽量保证主从节点间网络连接状况良好
开发一个外部程序监控主从间复制进度

得到双方复制进度-> 双方复制进度差值-> 大于阈值 不让客户端和这个从节点进行数据读取， 减少读到不一致数据的情况

### Redis单线程为什么这么快？

大部分操作在内存中完成，并且采用高效的数据结构因此Redis的瓶颈可能是机器的内存或者网络带宽，而并非CPU

单线程模型避免多线程竞争，省去多线程切换的时间和性能开销，不会死锁

I/O多路复用，处理大量的客户端socket请求，一个Redis线程处理多个IO流

### 6.0引入多线程，提高处理网络IO的并行度，命令的执行还是单线程

### Redis持久化
AOF：每执行一条写命令，就把该命令以追加的方式写入到文件
RDB：某一时间内存数据，以二进制写入硬盘
混合持久化

### AOF写回
awalys 同步写回
everySec 每秒写回
No 由操作系统控制写回

AOF过大->AOF重写
读取数据库所有键值对，每个键值对用一条命令记录到新的AOF文件上->压缩了AOF文件的体积

AOF重写过程：后台进程bgrewriteaof

重写期间，主进程仍可以处理命令请求，不会阻塞主进程
父子进程共享内存，只读；任意一方修改了共享内存，发生写时复制，父子进程就有了独立数据副本，不用加锁

数据不一致？
AOF重写缓冲区
AOF重写期间，主进程三个工作
执行客户端发来的命令
将执行后写命令追加到AOF缓冲区
....追加到AOF重写缓冲区

子进程完成AOF重写工作后，向主进程发送信号，信号处理函数
将AOF重写缓冲区的内容追加到新的AOF文件，保证数据一致
新的AOF文件改名，覆盖现有AOF

