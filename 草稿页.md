🐔虚函数的简单含义
在某基类中声明为 virtual并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名 ( 参数表 ) { 函数体 }；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。

好了，现在我们大概知道什么是虚函数，虚函数就是类中使用关键 virtual修饰的成员函数，其目的是为了实现多态性。

那么什么是多态性呢？

所谓多态性，顾名思义就是“多个性态”。更具体一点的就是，用一个名字定义多个函数，这些函数执行不同但相似的工作。最简单的多态性的实现方式就是函数重载和模板，这两种属于静态多态性。还有一种是动态多态性，其实现方式就是我们今天要说的虚函数。下面来看一段简单的代码

class A{
public:
void print(){ cout<<”This is A”<<endl;}
};

class B:public A{
public:
void print(){ cout<<”This is B”<<endl;}
};

int main(){   //为了在以后便于区分，我这段main()代码叫做main1
A a;
B b;
a.print();
b.print();
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
通过class A和class B的print()这个接口，可以看出这两个class因个体的差异而采用了不同的策略，输出的结果也是我们预料中的，分别是This is A和This is B。但这是否真正做到了多态性呢？No，多态还有个关键之处就是一切用指向基类的指针或引用来操作对象。那现在就把main()处的代码改一改。

int main(){   //main2
A a;
B b;
A* p1=&a;
A* p2=&b;

p1->print();
p2->print();
}
1
2
3
4
5
6
7
8
9
运行一下看看结果，哟呵，蓦然回首，结果却是两个This is A。问题来了，p2明明指向的是class B的对象但却是调用的class A的print()函数，这不是我们所期望的结果，那么解决这个问题就需要用到虚函数

class A{
public:
virtual void print(){ cout<<”This is A”<<endl;}  //现在成了虚函数了
};

class B:public A{
public:
void print(){ cout<<”This is B”<<endl;}  //这里需要在前面加上关键字virtual吗？
};
1
2
3
4
5
6
7
8
9
毫无疑问，class A的成员函数print()已经成了虚函数，那么class B的print()成了虚函数了吗？回答是Yes，我们只需在把基类的成员函数设为virtual，其派生类的相应的函数也会自动变为虚函数。所以，class B的print()也成了虚函数。那么对于在派生类的相应函数前是否需要用virtual关键字修饰，那就是你自己的问题了（可用可不用）。

现在重新运行main2的代码，这样输出的结果就是This is A和This is B了。

现在来消化一下，我作个简单的总结，指向基类的指针在操作它的多态类对象时，会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。‎

🐘虚函数的重要概念
首先：强调一个概念：

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
1、简介
假设我们有下面的类层次：

class A  
{  
public:  
virtual void foo()  
{  
cout<<"A::foo() is called"<<endl;  
}  
};  
class B:public A  
{  
public:  
void foo()  
{  
cout<<"B::foo() is called"<<endl;  
}  
};  
int main(void)  
{  
A *a = new B();  
a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  
return 0;  
}  
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。为实现多态性，可以通过基类的指针或引用访问派生类的成员。也就是说，声明一个基类指针，这个基类指针可以指向派生类对象。

🐧拓展：析构函数必须是虚拟的
基类中的虚拟成员希望其派生类定义自己的版本。特别是基类通常应该定义一个虚拟析构函数，即使它不起作用，析构函数必须是虚拟的，以允许动态分配和销毁继承层次结构中的对象。

那么为什么析构函数必须是虚拟的，而我们新建程序时，默认的析构函数却不是虚拟的呢？

一、为什么析构函数必须是虚拟的？

因为指针指向的是一个派生类实例，我们销毁这个实例时，肯定是希望先清理派生类自己的资源，同时又清理从基类继承过来的资源。而当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理。

总结：如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数。这样，释放基类指针指向的派生类实例时，清理工作才能全面进行，才不会发生内存泄漏。

二、为什么默认的析构函数不是虚函数？

虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。
这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。

这样一说，问题就不言而喻了。当我们创建一个类时，系统默认我们不会将该类作为基类，所以就将默认的析构函数定义成非虚函数，这样就不会占用额外的内存空间。同时，系统也相信程序开发者在定义一个基类时，会显示地将基类的析构函数定义成虚函数，此时该类才会维护虚函数表和虚表指针。

参考博文：为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？

🐒纯虚函数的含义与使用
一、定义

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

virtual void funtion1()=0;
1
二、引入原因

为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

三、纯虚函数的使用

问题：虚函数在基类中一定要实现吗？

class Location
{
public:
Location(){}
~Location(){}

public:
virtual bool Check();  // 这里一定要实现吗？
};

class LineLocation : public Location
{
public:
LineLocation(){}
~LineLocation(){}

public:
virtual bool Check() {
return 1;
}
};

int _tmain(int argc, _TCHAR* argv[])
{
Location* loc = NULL;
loc = new LineLocation();
bool b= loc->Check();
return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
基类中的纯虚函数不实现会报错：程序链接出错，error LNK2001: unresolved external symbol。。。而将基类的check()函数进行定义实现的话，程序链接是能够通过的。

回答： 虚函数在基类中一定要实现，如果基类中的虚函数不想实现，只想通过派生类来实现，需要将基类中的虚函数换成纯虚函数，需要在函数后加 = 0。因为虚函数的地址在链接的时候需要放到类的虚函数表中，所以即使你的代码里面没有调用这个函数，编译器也需要取它的地址，已经有对它的引用了，就必须要实现才行。

注：因为纯虚函数就相当于接口，无法实例化，即Location loc;编译是不能通过的。即有纯虚函数的类，将其作为参数也好，另一个类的成员变量也好，只能将其定义为指针或引用，只要不给基类实例化对象就行。

🐗抽象类的介绍
抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。

1.抽象类的定义： 称带有纯虚函数的类为抽象类。
2.抽象类的作用：
抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
3.使用抽象类时注意：
1)抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
2)抽象类是不能定义对象的。

🐎总结
1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol “public: virtual void __thiscall ClassName::virtualFunctionName(void)”
3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。
定义纯虚函数就是为了让基类不可实例化化
因为实例化这样的抽象数据结构本身并没有意义。
或者给出实现也没有意义
实际上我个人认为纯虚函数的引入，是出于两个目的
1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。
2、为了效率，不是程序执行的效率，而是为了编码的效率。

关键字const用来定义常量，如果一个变量被const修饰，那么它的值就不能再被改变，我想一定有人有这样的疑问，C语言中不是有#define吗，干嘛还要用const呢，我想事物的存在一定有它自己的道理，所以说const的存在一定有它的合理性，与预编译指令相比，const修饰符有以下的优点：

1、预编译指令只是对值进行简单的替换，不能进行类型检查

2、可以保护被修饰的东西，防止意外修改，增强程序的健壮性

3、编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

下面我们从几个方面来说一下const的用法：

一、修饰局部变量

const int n=5;
int const n=5;
1
2
这两种写法是一样的，都是表示变量n的值不能被改变了，需要注意的是，用const修饰变量时，一定要给变脸初始化，否则之后就不能再进行赋值了。

接下来看看const用于修饰常量静态字符串，例如：

const char* str="fdsafdsa";
1
如果没有const的修饰，我们可能会在后面有意无意的写str[4]=’x’这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。有了const，这个错误就能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译期被发现。

二、常量指针与指针常量

常量指针是指针指向的内容是常量，可以有一下两种定义方式。

const int * n;
int const * n;
1
2
需要注意的是一下两点：

1、常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的。

int a=5;
const int* n=&a;
a=6;
1
2
3
2、常量指针指向的值不能改变，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址。

int a=5;
int b=6;
const int* n=&a;
n=&b;
1
2
3
4
指针常量是指指针本身是个常量，不能在指向其他的地址，写法如下：

int *const n;
1
需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。

int a=5;
int *p=&a;
int* const n=&a;
*p=8;
1
2
3
4
区分常量指针和指针常量的关键就在于星号的位置，我们以星号为分界线，如果const在星号的左边，则为常量指针，如果const在星号的右边则为指针常量。如果我们将星号读作‘指针’，将const读作‘常量’的话，内容正好符合。int const * n；是常量指针，int *const n；是指针常量。

指向常量的常指针

是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值。

const int* const p;
1
三、修饰函数的参数

根据常量指针与指针常量，const修饰函数的参数也是分为三种情况

1、防止修改指针指向的内容

void StringCopy(char *strDestination, const char *strSource);
1
其中 strSource 是输入参数，strDestination 是输出参数。给 strSource 加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误。

2、防止修改指针指向的地址

void swap ( int * const p1 , int * const p2 )
1
指针p1和指针p2指向的地址都不能修改。

3、以上两种的结合。

四、修饰函数的返回值

如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。
例如函数

const char * GetString(void);
1
如下语句将出现编译错误：

char *str = GetString();
1
正确的用法是

const char *str = GetString();
1
五、修饰全局变量

全局变量的作用域是整个文件，我们应该尽量避免使用全局变量，因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数，导致除了bug后很难发现，如果一定要用全局变量，我们应该尽量的使用const修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。
————————————————
版权声明：本文为CSDN博主「xingjiarong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xingjiarong/article/details/47282255