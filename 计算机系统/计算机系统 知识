## 进程间通信方式

# 管道：
无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在# 具有亲缘关系的进程 #之间使用。进程的亲缘关系通常是指父子进程关系。
有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是# 允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式 #

# 共享内存
映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的
它往往与# 信号量配合使用 #来实现进程间的同步和通信。

# 消息队列
消息队列是有# 消息的链表 #存放在内核中并由消息队列标识符标识
消息队列克服了# 信号传递信息少 # 管道只能承载无格式字节流 #以及# 缓冲区大小受限 #等缺点。

# 套接字
适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。

# 信号
用于# 通知接收进程某个事件 #已经发生，比如按下ctrl + C就是信号。

# 信号量
信号量是一个# 计数器 #可以用来控制多个进程对共享资源的访问
它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问

## 线程间通信方式
# 信号：类似进程间的信号处理
# 锁机制：互斥锁、读写锁和自旋锁
# 条件变量：使用通知的方式解锁，与互斥锁配合使用
# 信号量：包括无名线程信号量和命名线程信号量


## 系统中具有快表后，地址的转换过程

#快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来# 存放当前访问的若干页表项 #以加速地址变换的过程

# CPU给出逻辑地址，由某个硬件算得# 页号、页内偏移量 #将页号与快表中的所有页号进行比较。

# 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号
再将# 内存块号与页内偏移量拼接形成物理地址 #最后，访问该物理地址对应的内存单元
因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
快表-页号-页表-内存块号+页内偏移量-物理地址-内存单元------一次访问内存

# 如果没有找到匹配的页号，则需要访问# 内存中的页表 #找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址
访问该# 物理地址对应的内存单元 #因此,若快表未命中，则访问某个逻辑地址需要两次访存
内存-页表-内存块号-页内偏移量-物理地址-内存单元-----两次访存内存
(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)
逻辑地址转换物理地址
逻辑地址-计算页号，页内偏移量-判断页号是否越界-查询内存中的页表，找到页号对应页表，确定页面-得到内存块号和页内偏移量得到物理地址-访问目标内存单元

# 动态分区分配算法有哪几种？可以分别说说吗？
# 首次适应算法
算法思想：每次都从# 低地址开始查找，找到第一个能满足大小的空闲分区 # 
如何实现：空闲分区以# 地址递增的顺序 #每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区

# 最佳适应算法
算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域
因此为了保证当"大进程"到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
如何实现:空闲分区按# 容量递增顺序排列 #每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区
缺点：每次使用最小分区分配，会留下越来越多难以利用的小内存块，产生很多外部碎片；

# 最坏适应算法
又称最大适应算法(Largest Fit)

算法思想:为了解决最佳适应算法的问题
即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
如何实现:空闲分区按# 按容量递减顺序排列 #每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区
缺点：导致较大连续空闲区被迅速用完，之后有大进程到来，没有内存可以使用

# 邻近适应算法           
算法思想：首次适应算法每次都从链头开始查找的
这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销
如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
缺点：无论高低地址，空闲分区都有相同的概率被使用，导致高地址部分的大分区可能被使用，最后导致无大分区可以用；

## 虚拟技术你了解吗？

# 虚拟技术把一个物理实体转换为多个逻辑实体。
主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
# 多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
# 虚拟内存使用了空分复用技术，它将# 物理内存抽象为地址空间，每个进程都有各自的地址空间 #
地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 虚拟内存的目的

虚拟内存的目的是为了让# 物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存 #
为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。
这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中
当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将# 缺失的部分装入物理内存并重新执行失败的指令 # 

## 逻辑地址VS物理地址

编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)

CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可

相对地址又称逻辑地址，绝对地址又称物理地址。



从上面的描述中可以看出# 虚拟内存允许程序不用将地址空间中的每一页都映射到物理内 #
也就是说# 一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能 # 



## 进程状态的切换你知道多少？
就绪状态（ready）：等待被调度
运行状态（running）
阻塞状态（waiting）：等待资源
就绪--获得时间片->运行--时间片用完->就绪
                   |
                   缺
                   少
                   资
                   源
                   |
                   阻塞--获得资源->就绪

# 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；
而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。


## 进程同步的四种方法

# 临界区
对临界资源进行访问的那段代码称为临界区。
为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

# 同步与互斥
同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
互斥：多个进程在同一时刻只有一个进程能进入临界区。

# 信号量
信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。
down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。
# 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

# 管程
使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。
管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。
管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作
对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。
在利用管程实现进程同步时，当某进程通过管程请求获得临界资源而未能满足时，管程便调用wait原语使该进程等待，并将其排在等待队列上。
仅当另一个进程访问完成并释放该资源后，管程才又调用signal原语，唤醒等待队列中的队首进程。
但是，考虑这样一种情况：当一个进程调用了管程后，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除；
在此期间，如果该进程不释放管程，则其它进程就无法进入管程，被迫长时间等待。
为了解决这个问题，引入条件变量condition。通常，一个进程被被阻塞或挂起的条件（原因）可有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。

## 介绍一下几种典型的锁

# 读写锁
多个读者可以同时进行读
写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

# 互斥锁
一次只能一个线程拥有互斥锁，其他线程只有等待
互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度
为了实现# 锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换 #
互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间
当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁

# 条件变量
互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定
而# 条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件 #
当# 条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化 #
一旦其他的某个线程改变了条件变量，他将通知# 相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程 #
总的来说# 互斥锁是线程间互斥的机制，条件变量则是同步机制 #

# 自旋锁
如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止
如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

## 内存的覆盖是什么？有什么特点？
# 由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序） # 
# 因此可以把用户空间分成为一个固定区和若干个覆盖区 # 
# 将经常活跃的部分放在固定区 #
# 其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中 #
在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。

覆盖技术的特点：是打破了必须将# 一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行 #
再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。

## 内存交换是什么？有什么特点？
交换(对换)技术的设计思想：# 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度) #
# 换入：把准备好竞争CPU运行的程序从辅存移到内存
# 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。

## 什么时候会进行内存的交换？
内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停
例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。

## 在执行malloc申请内存的时候，操作系统是怎么做的？
从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap
# brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以# 扩大进程在运行时的堆大小 #
# mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以# 获得一块可以操作的堆内存 #
# 分配的内存小于128k时，使用brk调用来获得虚拟内存 #
# 大于128k时就使用mmap来获得虚拟内存 #
进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址
在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成



