## 进程间通信方式

# 管道：
无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在# 具有亲缘关系的进程 #之间使用。进程的亲缘关系通常是指父子进程关系。
有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是# 允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式 #

# 共享内存
映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的
它往往与# 信号量配合使用 #来实现进程间的同步和通信。

# 消息队列
消息队列是有# 消息的链表 #存放在内核中并由消息队列标识符标识
消息队列克服了# 信号传递信息少 # 管道只能承载无格式字节流 #以及# 缓冲区大小受限 #等缺点。

# 套接字
适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。

# 信号
用于# 通知接收进程某个事件 #已经发生，比如按下ctrl + C就是信号。

# 信号量
信号量是一个# 计数器 #可以用来控制多个进程对共享资源的访问
它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问


## 系统中具有快表后，地址的转换过程
# CPU给出逻辑地址，由某个硬件算得# 页号、页内偏移量 #将页号与快表中的所有页号进行比较。

# 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号
再将# 内存块号与页内偏移量拼接形成物理地址 #最后，访问该物理地址对应的内存单元
因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
快表-页号-页表-内存块号+页内偏移量-物理地址-内存单元------一次访问内存

# 如果没有找到匹配的页号，则需要访问# 内存中的页表 #找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址
访问该# 物理地址对应的内存单元 #因此,若快表未命中，则访问某个逻辑地址需要两次访存
内存-页表-内存块号-页内偏移量-物理地址-内存单元-----两次访存内存
(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)


# 动态分区分配算法有哪几种？可以分别说说吗？
# 首次适应算法
算法思想：每次都从# 低地址开始查找，找到第一个能满足大小的空闲分区 # 
如何实现：空闲分区以# 地址递增的顺序 #每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区

# 最佳适应算法
算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域
因此为了保证当"大进程"到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
如何实现:空闲分区按# 容量递增顺序排列 #每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区
缺点：每次使用最小分区分配，会留下越来越多难以利用的小内存块，产生很多外部碎片；

# 最坏适应算法
又称最大适应算法(Largest Fit)

算法思想:为了解决最佳适应算法的问题
即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
如何实现:空闲分区按# 按容量递减顺序排列 #每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区
缺点：导致较大连续空闲区被迅速用完，之后有大进程到来，没有内存可以使用

# 邻近适应算法           
算法思想：首次适应算法每次都从链头开始查找的
这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销
如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
缺点：无论高低地址，空闲分区都有相同的概率被使用，导致高地址部分的大分区可能被使用，最后导致无大分区可以用；


