链接：https://www.nowcoder.com/discuss/1013380
来源：牛客网

首页 > 23滴滴提前批---C++开发面经


robryz
编辑于 08-18 13:53+ 关注
23滴滴提前批---C++开发面经


robryz
编辑于 08-18 13:53+ 关注
8.11一天三面
一面没问项目，八股，手撕
new和malloc的区别，delete析构是谁做的，如果不调用delete会怎么样
举个例子说明在什么情况下内存会彻底丢掉无法找回
一直申请内存导致不够用会怎么样，OOM会选择哪些进程删除
malloc出来的内存一定在物理内存上分配了吗
介绍一下分页机制，缺页中断，虚拟内存和物理地址的关系
C++代码如何变成二进制文件的，动静态链接的优缺点
两个二进制文件都运行同一个库文件应该怎么做
输入URL解析的过程，四次挥手的过程
TCP连接建立后把网线拔了会怎么样，客户端会发生什么
在山区里信号很差用手机上网，没有彻底断开会发生什么，什么时候会发生重传（太难了已经崩溃了
CPU缓存机制是怎么做的，L1、2、3缓存
介绍虚函数、纯虚函数
手撕：给一个等差数列，其中有一项缺失，找出这一项
二面还是八股，手撕
C++独有特性，和C的区别，描述面向对象，虚函数怎么实现，为什么需要虚函数，虚基类有接触吗
纯虚函数和虚函数区别，有一个大规模项目需要合作，纯虚函数有什么好处
函数指针和指向指针的指针是什么，有什么用
有哪些设计模式，单例模式是为了解决什么问题，解释一下工厂和抽象工厂
学过的数据结构有什么用，堆栈用处大吗，树是干什么用的，为什么要用红黑树不用其他树
为什么数据库用b+树不用红黑树（引导我半天也没想出来。。
你来设计苹果iCloud共享图片是怎么做
平时写代码用什么东西管理
手撕：反转链表



1、介绍一下c++的多态
2、运行时多态与编译时多态的区别？

* c++的静态多态是怎么做到的？为什么函数名相同却可以调到不同的实现呢？

* C++ 是如何做到函数重载的？
  -C++代码在编译时会根据参数列表对函数进行重命名，例如 void Swap(int a, int b) 会被重命名为 _Swap_int_int ， void Swap(float x, float y) 会被重命名为 _
  Swap_float_float 。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做 重载决议（ Overload Resolution ） 。
  -不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。
  -从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

* 函数返回值类型不同也能实现重载吗？
  和返回值类型无关

* 空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

* 类内部的成员变量：
  普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
  static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
* 类内部的成员函数：
  普通函数：不占用内存。
  虚函数：要占用4个字节（32位系统）或8个字节（64位系统），用来指定虚函数的虚拟函数表的入口地址。
  所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。
* C++编译系统中，数据和函数是分开存放的(函数放在代码区；数据主要放在栈区和堆区，静态/全局区以及文字常量区也有)，
  实例化不同对象时，只给数据分配空间，各个对象调用函数时都都跳转到(内联函数例外)找到函数在代码区的入口执行，可以节省拷贝多份代码的空间
  类的静态成员变量编译时被分配到静态/全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间。
  内联函数(声明和定义都要加inline)也是存放在代码区，内联函数在被调用时，编译器会用内联函数的代码替换掉函数，避免了函数跳转和保护现场的开销。不要将成员函数的这种存储方式和inline(内联)函数的概念混淆。不要误以为用inline声明(或默认为inline)的成员函数，其代码段占用对象的存储空间，而不用inline声明的成员函数，其代码段不占用对象的存储空间。不论是否用inline声明(或默认为inline)，成员函数的代码段都不占用对象的存储空间。用inline声明的作用是在调用该函数时，将函数的代码段复制插人到函数调用点，而若不用inline声明，在调用该函数时，流程转去函数代码段的入口地址，在执行完该函数代码段后，流程返回函数调用点。inline与成员函数是否占用对象的存储空间无关

同一个类创建的多个对象，其数据成员是各用各的，互不相通（静态成员变量是共享的）。
成员函数是共享共用的，多个对象共用一份代码，所有类成员函数和非成员函数代码存放在代码区。
不论成员函数在类内定义还是在类外定义，成员函数的代码段都用同一种方式存储。

* 两个一模一样的函数，一个使用const修饰，一个不使用const修饰，这两个函数可以进行重载吗？

* const修饰函数起到了什么作用？哪些变量不能修

* const除了修饰函数，还可以修饰什么？

* 顶层const和底层const的区别

* 指针和引用有什么区别？

* 对同一个变量的指针和引用进行sizeof操作，会有什么区别吗？

* 指针为什么会是4个字节，一定是4个字节吗？对指针做sizeof的结果与什么相关？
* 子类的大小是本身成员变量的大小加上父类的大小

* 在32位系统分配指针大小为4字节

* 继续回到动态多态，构造函数可以是virtual吗？为什么不可以是virtual？
-必要性分析：
  当定义派生类对象时，它会主动依次调用构造函数，顺序为基类的构造函数->一级派生类构造函数->二级派生类构造函数….直到当前派生类的构造函数调用完毕为止，到此派生类对象生成。
  而虚函数存在的意义为动态绑定，从上一段话可知，它会从基类开始依次自动调用相应的构造函数，根本就不存在动态绑定的必要。
-内存角度分析：
  构造函数的作用是生成相应的类对象。虚函数的动态绑定是依据一张虚函数表来确认的最终绑定到哪一个虚函数版本。
  而调用构造函数之前，我们对类对象所做的操作仅限于分配内存，还没有对内存进行初始化。此时，内存空间上也不存在虚函数表，
  因此，按照这样的执行顺序，虚函数的动态绑定是实现不了的

```c++
#include <iostream>
using namespace std;

class Father
{
  public:
    Father(){
        cout<<"contructor Father!"<<endl;
    }
    ~Father(){
        cout<<"destructor Father!"<<endl;
    }
};

class Son:public Father
{
  public:
    Son(){
        cout<<"contructor Son!"<<endl;
    }
    ~Son(){
        cout<<"destructor Son!"<<endl;
    }
};

int main()
{
    Father *pfather=new Son;
    delete pfather;
    pfather=NULL;
    return 0;
}
/*输出结果为：
contructor Father!
contructor Son!
destructor Father!
*/
```

13、虚表指针是什么时候初始化的？

*
* 不考虑使用场景，除了构造函数，给所有函数都声明为virtual的，可以这样做吗？或者推荐这么做吗？有什么负面影响吗？

- 虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。
  这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，
  我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。
  这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。
-

* 介绍一下static关键字都有什么作用？都可以修饰什么？分别起到什么作用呢？function实现里面对一个局部变量定义static可以吗？
* c++单例模式，都有哪些实现？预加载和延迟加载各自都有什么问题？都存在安全问题吗？
* 预先加载有什么缺点吗？
* 有两个使用预先加载的单例类，一个类A一个类B，类B的初始化依赖于类A的初始化完成，使用预先加载的方式可以保证能够完成吗？类A类B在两个不同的文件里面（c++对不同文件（编译单元）里面定义的static变量初始化的顺序有保证吗？）不能够做到的话，这种情况知道怎么解决吗？
* 在一个函数内部定义一个static变量，不对其进行加锁，有线程安全的保证吗？c++11以前没有，c++11以后有了，通过c++11语言标准进行保证的。
* c++11里面用到了哪些东西？
* 引用坍缩的概念有了解吗？（指的就是forward解决的问题，右值引用变成左值的情况）
* 智能指针用过哪些？
* unique_ptr有哪些特性？
24、shared_ptr有哪些特性？
25、shared_ptr保证线程安全吗？为什么不是线程安全的？

* vector的扩容过程？
-- 当向vector中插入元素时，如果元素有效个数size与空间容量capacity相等时，vector内部会触发扩容机制：

* 有什么方法能够避免vector的动态扩容过程呢？
-- 如果要避免扩容而导致程序效率过低问题，其实非常简单：如果在插入之前，可以预估vector存储元素的个数，提前将底层容量开辟好即可
-- 如果插入之前进行reserve，只要空间给足，则插入时不会扩容，如果没有reserve，则会边插入边扩容，效率极其低下。

* 虚基类的作用 --菱形继承

* 移动构造函数的优点
--移动构造函数是c++11的新特性，移动构造函数传入的参数是一个右值 用&&标出。
--首先讲讲拷贝构造函数：拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间

* 而移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。
```c++
    Str(const Str &s) {
      cout<<"拷贝构造函数..."<<endl;
      str = NULL;
      int len = strlen(s.str);
      str = (char *)malloc(len + 1);
      memset(str,0,len + 1);
      strcpy(str,s.str);
    }
    demo(const demo &d):num(new int(*d.num)) {
      cout<<"copy construct!"<<endl;
    }
    Str(Str &&s) {
      cout<<"移动构造函数..."<<endl;
      str = NULL;
      str = s.str;
      s.str = NULL;
    }
    //添加移动构造函数
    demo(demo &&d):num(d.num) {
      d.num = NULL;
      cout<<"move construct!"<<endl;
    }
    A(A&x) {
      this->num = new int(*x.num);
      cout << "拷贝构造函数" << endl;
    }
    A(A&&x) {
      this->num = x.num;
      x.num = nullptr;
      cout << "移动构造函数" << endl;
    }
     
```
* 线程安全的单例模式
-
* 从C++源文件到可执行程序有几步


第二部分：操作系统
1、进程和线程有什么区别？
2、哪些资源是线程独占的？
3、线程死循环会导致所在进程（单线程进程和多线程进程）出现什么问题，有什么影响？出现假死现象（一定会出现假死吗？）
CPU会飙升吗？
4、线程崩溃会导致进程崩溃吗？一定会导致进程崩溃吗？
5、线程崩溃之后会使用什么方式通知进程呢？

* fork()之前创建的socket，父子进程能否同时读/写此socket？
  fork()创建的socket，父子进程可以同时读/写此socket，父子进程会轮流获得socket读/写权，这点好像和1）冲突，需要详细研究内因。

第三部分：计算机网络

* TCP、UDP可以绑定相同的端口吗？
  -TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP
  -所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。
  -因此，TCP/UDP 各自的端口号也相互独立，互不影响。

* 多个TCP进程可以绑定同一个端口吗？
  如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。
  如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。

* 什么情况下，可以重新利用这个端口？

* 如何解决服务端重启时，报错“Address already in use”的问题？
  当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。
  当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行
  bind() 函数的时候，就会返回了 Address already in use 的错误。
  要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。
  这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。

* 如果没有开启 net.ipv4.tcp_tw_reuse 内核参数，那么内核就会选择下一个端口，然后继续判断，直到找到一个没有被相同四元组的连接使用的端口
* 如果端口资源耗尽还是没找到，那么 connect 函数就会返回错误。
  如果开启了 net.ipv4.tcp_tw_reuse 内核参数，就会判断该四元组的连接状态是否处于 TIME_WAIT 状态，如果连接处于 TIME_WAIT 状态并且该状态持续的时间超过了 1 秒，
* 那么就会重用该连接，于是就可以使用 2222 端口了，这时 connect 就会返回成功。
  再次提醒一次**，开启了 net.ipv4.tcp_tw_reuse 内核参数，是客户端（连接发起方） 在调用 connect() 函数时才起作用**，所以在服务端开启这个参数是没有效果的。

* 客户端的端口可以重复使用吗？
  -在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。
  -TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。
  -所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP
  连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。

* 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？
  -要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。
  -如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT
  状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。

* 如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？
  -打开 net.ipv4.tcp_tw_reuse 这个内核参数。
  -因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。
  -如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

* 介绍一下time_wait是一个什么状态，为什么需要这个状态，有什么作用？

* time_wait状态会带来什么副作用吗？
--如果客户端（发起连接方）的 TIME_WAIT 状态过多，占满了所有端口资源
--那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。

* 但是 TIME_WAIT 状态也不是摆设作用，它的作用有两个：
--防止具有相同四元组的旧数据包被收到，也就是防止历史连接中的数据，被后面的连接接受，否则就会导致后面的连接收到一个无效的数据，
--保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭;

* Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：
* net.ipv4.tcp_tw_reuse
--如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，如果内核选择到的端口，已经被相同四元组的连接占用的时候 
--就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。
--所以该选项只适用于连接发起方。
* net.ipv4.tcp_tw_recycle
--如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；
--要使得这两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps=1（默认即为 1)）。
* 同步IO和异步IO介绍一下？

* PAWS
--PAWS 就是为了避免这个问题而产生的，在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，
--PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，
--如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。

* 那什么是 per-host 的 PAWS 机制呢？

per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查。

但是如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。

Per-host PAWS 机制利用TCP option里的 timestamp 字段的增长来判断串扰数据，而 timestamp 是根据客户端各自的 CPU tick 得出的值。

当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后
客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，
所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，
那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。

因此，tcp_tw_recycle 在使用了 NAT 的网络下是存在问题的，
如果它是对 TCP 四元组做 PAWS 检查，而不是对「相同的 IP 做 PAWS 检查」，那么就不会存在这个问题了。

tcp_tw_recycle 在 Linux 4.12 版本后，直接取消了这一参数。

#### accpet 队列满了
在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

半连接队列，也称 SYN 队列；
全连接队列，也称 accepet 队列；
服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列
并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除
然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。
#### 半连接队列满了
当服务器造成syn攻击，就有可能导致 TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃。

但是，如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。

syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。

syncookies 参数主要有以下三个值：

0 值，表示关闭该功能；
1 值，表示仅当 SYN 半连接队列放不下时，再启用它；
2 值，表示无条件开启功能；
那么在应对 SYN 攻击时，只需要设置为 1 即可：


#### 这里给出几种防御 SYN 攻击的方法：

* 增大半连接队列；
* 开启 tcp_syncookies 功能
* 减少 SYN+ACK 重传次数
方式一：增大半连接队列

要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列。否则，只单纯增大 tcp_max_syn_backlog 是无效的。
增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：
增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：
最后，改变了如上这些参数后，要重启 Nginx 服务，因为半连接队列和全连接队列都是在 listen() 初始化的。

方式二：开启 tcp_syncookies 功能

开启 tcp_syncookies 功能的方式也很简单，修改 Linux 内核参数：

方式三：减少 SYN+ACK 重传次数

当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。

那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。


#### 全连接队列满了
在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了 
这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。


我们可以通过 ss 命令来看 accpet 队列大小，在「LISTEN 状态」时，Recv-Q/Send-Q 表示的含义如下：


Recv-Q：当前 accpet 队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接个数；
Send-Q：当前 accpet 最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务进程，accpet 队列的最大长度为 128；
如果 Recv-Q 的大小超过 Send-Q，就说明发生了 accpet 队列满的情况。

要解决这个问题，我们可以：

调大 accpet 队列的最大长度，调大的方式是通过调大 backlog 以及 somaxconn 参数。
检查系统或者代码为什么调用 accept() 不及时；





做题：
LeetCode：剑指offerⅡ76
LeetCode：剑指offer 35
