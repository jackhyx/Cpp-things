

#### C++ 是如何做到函数重载的？
* C++代码在编译时会根据参数列表对函数进行重命名。
例如 void Swap(int a, int b) 会被重命名为 _Swap_int_int ， void Swap(float x, float y) 会被重命名为 _
Swap_float_float 
* 当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议
不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。
* 函数重载本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

#### 不考虑使用场景，除了构造函数，给所有函数都声明为virtual的，可以这样做吗？或者推荐这么做吗？有什么负面影响吗？
* 虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。
* 虚函数的代价：包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，
  我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。
* 就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。

#### shared_ptr保证线程安全吗？为什么不是线程安全的？
* 智能指针shared_ptr本身（底层实现原理是引用计数）是线程安全的
智能指针的引用计数在手段上使用了atomic原子操作，只要shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了
* 原子操作是线程安全的，所有智能指针在多线程下引用计数也是安全的，智能指针在多线程下传递使用时引用计数是不会有线程安全问题的。
* 但是智能指针指向的对象的线程安全问题，智能指针没有做任何保障

* 对于智能指针shared_ptr的引用计数本身是安全且无锁的，但对象的读写则不是
* 因为 shared_ptr 有两个数据成员，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象
* 当智能指针发生拷贝的时候，标准库的实现是先拷贝智能指针，再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子操作
* 隐患就出现在这里。两个线程中智能指针的引用计数同时++或--，这个操作不是原子的，假设引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了，违背了原子性。


#### 移动构造函数的优点
* 移动构造函数是c++11的新特性，移动构造函数传入的参数是一个右值 用&&标出。
* 拷贝构造函数：拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间
* 移动构造函数就是为了解决这个拷贝开销而产生的。
* 移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。

#### 将虚函数声明为inline，要分情况讨论
* 有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，
* 如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联
* 当用对象调用虚函数（此时不具有多态性）时，就内联展开
* 当是指向派生类的指针（多态性）调用声明为内联的虚函数时，不会内联展开；
当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

#### 模板是什么，你知道底层怎么实现的？
* 编译器并不是把函数模板处理成能够处理任意类的函数
* 编译器从函数模板通过具体类型产生不同的函数；
* 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件
* 如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

#### 基类析构函数声明为虚函数是为了防止内存泄漏。
* 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
* 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
* 那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
  所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。


#### 什么是虚拟继承
由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：

* 虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。
* 虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格
* 表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。

####  构造函数的几种关键字

* default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错
* delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示
* = 0 将虚函数定义为纯虚函数，纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处
当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。


#### 多继承的优缺点，作为一个开发者怎么看待多继承
* C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
* 多重继承的优点:使对象可以调用多个基类中的接口；
* 问题：如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个基类类的接口方法，就会容易出现二义性
--因此，需要加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
--或者使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

#### 静态函数能定义为虚函数吗？常函数呢？说说你的理解
* 静态函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
* 虚函数的调用关系：this -> vptr -> vtable ->virtual function
* 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，
* 因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。


####  虚函数和纯虚函数区别？
* 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
* 纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。
* 既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，
* 因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

* 一个类中如果有纯虚函数的话，称其为抽象类。
* 抽象类不能用于实例化对象，否则会报错
* 抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象

### 你知道空类的大小是多少吗？
C++空类的大小不为0，不同编译器设置不一样，vs设置为1；
C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。

#### C++从代码到可执行程序经历了什么？
### 预编译：
* 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：
* 删除所有的#define，展开所有的宏定义。
* 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
* 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
* 删除所有的注释，“//”和“/**/”。
* 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。
* 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。

### 编译
* 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。
* 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。
* 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。
* 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。
* 优化：源代码级别的一个优化过程。
* 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。
* 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。

* 汇编
* 将汇编代码转变成机器可以执行的指令(机器码文件)。
* 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，
* 汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。

* 链接
* 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：
#### 静态链接
* 函数和数据被编译进一个二进制文件。
* 在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
* 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

##### 动态链接
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序
而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

#### 友元函数和友元类的基本情况
* 友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。
* 通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。
* 友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。
### 友元函数
* 友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。
### 友元类
* 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
* 但是另一个类里面也要相应的进行声明
### 使用友元类时注意：
* 友元关系不能被继承。
* 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
* 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明


#### #### volatile关键字的作用？
* volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。
* 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
声明时语法：int volatile vInt
* 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
而且读取的数据立刻被保存。
volatile用在如下的几个地方：

中断服务程序中修改的供其它程序检测的变量需要加volatile；
多任务环境下各任务间共享的标志应该加volatile；
存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

#### strcpy函数和strncpy函数的区别？哪个函数更安全？
函数原型
char* strcpy(char* strDest, const char* strSrc)
char *strncpy(char *dest, const char *src, size_t n)
strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。

strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。

如果目标长>指定长>源长，则将源长全部拷贝到目标长，自动加上’\0’
如果指定长<源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’
如果指定长>目标长，运行时错误 ；


#### C++中有几种类型的new
* plain new
* plain new在空间分配失败的情况下，抛出异常std::bad_alloc而不是返回nullptr，因此通过判断返回值是否为nullptr是徒劳的
* nothrow new
* nothrow new在空间分配失败的情况下是不抛出异常，而是返回nullptr
* placement new
在一块已经分配成功的内存上重新构造对象或对象数组。
placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数
使用placement new需要注意两点：

palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，
这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

#### 迭代器失效的几种情况
* 插入元素：
  尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
  中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。
* 删除元素：
  尾后删除：只有尾迭代失效。
  中间删除：删除位置之后所有迭代失效。
  deque 和 vector 的情况类似,
  而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;
  map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);
  unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.
