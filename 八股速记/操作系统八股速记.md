### 同步异步 vs 阻塞非阻塞
* 同步：调用发出后，等待结果返回
* 异步：调用发出后，可以做别的，等待处理完通知（回调通知获取结果
* 阻塞：调用结果返回前，挂起线程
* 非阻塞：调用结果返回前，不阻塞线程，每隔一段时间检测，没有就绪就做别的
  同步、异步：是否需要内核空间到用户空间的拷贝
  阻塞、非阻塞：是否需要等待所需的I/O存在

### 同步 互斥
互斥：对资源竞争，彼此不知道对方的存在，执行顺序乱序
同步：协调多个相互关联线程合作完成任务，彼此知道对方存在；执行顺序往往有序

### 用户态 内核态
用户态：CPU受限的访问内存（只能访问用户空间），不允许访问外围设备，不允许独占；
内核态：CPU可以访问任意数据，CPU可以从一个程序切换到另一个程序，占用CPU不会发生抢占 特权级0
进程的切换只能发生在内核态

### 用户态->内核态
系统调用
异常
外中断

### 中断处理过程的五个阶段：
1、中断请求阶段；
2、中断判优阶段，有硬件判优和软件判优两种方法；
3、中断响应阶段，CPU向中断源发出中断响应信号；
4、中断服务阶段；
5、中断返回阶段，返回到原程序的断点处，恢复硬件现场，继续执行原程序
### 外中断 vs 异常
外中断：CPU执行指令的外部事件（输入输出、时钟中断
异常：CPU执行指令的内部时间（地址越界溢出

### CPU中断？
定义：系统内发生了急需处理的事件，CPU转去处理相应的处理程序，处理完毕后返回中断处继续执行
作用：系统及时响应外部事件，多个外设同时工作，提高了CPU利用率；处理硬件故障

### 一个程序从开始到可执行文件？
预编译：处理#开头的内容
编译：词法分析，语法分析，语义分析 x.c->x.i
汇编：汇编指令翻译成机器码 x.i->x.o
链接：目标文件链接成可执行程序 x.o->可执行

### 静态链接 vs 动态链接

编译链接时将代码拷贝到调用处   不直接拷贝代码，需要的时候加载到内存，多个程序调用一个时共享内存
运行速度块 多个程序共享一段代码
浪费空间 更新困难  运行时加载 速度慢

### 进程 线程 协程
进程：资源分配的最小单位 私有地址空间 私有堆栈 上下文切换需要切换虚拟地址空间
线程：资源调度的基本单位 共有地址空间 公有堆 私有栈 上下文切换只需要切换少量寄存器
协程：用户态轻量线程 上下文切换有开发者决定

### 为什么有？
进程：提升CPU利用率
线程：进程上下文切换开销大 切换虚拟地址空间 切换内核栈和硬件上下文 导致TLB失效 
线程共享资源节省空间（ 共享堆 地址空间 全局变量 静态变量； 私有栈，寄存器，程序计数器）
协程：**线程是抢占式任务**，有操作系统控制，不知道什么时候被抢走，需要加锁；
协程是异步机制，需要代码编写者主动让出控制权，不需要上下文切换

### 为什么虚拟地址切换耗时（为什么线程比进程切换块
把虚拟地址映射成物理地址需要页表，页表查找慢，用TLB缓存地址映射加速
每个进程有自己的虚拟空间，进程有自己的页表，切换时页表也发生切换TLB失效，缓存命中率底，查找慢，程序运行慢

### 进程状态切换？
就绪->运行：调度算法选择
运行->就绪：时间片用完
运行->阻塞：发生等待时间进入阻塞
阻塞->就绪：等待时间已经发生

### 进程切换场景：
进度调用时间片被耗尽，系统挂起
系统资源不足，等满足后再运行
睡眠函数主动挂起
更高优先级的进程需要运行
硬件中断，当前进程挂起

### 进程间通信
匿名管道：内核中的一段缓存，单向，半双工 父子关系进程 效率底，容量有限
有名管道：半双工 不相关的进程也可以相互通信
共享内存：不同进程拿出一段地址空间，映射到相同物理地址，效率最高，同时修改存在冲突
消息队列：消息链表
信号量：整型计数器，进程间互斥和同步PV操作 原子操作
信号：通知某个事件已经发生，异步通信 SIGCLD 子进程退出SIGKILL用户终止进程
套接字：不同主机进程间通信

### 进程内存布局
地址高--->低
栈
文件映射区
堆
bss段未初始化的全局变量
数据段 初始化的全局变量、静态变量
代码段：常量，二进制代码

### 有了进程，为什么还需要线程
进程切换开销大，线程切换仅需要保存和设置少量寄存器内容
适合高并发
节省空间：线程共享地址空间和堆等资源 无需拷贝
节省事件：进程切换需要切换虚拟内存，使TLB失效，

### 线程通信
共享内存、消息传递、管道流

### 线程崩溃会怎么样？
线程崩溃触发segment fault 触发信号SIGSEGV
不屏蔽信号，所有线程崩溃
屏蔽信号，线程私有栈，崩溃位置是栈，屏蔽后不影响其他线程
线程共有堆、全局变量，崩溃位置是堆、全局变量，屏蔽后崩溃影响其他线程

### 为什么有协程？
现有协程->进程->线程
线程：抢占式任务，操作系统控制，不知道什么时候被抢走，要加锁，同步
协程：代码编写者主动让出控制全，无需操作系统内核上下文切换，用户态，不加锁，异步

### 孤儿进程 僵尸进程 守护进程
原因：子进程 有父进程创建，但是父子进程退出是无序的

孤儿进程：父进程先退出，子进程托孤给init进程
僵尸进程：子进程已经终止，父进程还没有通过waitwaitpid获取状态，子进程残留状态信息
避免：fork()两次
调用wait waitpid获取子进程退出状态
捕获sigchld信号在捕获程序中调用wait waitpid
守护进程：运行在后台，不和任何终端关联，周期性执行某些任务，系统启动时就运行

### 什么时候多线程？什么时候多进程？ 进程线程场景
需要频繁创建和销毁：多线程
需要数据共享：多线程
cpu、计算密集型：多进程 IO密集型：多线程
弱相关：多进程 强相关：多线程
多机分布：多进程 多核分区：多线程
nginx chrome多进程

### 死锁
原因：资源分配不当，系统资源不足；程序推进的顺序不合适
必要条件：互斥：一段时间某资源仅为一个进程占有
请求和保持：已获取的资源保持不放
不抢占：获得之后不能被抢占
环路等待：资源获取存在环形链

### 分段？分页：
定义： 提高内存利用率，每个段连续分配，段和段之间离散分配   把内存分成大小相等且固定的块
信息的逻辑单位，根据用户需要划分   信息的物理单位，为了管理主存方便划分
大小不固定 可以动态改变  大小固定系统决定
地址空间:向用户提供二维地址空间  （段名 + 段地址  向用户提供一维地址空间
作用：分段能反应程序的逻辑结构 便于段的共享和保护  提高内存利用率，实现虚拟内存，获得更大的地址空间




















### 虚拟内存的作用
虚拟内存使得进程运行内存超过物理内存大小
程序运行符合局部性原理，CPU访问内存会有明显的重复访问的倾向，对于没有经常访问的内存，我们可以换出到磁盘

每个进程有自己的页表，每个进程的虚拟内存空间是相互独立的，进程没有办法访问其他进程的页表->解决了多进程之间地址冲突的问题

页表的页表项除了物理地址，还有标记位，控制页的读写权限，内存访问方面，提供了更好的安全性

### 进程调度算法
* 先来先服务 对长作业有利 适合CPU繁忙型， 不适合IO繁忙型

* 最短作业有先 对长作业不利 提高系统吞吐量

* 高响应比有限  （等待时间 + 要求服务时间 ） / 要求服务时间

* 时间片轮转每个进程分配一个时间片 20-50ms

* 最高优先级调度算法
从就绪队列选择最高优先级进程

* 多级反馈队列 优先级越高，时间片越少

### 页面置换算法 缺页异常，需要调入新页面而内存已满，选择被置换的物理页面
选择一个物理页面换出磁盘，把需要访问的页面换入到物理页

* 最佳页面置换算法
置换未来最长时间不访问：衡量算法效率

* 先进先出 选择在内存中驻留时间最长的

* 最近最久未使用LRU： 选择最长时间没有被访问：维护一个所有页面的链表

* 时钟页面置换算法
所有页面保存在类似钟面的环形链表中一个表针指向最老的页面
缺页中断时，先检查表针页面
访问位为0淘汰，插入新页面，前移
访问位位1置为0 前移找到0

* 最不常用 选择访问频率最少的 维护一个计数器

### 磁盘调度算法
先来先服务
最短寻道优先
扫描算法
循环扫描算法
LOOK / C-LOOK

### 键盘敲入字母时，期间发生了什么
当用户输入键盘字符，键盘控制器产生扫描码数据——>缓冲在键盘控制器的寄存器中
键盘控制器通过总线给CPU发送中断请求

CPU收到中断请求后，操作系统保存被中断进程的CPU上下文，然后调用键盘的中断处理程序

中断处理程序在键盘驱动程序初始化时注册，功能：从键盘控制器寄存器的缓冲区读取扫描码，根据扫描码找到对应字符，
翻译成对应ASCII码

得到ASCII码，放到读缓冲队列
显示设备定时从读缓冲队列读取数据到写缓冲队列

最后把写缓冲队列的数据写入显示设备控制器的寄存器的数据缓冲区，最后显示在屏幕

恢复被中断进程的上下文

