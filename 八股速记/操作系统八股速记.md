### 同步异步 vs 阻塞非阻塞
* 同步：调用发出后，等待结果返回
* 异步：调用发出后，可以做别的，等待处理完通知（回调通知获取结果
* 阻塞：调用结果返回前，挂起线程
* 非阻塞：调用结果返回前，不阻塞线程，每隔一段时间检测，没有就绪就做别的
  同步、异步：是否需要内核空间到用户空间的拷贝
  阻塞、非阻塞：是否需要等待所需的I/O存在

### 同步 互斥
互斥：对资源竞争，彼此不知道对方的存在，执行顺序乱序
同步：协调多个相互关联线程合作完成任务，彼此知道对方存在；执行顺序往往有序

### 用户态 内核态
用户态：CPU受限的访问内存（只能访问用户空间），不允许访问外围设备，不允许独占；
内核态：CPU可以访问任意数据，CPU可以从一个程序切换到另一个程序，占用CPU不会发生抢占 特权级0
进程的切换只能发生在内核态

### 用户态->内核态
系统调用
异常
外中断

### 中断处理过程的五个阶段：
1、中断请求阶段；
2、中断判优阶段，有硬件判优和软件判优两种方法；
3、中断响应阶段，CPU向中断源发出中断响应信号；
4、中断服务阶段；
5、中断返回阶段，返回到原程序的断点处，恢复硬件现场，继续执行原程序
### 外中断 vs 异常
外中断：CPU执行指令的外部事件（输入输出、时钟中断
异常：CPU执行指令的内部时间（地址越界溢出

### CPU中断？
定义：系统内发生了急需处理的事件，CPU转去处理相应的处理程序，处理完毕后返回中断处继续执行
作用：系统及时响应外部事件，多个外设同时工作，提高了CPU利用率；处理硬件故障

### 一个程序从开始到可执行文件？
预编译：处理#开头的内容
编译：词法分析，语法分析，语义分析 x.c->x.i
汇编：汇编指令翻译成机器码 x.i->x.o
链接：目标文件链接成可执行程序 x.o->可执行

### 静态链接 vs 动态链接

编译链接时将代码拷贝到调用处   不直接拷贝代码，需要的时候加载到内存，多个程序调用一个时共享内存
运行速度块 多个程序共享一段代码
浪费空间 更新困难  运行时加载 速度慢

### 进程 线程 协程
进程：资源分配的最小单位 私有地址空间 私有堆栈 上下文切换需要切换虚拟地址空间
线程：资源调度的基本单位 共有地址空间 公有堆 私有栈 上下文切换只需要切换少量寄存器
协程：用户态轻量线程 上下文切换有开发者决定

### 为什么有？
进程：提升CPU利用率
线程：进程上下文切换开销大 切换虚拟地址空间 切换内核栈和硬件上下文 导致TLB失效 
线程共享资源节省空间（ 共享堆 地址空间 全局变量 静态变量； 私有栈，寄存器，程序计数器）
协程：**线程是抢占式任务**，有操作系统控制，不知道什么时候被抢走，需要加锁；
协程是异步机制，需要代码编写者主动让出控制权，不需要上下文切换

### 为什么虚拟地址切换耗时（为什么线程比进程切换块
把虚拟地址映射成物理地址需要页表，页表查找慢，用TLB缓存地址映射加速
每个进程有自己的虚拟空间，进程有自己的页表，切换时页表也发生切换TLB失效，缓存命中率底，查找慢，程序运行慢

### 进程状态切换？
就绪->运行：调度算法选择
运行->就绪：时间片用完
运行->阻塞：发生等待时间进入阻塞
阻塞->就绪：等待时间已经发生

### 进程切换场景：
进度调用时间片被耗尽，系统挂起
系统资源不足，等满足后再运行
睡眠函数主动挂起
更高优先级的进程需要运行
硬件中断，当前进程挂起

### 进程间通信
匿名管道：内核中的一段缓存，单向，半双工 父子关系进程 效率底，容量有限
有名管道：半双工 不相关的进程也可以相互通信
共享内存：不同进程拿出一段地址空间，映射到相同物理地址，效率最高，同时修改存在冲突
消息队列：消息链表
信号量：整型计数器，进程间互斥和同步PV操作 原子操作
信号：通知某个事件已经发生，异步通信 SIGCLD 子进程退出SIGKILL用户终止进程
套接字：不同主机进程间通信

### 进程内存布局
地址高--->低
栈
文件映射区
堆
bss段未初始化的全局变量
数据段 初始化的全局变量、静态变量
代码段：常量，二进制代码

### 有了进程，为什么还需要线程
进程切换开销大，线程切换仅需要保存和设置少量寄存器内容
适合高并发
节省空间：线程共享地址空间和堆等资源 无需拷贝
节省事件：进程切换需要切换虚拟内存，使TLB失效，

### 线程通信
共享内存、消息传递、管道流

### 线程崩溃会怎么样？
线程崩溃触发segment fault 触发信号SIGSEGV
不屏蔽信号，所有线程崩溃
屏蔽信号，线程私有栈，崩溃位置是栈，屏蔽后不影响其他线程
线程共有堆、全局变量，崩溃位置是堆、全局变量，屏蔽后崩溃影响其他线程

### 为什么有协程？
现有协程->进程->线程
线程：抢占式任务，操作系统控制，不知道什么时候被抢走，要加锁，同步
协程：代码编写者主动让出控制全，无需操作系统内核上下文切换，用户态，不加锁，异步

### 孤儿进程 僵尸进程 守护进程
原因：子进程 有父进程创建，但是父子进程退出是无序的

孤儿进程：父进程先退出，子进程托孤给init进程
僵尸进程：子进程已经终止，父进程还没有通过waitwaitpid获取状态，子进程残留状态信息
避免：fork()两次
调用wait waitpid获取子进程退出状态
捕获sigchld信号在捕获程序中调用wait waitpid
守护进程：运行在后台，不和任何终端关联，周期性执行某些任务，系统启动时就运行

### 什么时候多线程？什么时候多进程？ 进程线程场景
需要频繁创建和销毁：多线程
需要数据共享：多线程
cpu、计算密集型：多进程 IO密集型：多线程
弱相关：多进程 强相关：多线程
多机分布：多进程 多核分区：多线程
nginx chrome多进程

### 死锁
原因：资源分配不当，系统资源不足；程序推进的顺序不合适
必要条件：互斥：一段时间某资源仅为一个进程占有
请求和保持：已获取的资源保持不放
不抢占：获得之后不能被抢占
环路等待：资源获取存在环形链

### 分段？分页：
定义： 提高内存利用率，每个段连续分配，段和段之间离散分配   把内存分成大小相等且固定的块
信息的逻辑单位，根据用户需要划分   信息的物理单位，为了管理主存方便划分
大小不固定 可以动态改变  大小固定系统决定
地址空间:向用户提供二维地址空间  （段名 + 段地址  向用户提供一维地址空间
作用：分段能反应程序的逻辑结构 便于段的共享和保护  提高内存利用率，实现虚拟内存，获得更大的地址空间




### 内存管理
* malloc
* brk:堆 分配内存 < 128k
堆顶指针向高地址移动
* mmap：私有匿名映射 从文件映射区分配一块内存 分配内存 > 128k
* void* mmap(start, lenth, prot, flags, fd, offsize)
start:映射内存起始地址
length：多大
prot：映射区域保护方式
flags：映射区域特性
fd:映射文件描述符 匿名-1
offset 文件映射偏移量

#### malloc 申请的内存，free 释放内存会归还给操作系统吗？
malloc 通过 brk() 方式申请的内存 通过 free 释放内存后，堆内存还是存在的，并没有归还给操作系统。
如果 malloc 通过 mmap 方式申请的内存，free 释放内存后就会归归还给操作系统。

### 全部用mmap？
频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。
为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。
等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗

### 全部用brk？导致内存碎片valgrind检测不出来

### free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？
malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节
保存了该内存块的描述信息，比如有该内存块的大小。


### 内存分配的过程是怎样的？
malloc -> 虚拟内存，读写时访问虚拟内存，发现没有映射到物理内存->产生缺页中断
从用户态切换到内核态 缺页中断函数处理page fault handler
缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。
如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。
后台回收：kswapd线程，异步
直接回收：同步阻塞
OOM

### 哪些内存可以被回收？
文件页：内核缓存的磁盘数据和内核缓存的文件数据
直接释放，有需要再直接读
脏页，先写回磁盘再释放内存

匿名页：swap机制 ： 不常用的先写回磁盘，然后释放，再次访问时，从磁盘读取
LRU:维护活跃内存链表和不活跃内存链表

### 回收内存带来的性能影响
一种是后台内存回收，也就是唤醒 kswapd 内核线程，这种方式是异步回收的，不会阻塞进程。
一种是直接内存回收，这种方式是同步回收的，会阻塞进程，这样就会造成很长时间的延迟，以及系统的 CPU 利用率会升高，最终引起系统负荷飙高。
可被回收的内存类型有文件页和匿名页：
文件页的回收：对于干净页是直接释放内存，这个操作不会影响性能，而对于脏页会先写回到磁盘再释放内存，
这个操作会发生磁盘 I/O 的，这个操作是会影响系统性能的。
匿名页的回收：如果开启了 Swap 机制，那么 Swap 机制会将不常访问的匿名页换出到磁盘中，下次访问时，再从磁盘换入到内存中，这个操作是会影响系统性能的。
回收内存的操作基本都会发生磁盘 I/O 的，如果回收内存的操作很频繁，意味着磁盘 I/O 次数会很多，这个过程势必会影响系统的性能，整个系统给人的感觉就是很卡。

### 调整文件页和匿名页的回收倾向
* swappiness 越大越积极使用swap回收匿名页，越小回收文件页
* 尽早触发 kswapd 内核线程异步回收内存
* sar -B pgscand ->直接回收
* 当剩余内存页（pages_free）小于页低阈值（pages_low），就会触发 kswapd 进行后台回收
* 在 NUMA 架构下，当某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。
### OOM
* points = process_pages + oom_score_adj*totalpages/1000
用「系统总的可用页面数」乘以 「OOM 校准值 oom_score_adj」再除以 1000，
最后再加上进程已经使用的物理页面数，计算出来的值越大，那么这个进程被 OOM Kill 的几率也就越大
* 调整该进程的 oom_score_adj 


### 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？
在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
在 64位 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，
即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；

### 缓存失效 or 缓存污染导致缓存命中率下降
redis实现LFU
mysql + linux 改进LRU
LRU 算法一般是用「链表」作为数据结构来实现的，链表头部的数据是最近使用的，而链表末尾的数据是最久没被使用的
* 应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用预读机制（ReadaHead） 机制完成了 16KB 数据的读取，
* 也就是通过一次磁盘顺序读将多个 Page 数据装入 Page Cache。
这样下次读取 4KB 数据后面的数据的时候，就不用从磁盘读取了，直接在 Page Cache 即可命中数据。
* 因此，预读机制带来的好处就是减少了 磁盘 I/O 次数，提高系统磁盘 I/O 吞吐量。
MySQL Innodb 存储引擎的 Buffer Pool 也有类似的预读机制，MySQL 从磁盘加载页时，会提前把它相邻的页一并加载进来，目的是为了减少磁盘 IO
* 预读失效：提前加载的页，最后并没有被访问；
* 不被访问的预读页占用了LRU链表前排，而末尾淘汰的页可能是热点->降低缓存命中率
### Linux 是如何避免预读失效带来的影响？
维护两个链表 活跃链表和非活跃链表
预读页加入非活跃链表头，被访问时才插入活跃链表头，不会影响活跃链表的热点数据；
### MySQL 是如何避免预读失效带来的影响？
MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，young 区域 和 old 区域。
划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部

### 但是存在缓存污染：只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）
如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染
导致热点数据被替换掉，降低缓存命中率
### 避免：只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉。

Linux 操作系统：在内存页被访问第二次的时候，才将页从 inactive list 升级到 active list 里。
MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：
如果第二次的访问时间与第一次访问的时间在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域；
如果第二次的访问时间与第一次访问的时间超过 1 秒，那么该页就会从 old 区域升级到 young 区域；
提高了进入活跃 LRU 链表（或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。
在批量读取数据时候，如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 LRU 链表（或者 young 区域），也就不会把热点数据淘汰，只会待在非活跃 LRU 链表（或者 old 区域）中，后续很快也会被淘汰。

### 虚拟内存的作用
虚拟内存使得进程运行内存超过物理内存大小
程序运行符合局部性原理，CPU访问内存会有明显的重复访问的倾向，对于没有经常访问的内存，我们可以换出到磁盘

每个进程有自己的页表，每个进程的虚拟内存空间是相互独立的，进程没有办法访问其他进程的页表->解决了多进程之间地址冲突的问题

页表的页表项除了物理地址，还有标记位，控制页的读写权限，内存访问方面，提供了更好的安全性

### 进程调度算法
* 先来先服务 对长作业有利 适合CPU繁忙型， 不适合IO繁忙型

* 最短作业有先 对长作业不利 提高系统吞吐量

* 高响应比有限  （等待时间 + 要求服务时间 ） / 要求服务时间

* 时间片轮转每个进程分配一个时间片 20-50ms

* 最高优先级调度算法
从就绪队列选择最高优先级进程

* 多级反馈队列 优先级越高，时间片越少

### 页面置换算法 缺页异常，需要调入新页面而内存已满，选择被置换的物理页面
选择一个物理页面换出磁盘，把需要访问的页面换入到物理页

* 最佳页面置换算法
置换未来最长时间不访问：衡量算法效率

* 先进先出 选择在内存中驻留时间最长的

* 最近最久未使用LRU： 选择最长时间没有被访问：维护一个所有页面的链表

* 时钟页面置换算法
所有页面保存在类似钟面的环形链表中一个表针指向最老的页面
缺页中断时，先检查表针页面
访问位为0淘汰，插入新页面，前移
访问位位1置为0 前移找到0

* 最不常用 选择访问频率最少的 维护一个计数器

### 磁盘调度算法
先来先服务
最短寻道优先
扫描算法
循环扫描算法
LOOK / C-LOOK

### 键盘敲入字母时，期间发生了什么
当用户输入键盘字符，键盘控制器产生扫描码数据——>缓冲在键盘控制器的寄存器中
键盘控制器通过总线给CPU发送中断请求

CPU收到中断请求后，操作系统保存被中断进程的CPU上下文，然后调用键盘的中断处理程序

中断处理程序在键盘驱动程序初始化时注册，功能：从键盘控制器寄存器的缓冲区读取扫描码，根据扫描码找到对应字符，
翻译成对应ASCII码

得到ASCII码，放到读缓冲队列
显示设备定时从读缓冲队列读取数据到写缓冲队列

最后把写缓冲队列的数据写入显示设备控制器的寄存器的数据缓冲区，最后显示在屏幕

恢复被中断进程的上下文

