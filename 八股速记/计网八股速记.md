
OSI七层：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 理论模型

TCP/IP四层 应用层 传输层 网络层 网络接口层

五层 应用层 传输层 网络层 数据链路层 物理层

应用层： 为用户提供应用功能，不关心数据如何传输 工作在用户态 其下内核态 -- 报文

表示层： 数据格式的转换 加密解密压缩解压缩 

会话层：负责两点之间建立、维持和终止通信，例如服务器验证用户登录

传输层：为应用层提供数据传输服务 将上层数据分段并提供传输，负责流量控制等 -- 段

网络层：实际传输功能 寻址（找到IP地址对应的设备） + 路由（数据应该往哪里发送） -- 包

数据链路层：为网络层提供链路级别的服务 将网络层的包组成帧 -- 帧

物理层：为数据链路层提供二进制传输服务 传输Bit流 -- bit流



#### GET vs POST
数据传输方式 从服务器获取数据  向服务器新增、提交数据

数据长度限制 2048个字符  无限制

数据类型 ASCII字符  无限制 标准字符集

安全性 明文显示在网页上 较好

可见性 URL 不显示
可以收藏为书签 不可以
历史记录 保存 不保存
能被缓存  不可以缓存
传参方式 URL或Cookie BODY实体
安全且幂等  不安全不幂等

#### HTTP状态码
1xx 中间状态 服务器收到请求 需要请求者继续执行操作
2xx 成功接收并处理
3xx 重定向 需要进一步操作
4xx 客户端错误 请求包含语法错误或无法完成请求
5xx 服务器错误 服务器在处理请求的过程中发生了错误

101 切换请求协议 http->websocket
200 ok 服务器成功处理了请求

204 not content 同200 响应头没有Body数据

206 partital content 部分数据 与断点续传有关

301 永久重定向 需要新的url

302 临时重定向 

304 缓存重定向 协商缓存命中 告诉客户端可以继续使用缓存

400 bad request 客户端请求报文有错

401 身份过期，没有通过身份认证

403 forbidden 没有权限

404 not found 资源找不到

499 nginx 客户端已经关闭

500 笼统服务器内部错误

501 请求功能还不支持

502 bad gateway 错误网关 服务器作为网关或代理时返还

503 服务器目前无法使用 暂时状态

504 bad gateway timeout 网关超市

505 不支持Http协议版本


### HTTP缓存机制
强制缓存:命中责返回
协商缓存：和服务器进行协商 满足则返回huanc
etag:判断是否改变 精度优 性能低
last-modified最后一次改变时间

### HTTP请求完整过程
域名解析
TCP3次握手 建立TCP连接后 HTTP请求
服务器响应HTTP请求 浏览器得到Html 代码
浏览器解析 请求其中资源jc css 图片等
浏览器对页面进行渲染呈现给客户

### 长连接
HTTP 1.1默认长连接 connection: keep_alive

### http1.0问题
默认短连接
第一个请求发出去必须等待确认回来，才能发第二个请求

### HTTP1.1
优点：简单 灵活 易扩展 应用广泛 长连接
缺点：明文 头部巨大 队头阻塞 不支持服务器推送 并发连接有限

### HTTPS
优点：
混合加密 窃听
摘要算法 篡改
CA证书 冒充
缺点：技术门槛高 CA证书收费 需要更多的服务器资源

### HTTP2.0
优点：队头压缩 二进制格式 数据流 多路复用 服务器推送
缺点：TCP（队头阻塞） 连接迁移需要重新三次握手

### HTTP3.0
udp + quic

### http vs https
明文不安全  加入TLS/SSL安全协议 加密传输
三次握手 之后还需要TLS四次握手
端口 80  443
证书  CA证书

### HTTP 1.1 vs 1.0
长连接 短连接 每一次都需要三次握手 请求串行   
新增管道 可以发送多个请求  发送一个请求等待响应才能发第二个 
断点续传  range指定数据字节位置
新增HOST请求头： 虚拟主机技术
新增错误状态码

### HTTP2.0 VS 1.1

头部压缩：多个请求，头部相同，消除重复部分
二进制格式  纯文本
stream流 不用按序发送 指定优先级
多路复用 ： 在一个连接中并发多个请求或响应
实现服务器推送

### 2.0 vs 3.0

TCP对头阻塞 UDP无对头阻塞

不用四元组 两个ID标记 连接迁移不需要三次握手


### session vs token
签名验证机制替代白名单验证

session的问题：前端传来的session_id可以伪造 所以需要在服务器维护一个session_id白名单验证
token通过签名机制只要前段传来的token能通过签名认证就是合法不需要服务器维护

## 应用层DNS
DNS端口53 
区域传输是用tcp
域名解析udp

### DNS解析过程
* 浏览器中查询域名对应ip地址缓存， 硬盘Hosts文件
* 都没有发DNS给本地DNS服务器
* 本地DNS服务器查询缓存，有直接返回，没有向DNS根服务器发送请求
* 根域名告诉本地DNS可以向顶级域 本地DNS向顶级域发出请求
* 顶级域告诉本地DNS权威域 本地DNS向权威域发出请求
* 得到IP和域名关系 缓存


### TCP VS UDP
连接：建立连接 即可传输
对象：点对点 一对一一对多 多对多
可靠：可靠 最大努力
拥塞控制、流量控制
首部开销： 8 20
传输方式：面向字节 没有边界 面向报文
分片不同：

### 对应场景 协议
TCP http https SMTP FTP TELNET
udp 音视频 直播 DNS SNMP TFTP

### TCP UDP可以使用同一个端口吗
端口号作用：区分同一主机上不同应用程序的数据包
tcp udp在内核中是完全独立的软件模块
Ip包头协议号区分是tcp还是udp 确定送个哪个模块处理 然后根据端口确定给哪个应用程序处理

### ISN每次随机？
* 防止历史报文被下一个相同的四元组接受
* 安全性防止黑客伪造相同序列号的TCP报文被对方接受

### ISN如何随机？
ISN = M + F(四元组) -- M：计时器 每隔4us + 1 哈希算法

### 既然IP层分片，为什么TCP要需要MSS分片
MTU：一个网络包最大长度 1500
MSS： 除去IP和TCP头 一个网络报容纳TCP数据最大长度
* 当一个IP分片丢失，整个IP报文都需要重传 没有效率
* TCP分片后，重传以MSS为单位

### 三次握手能携带数据吗？
* 第三次可以携带
* 第一次可以携带的话攻击者放入大量数据，重发多次SYN 服务器阻塞 避免服务器收到攻击

### 为什么是三次握手？不是两次？四次？
* 防止历史连接初始化了连接
* 两次握手无法阻止历史连接：服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立起一个历史连接，造成资源浪费
* 同步双方序列号
* 避免资源浪费 两次握手，SYN阻塞，重复发送多次SYN 建立多个冗余的无效连接，造成不必要的资源浪费
#### 两次
无法阻止历史连接的建立，无法同步双方序列号，造成资源浪费
#### 四次
理论上三次已经实现最少的可靠连接建立，不需要四次

### 第一次握手丢失？
SYN 丢失 客户端没有收到syn/ack包 超时重传tcp_syn_retries次SYN后不再发送
### 第二次握手丢失
服务器的syn/ack包丢失 服务端没有收到客户端ack
客户端也没有收到syn/ack包
客户端重传tcp_syn_retries次syn
服务器重传tcp_synack_retries次 SYN-ACK包

### 第三次丢失
客户端发送ack 服务器没有收到
重传tcp_synack_retries次后不再发送断开连接
客户端认为建立了连接 如果发送数据包，超时重传tcp_retris次后断开
不发送数据包 保活机制

### 为什么挥手要四次
关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，
等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接

### 第一次挥手丢失：
客户端调用close 发送FIN 进入FIN_WAIT_1 收到ACK后进入FIN_WAIT_2
第一次挥手丢失收不到ACK重传tcp_orphan_retries次FIN后断开连接

#### 第二次挥手丢失
服务端收到FIN先回一个ACK确认，进入CLOSE_WAIT状态 ACK是不会重传的
所以客户端收不到ACK 重传tcp_orphan_retries次FIN后断开链接

* 对于close调用的链接FIN_WAIT_2状态不会持续太久 tcp_fin_timeout控制 60S
* 如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，
* 那么意味着主动关闭方还是可以接收数据的。
* 如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态

### 第三次挥手丢失：
* 服务端处于close_wait发送FIN进入last_ack状态
内核没有权力替代进程关闭链接，必须由进程主动调用close函数
FIN丢失客户端迟迟收不到ACK将重传tcp_orphan次fin后断开链接
* 客户端因为是通过 close 函数关闭连接的，
* 处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。

### 第四次挥手丢失
客户端收到FIN后回复ACK进入TIME_WAIT状态 持续2msl进入close
服务端没有收到ACK还是处于last_ack
如果没有收到ack 服务端重发 tcp_orphan_retries次 FIN


### TIME_WAIT 2MSL
MSL 报文最大生存事件 任何报文在网络上生存的最长事件
TTL 经过路由条数
MSL大于等于TTL消耗为0的时间
* 如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，
* 另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。
* 2MSL相当于允许报文至少丢失一次

为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。

### 为什么需要TIME_WAIT
* 防止历史链接中的数据，被后面相同的四元组接受
* 保证被动关闭的一方能正常关闭

### TIME_WAIT过多
* 占用系统资源：文件描述符、内存CPU线程资源
* 占用端口资源
* 对客户端，占满所有端口资源，无法对ip+port一样的服务器发起链接，但是可以对另一个服务器
* 对服务端，服务器只监听一个端口，可以建立很多链接

### 优化
* 打开net.ipv4.tcp_tw_reuse 和时间戳
：tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。
* net.ipv4.tcp_max_tw_buckets
:当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置
* SO_LINGER
:如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。