
OSI七层：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 理论模型

TCP/IP四层 应用层 传输层 网络层 网络接口层

五层 应用层 传输层 网络层 数据链路层 物理层

应用层：**为用户提供应用功能，不关心数据如何传输 工作在用户态** 其下内核态 -- **基本数据单元：报文** HTTP FTP⽂件传输 DNS SSH 安全外壳协议 **报⽂**

表示层： 数据**格式的转换** **加密解密压缩解压缩** 

会话层：**负责两点之间建立、维持和终止通信**，例如服务器验证用户登录sei

传输层：为**应用层提供数据传输服务** 将**上层数据分段并提供传输**，负责**流量控制**等 -- **段** TCP UDP **段**

网络层：**实际传输功能** **寻址**（找到IP地址对应的设备） + **路由**（数据应该往哪里发送） -- **包**
IP、ICMP（Internet控制报⽂协议，PING协议使⽤的）、ARP、RARP（属于⽹络层协议，⼯作内容是在数据链路层的）

数据链路层：为**网络层提供链路级别的服务** 将网络层的包组成帧 -- **帧** 错误纠正协议ARQ 点对点协议PPP

物理层：为**数据链路层提供二进制传输服务** 传输Bit流 -- **bit流** IEEE802通信标准



#### GET vs POST
数据传输方式 从服务器获取数据  向服务器新增、提交数据

数据长度限制 2048个字符  无限制

数据类型 ASCII字符  无限制 标准字符集

安全性 明文显示在网页上 较好

可见性 URL 不显示
可以收藏为书签 不可以
历史记录 保存 不保存
能被缓存  不可以缓存
传参方式 URL或Cookie BODY实体
安全且幂等  不安全不幂等

#### HTTP状态码
1xx 中间状态 服务器收到请求 需要请求者继续执行操作
2xx 成功接收并处理
3xx 重定向 需要进一步操作
4xx 客户端错误 请求包含语法错误或无法完成请求
5xx 服务器错误 服务器在处理请求的过程中发生了错误

101 切换请求协议 http->websocket
200 ok 服务器成功处理了请求

204 not content 同200 响应头没有Body数据

206 partital content 部分数据 与断点续传有关

301 永久重定向 需要新的url

302 临时重定向 

304 缓存重定向 协商缓存命中 告诉客户端可以继续使用缓存

400 bad request 客户端请求报文有错

401 身份过期，没有通过身份认证

403 forbidden 没有权限

404 not found 资源找不到

499 nginx 客户端已经关闭

500 笼统服务器内部错误

501 请求功能还不支持

502 bad gateway 错误网关 服务器作为网关或代理时返还

503 服务器目前无法使用 暂时状态

504 bad gateway timeout 网关超市

505 不支持Http协议版本


### HTTP缓存机制
强制缓存:命中责返回
协商缓存：和服务器进行协商 满足则返回huanc
etag:判断是否改变 精度优 性能低
last-modified最后一次改变时间

### HTTP请求完整过程
域名解析
TCP3次握手 建立TCP连接后 HTTP请求
服务器响应HTTP请求 浏览器得到Html 代码
浏览器解析 请求其中资源jc css 图片等
浏览器对页面进行渲染呈现给客户

### 长连接
HTTP 1.1默认长连接 connection: keep_alive

### http1.0问题
默认短连接
第一个请求发出去必须等待确认回来，才能发第二个请求

### HTTP1.1
优点：简单 灵活 易扩展 应用广泛 长连接
缺点：明文 头部巨大 队头阻塞 不支持服务器推送 并发连接有限

### HTTPS
优点：
混合加密 窃听
摘要算法 篡改
CA证书 冒充
缺点：技术门槛高 CA证书收费 需要更多的服务器资源

### HTTP2.0
优点：队头压缩 二进制格式 数据流 多路复用 服务器推送
缺点：TCP（队头阻塞） 连接迁移需要重新三次握手

### HTTP3.0
udp + quic

### http vs https
明文不安全  加入TLS/SSL安全协议 加密传输
三次握手 之后还需要TLS四次握手
端口 80  443
证书  CA证书
### HTTPS 解决了 HTTP 的哪些问题？
HTTP：
窃听：**混合加密**
在通信建立前采用**非对称加密的方式交换「会话秘钥」**，后续就不再使用非对称加密。
在通信过程中全部**使用对称加密的「会话秘钥」的方式加密明文数据**。
对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。
冒充 ：将服务器公钥放入到数字证书

篡改：摘要算法 实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
摘要算法（哈希函数）来计算出内容的哈希值
通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。

### HTTPS 是如何建立连接的？其间交互了什么？
**SSL/TLS 协议基本流程：**
客户端向**服务器索要并验证服务器的公钥**。
双方**协商生产「会话秘钥**」。
双方采用**「会话秘钥」进行加密通信**。

### 基于RSA
基于 RSA 算法的 HTTPS 存在「前向安全」的问题：
**如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解**
* clientHello:
客户端向服务端发送：支持TLS版本、clentRandom、支持的密码套件
* serverHello:
服务端确认TLS版本，生成serverRandom 确认密码套件、服务器的数字证书
* 客户端回应
先通过浏览器中的CA公钥确认服务数字证书的真伪，
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
**一个随机数**（pre-master key）。该随机数会被服务器公钥加密。
**加密通信算法改变通知**，表示随后的信息都将用「会话秘钥」加密通信。
**客户端握手结束通知**，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。
上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。
服务器和客户端有了这三个随机数（**Client Random、Server Random、pre-master key**），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。
* 服务器的最后回应
服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。
然后，向客户端发送最后的信息：
**加密通信算法改变通知**，表示随后的信息都将用「会话秘钥」加密通信。
**服务器握手结束通知**，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。
至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，
本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。
### HTTP 1.1 vs 1.0
长连接 短连接 每一次都需要三次握手 请求串行  
支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间  ： 发送一个请求等待响应才能发第二个

**断点续传**  range指定数据字节位置
新增HOST请求头： 虚拟主机技术
新增错误状态码

HTTP1.1性能瓶颈：header未经压缩就发送，首部信息越多延迟越大 只能压缩body
发送冗长的首部 每次互相发送相同的首部造成浪费
服务器按照请求的顺序相应 服务器相应慢造成客户端一直请求不到数据 对头阻塞
没有请求优先级控制
请求只能从客户端开始 服务器被动响应

### HTTP2.0 VS 1.1

头部压缩：多个请求，头部相同，消除重复部分 HPACK：维护头信息表，字段-索引号
二进制格式  纯文本
stream流 不用按序发送 指定优先级 一个TCP多个stream流 不同stream帧乱序发送 stream ID
多路复用 ： 在一个连接中并发多个请求或响应
实现服务器推送 客户端和服务器双方都可以建立 Stream

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，
这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，
只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题

### 2.0 vs 3.0

TCP对头阻塞 UDP无对头阻塞
当**某个流发生丢包时，只会阻塞这个流**，其他流不会受到影响，因此不存在队头阻塞问题。
QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响
更快的连接建立 握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。
QUIC 使用的是 T**LS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商**
在第二次连接的时候，应用数据包可以和 **QUIC 握手信息（连接信息 + TLS 信息）**一起发送，达到 0-RTT 的效果。
IC 协议没有用四元组的方式来“绑定”连接，而是**通过连接 ID来标记通信的两个端点**，
客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，
**只要仍保有上下文信息（比如连接 ID、TLS 密钥等）**，**就可以“无缝”地复用原连接，消除重连的成本**，没有丝毫卡顿感，达到了连接迁移的功能。
不用四元组 两个ID标记 连接迁移不需要三次握手


### session vs token
签名验证机制替代白名单验证

session的问题：前端传来的session_id可以伪造 所以需要在服务器维护一个session_id白名单验证
token通过签名机制只要前段传来的token能通过签名认证就是合法不需要服务器维护

## 应用层DNS
DNS端口53 
区域传输是用tcp
域名解析udp

### DNS解析过程
* 浏览器中查询域名对应ip地址缓存， 硬盘Hosts文件
* 都没有发DNS给本地DNS服务器
* 本地DNS服务器查询缓存，有直接返回，没有向DNS根服务器发送请求
* 根域名告诉本地DNS可以向顶级域 本地DNS向顶级域发出请求
* 顶级域告诉本地DNS权威域 本地DNS向权威域发出请求
* 得到IP和域名关系 缓存


### TCP VS UDP
连接：建立连接 即可传输
对象：点对点 一对一一对多 多对多
可靠：可靠 最大努力
拥塞控制、流量控制
首部开销： 8 20
传输方式：面向字节 没有边界 面向报文
分片不同：

### 对应场景 协议
TCP http https SMTP FTP TELNET
udp 音视频 直播 DNS SNMP TFTP

### TCP UDP可以使用同一个端口吗
端口号作用：区分同一主机上不同应用程序的数据包
tcp udp在内核中是完全独立的软件模块
Ip包头协议号区分是tcp还是udp 确定送个哪个模块处理 然后根据端口确定给哪个应用程序处理

### ISN每次随机？
* 防止历史报文被下一个相同的四元组接受
* 安全性防止黑客伪造相同序列号的TCP报文被对方接受

### ISN如何随机？
ISN = M + F(四元组) -- M：计时器 每隔4us + 1 哈希算法

### 既然IP层分片，为什么TCP要需要MSS分片
MTU：一个网络包最大长度 1500
MSS： 除去IP和TCP头 一个网络报容纳TCP数据最大长度
* 当一个IP分片丢失，整个IP报文都需要重传 没有效率
* TCP分片后，重传以MSS为单位

### 三次握手能携带数据吗？
* 第三次可以携带
* 第一次可以携带的话攻击者放入大量数据，重发多次SYN 服务器阻塞 避免服务器收到攻击

### 为什么是三次握手？不是两次？四次？
* 防止历史连接初始化了连接
：两次握手无法阻止历史连接：服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立起一个历史连接，造成资源浪费
* 同步双方序列号
* 避免资源浪费 两次握手，SYN阻塞，重复发送多次SYN 建立多个冗余的无效连接，造成不必要的资源浪费
#### 两次
无法阻止历史连接的建立，无法同步双方序列号，造成资源浪费
#### 四次
理论上三次已经实现最少的可靠连接建立，不需要四次

### 第一次握手丢失？
SYN 丢失 客户端没有收到syn/ack包 超时重传tcp_syn_retries次SYN后不再发送
### 第二次握手丢失
服务器的syn/ack包丢失 服务端没有收到客户端ack
客户端也没有收到syn/ack包
客户端重传tcp_syn_retries次syn
服务器重传tcp_synack_retries次 SYN-ACK包

### 第三次丢失
客户端发送ack 服务器没有收到
重传tcp_synack_retries次后不再发送断开连接
客户端认为建立了连接 如果发送数据包，超时重传tcp_retris次后断开
不发送数据包 保活机制

### 为什么挥手要四次
关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，
等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接

### 第一次挥手丢失：
客户端调用close 发送FIN 进入FIN_WAIT_1 收到ACK后进入FIN_WAIT_2
第一次挥手丢失收不到ACK重传tcp_orphan_retries次FIN后断开连接

#### 第二次挥手丢失
服务端收到FIN先回一个ACK确认，进入CLOSE_WAIT状态 ACK是不会重传的
所以客户端收不到ACK 重传tcp_orphan_retries次FIN后断开链接

* 对于close调用的链接FIN_WAIT_2状态不会持续太久 tcp_fin_timeout控制 60S
* 如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，
* 那么意味着主动关闭方还是可以接收数据的。
* 如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态

### 第三次挥手丢失：
* 服务端处于close_wait发送FIN进入last_ack状态
内核没有权力替代进程关闭链接，必须由进程主动调用close函数
FIN丢失客户端迟迟收不到ACK将重传tcp_orphan次fin后断开链接
* 客户端因为是通过 close 函数关闭连接的，
* 处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。

### 第四次挥手丢失
客户端收到FIN后回复ACK进入TIME_WAIT状态 持续2msl进入close
服务端没有收到ACK还是处于last_ack
如果没有收到ack 服务端重发 tcp_orphan_retries次 FIN


### TIME_WAIT 2MSL
MSL 报文最大生存事件 任何报文在网络上生存的最长事件
TTL 经过路由条数
MSL大于等于TTL消耗为0的时间
* 如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，
* 另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。
* 2MSL相当于允许报文至少丢失一次

为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。

### 为什么需要TIME_WAIT
* 防止历史链接中的数据，被后面相同的四元组接受
* 保证被动关闭的一方能正常关闭

### TIME_WAIT过多
* 占用系统资源：文件描述符、内存CPU线程资源
* 占用端口资源
* 对客户端，占满所有端口资源，无法对ip+port一样的服务器发起链接，但是可以对另一个服务器
* 对服务端，服务器只监听一个端口，可以建立很多链接

### 优化
* 打开net.ipv4.tcp_tw_reuse 和时间戳
：tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。
* net.ipv4.tcp_max_tw_buckets
:当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置
* SO_LINGER
:如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。