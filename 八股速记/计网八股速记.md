
OSI七层：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 理论模型

TCP/IP四层 应用层 传输层 网络层 网络接口层

五层 应用层 传输层 网络层 数据链路层 物理层

应用层： 为用户提供应用功能，不关心数据如何传输 工作在用户态 其下内核态 -- 报文

表示层： 数据格式的转换 加密解密压缩解压缩 

会话层：负责两点之间建立、维持和终止通信，例如服务器验证用户登录

传输层：为应用层提供数据传输服务 将上层数据分段并提供传输，负责流量控制等 -- 段

网络层：实际传输功能 寻址（找到IP地址对应的设备） + 路由（数据应该往哪里发送） -- 包

数据链路层：为网络层提供链路级别的服务 将网络层的包组成帧 -- 帧

物理层：为数据链路层提供二进制传输服务 传输Bit流 -- bit流



#### GET vs POST
数据传输方式 从服务器获取数据  向服务器新增、提交数据

数据长度限制 2048个字符  无限制

数据类型 ASCII字符  无限制 标准字符集

安全性 明文显示在网页上 较好

可见性 URL 不显示
可以收藏为书签 不可以
历史记录 保存 不保存
能被缓存  不可以缓存
传参方式 URL或Cookie BODY实体
安全且幂等  不安全不幂等

#### HTTP状态码
1xx 中间状态 服务器收到请求 需要请求者继续执行操作
2xx 成功接收并处理
3xx 重定向 需要进一步操作
4xx 客户端错误 请求包含语法错误或无法完成请求
5xx 服务器错误 服务器在处理请求的过程中发生了错误

101 切换请求协议 http->websocket
200 ok 服务器成功处理了请求

204 not content 同200 响应头没有Body数据

206 partital content 部分数据 与断点续传有关

301 永久重定向 需要新的url

302 临时重定向 

304 缓存重定向 协商缓存命中 告诉客户端可以继续使用缓存

400 bad request 客户端请求报文有错

401 身份过期，没有通过身份认证

403 forbidden 没有权限

404 not found 资源找不到

499 nginx 客户端已经关闭

500 笼统服务器内部错误

501 请求功能还不支持

502 bad gateway 错误网关 服务器作为网关或代理时返还

503 服务器目前无法使用 暂时状态

504 bad gateway timeout 网关超市

505 不支持Http协议版本


### HTTP缓存机制
强制缓存:命中责返回
协商缓存：和服务器进行协商 满足则返回huanc
etag:判断是否改变 精度优 性能低
last-modified最后一次改变时间

### HTTP请求完整过程
域名解析
TCP3次握手 建立TCP连接后 HTTP请求
服务器响应HTTP请求 浏览器得到Html 代码
浏览器解析 请求其中资源jc css 图片等
浏览器对页面进行渲染呈现给客户

### 长连接
HTTP 1.1默认长连接 connection: keep_alive

### http1.0问题
默认短连接
第一个请求发出去必须等待确认回来，才能发第二个请求

### HTTP1.1
优点：简单 灵活 易扩展 应用广泛 长连接
缺点：明文 头部巨大 队头阻塞 不支持服务器推送 并发连接有限

### HTTPS
优点：
混合加密 窃听
摘要算法 篡改
CA证书 冒充
缺点：技术门槛高 CA证书收费 需要更多的服务器资源

### HTTP2.0
优点：队头压缩 二进制格式 数据流 多路复用 服务器推送
缺点：TCP（队头阻塞） 连接迁移需要重新三次握手

### HTTP3.0
udp + quic

### http vs https
明文不安全  加入TLS/SSL安全协议 加密传输
三次握手 之后还需要TLS四次握手
端口 80  443
证书  CA证书

### HTTP 1.1 vs 1.0
长连接 短连接 每一次都需要三次握手 请求串行   
新增管道 可以发送多个请求  发送一个请求等待响应才能发第二个 
断点续传  range指定数据字节位置
新增HOST请求头： 虚拟主机技术
新增错误状态码

### HTTP2.0 VS 1.1

头部压缩：多个请求，头部相同，消除重复部分
二进制格式  纯文本
stream流 不用按序发送 指定优先级
多路复用 ： 在一个连接中并发多个请求或响应
实现服务器推送

### 2.0 vs 3.0

TCP对头阻塞 UDP无对头阻塞

不用四元组 两个ID标记 连接迁移不需要三次握手


### session vs token
签名验证机制替代白名单验证

session的问题：前端传来的session_id可以伪造 所以需要在服务器维护一个session_id白名单验证
token通过签名机制只要前段传来的token能通过签名认证就是合法不需要服务器维护

## 应用层DNS
DNS端口53 
区域传输是用tcp
域名解析udp

### DNS解析过程
* 浏览器中查询域名对应ip地址缓存， 硬盘Hosts文件
* 都没有发DNS给本地DNS服务器
* 本地DNS服务器查询缓存，有直接返回，没有向DNS根服务器发送请求
* 根域名告诉本地DNS可以向顶级域 本地DNS向顶级域发出请求
* 顶级域告诉本地DNS权威域 本地DNS向权威域发出请求
* 得到IP和域名关系 缓存


### TCP VS UDP
连接：建立连接 即可传输
对象：点对点 一对一一对多 多对多
可靠：可靠 最大努力
拥塞控制、流量控制
首部开销： 8 20
传输方式：面向字节 没有边界 面向报文
分片不同：

### 对应场景 协议
TCP http https SMTP FTP TELNET
udp 音视频 直播 DNS SNMP TFTP

### TCP UDP可以使用同一个端口吗
端口号作用：区分同一主机上不同应用程序的数据包
tcp udp在内核中是完全独立的软件模块
Ip包头协议号区分是tcp还是udp 确定送个哪个模块处理 然后根据端口确定给哪个应用程序处理

### ISN每次随机？
* 防止历史报文被下一个相同的四元组接受
* 安全性防止黑客伪造相同序列号的TCP报文被对方接受

### ISN如何随机？
ISN = M + F(四元组) -- M：计时器 每隔4us + 1 哈希算法

### 既然IP层分片，为什么TCP要需要MSS分片
MTU：一个网络包最大长度 1500
MSS： 除去IP和TCP头 一个网络报容纳TCP数据最大长度
* 当一个IP分片丢失，整个IP报文都需要重传 没有效率
* TCP分片后，重传以MSS为单位

### 三次握手能携带数据吗？
* 第三次可以携带
* 第一次可以携带的话攻击者放入大量数据，重发多次SYN 服务器阻塞 避免服务器收到攻击

### 为什么是三次握手？不是两次？四次？
* 防止历史连接初始化了连接
* 两次握手无法阻止历史连接：服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立起一个历史连接，造成资源浪费
* 同步双方序列号
* 避免资源浪费 两次握手，SYN阻塞，重复发送多次SYN 建立多个冗余的无效连接，造成不必要的资源浪费
#### 两次
无法阻止历史连接的建立，无法同步双方序列号，造成资源浪费
#### 四次
理论上三次已经实现最少的可靠连接建立，不需要四次

### 第一次握手丢失？
SYN 丢失 客户端没有收到syn/ack包 超时重传tcp_syn_retries次SYN后不再发送
### 第二次握手丢失
服务器的syn/ack包丢失 服务端没有收到客户端ack
客户端也没有收到syn/ack包
客户端重传tcp_syn_retries次syn
服务器重传tcp_synack_retries次 SYN-ACK包

### 第三次丢失
客户端发送ack 服务器没有收到
重传tcp_synack_retries次后不再发送断开连接
客户端认为建立了连接 如果发送数据包，超时重传tcp_retris次后断开
不发送数据包 保活机制
