#### 总结
正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，
而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。

但如果进程觉得"罪不致死"，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。

回过头来看为什么虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，
针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了。

为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑
与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误/异常抛给用户来处理。



#### 线程崩溃，进程一定会崩溃吗
一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃
为什么系统要让进程崩溃呢，这主要是因为在进程中，各个线程的地址空间是共享的
既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，
这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃

线程共享代码段，数据段，地址空间，文件非法访问内存有以下几种情况，我们以 C 语言举例来看看。
```c
//1.、针对只读内存写入数据

#include <stdio.h>
#include <stdlib.h>

int main() {
char *s = "hello world";
// 向只读内存写入数据，崩溃
s[1] = 'H';
}
//2、访问了进程没有权限访问的地址空间（比如内核空间）

#include <stdio.h>
#include <stdlib.h>

int main() {
int *p = (int *)0xC0000fff;
// 针对进程的内核空间写入数据，崩溃
*p = 10;
}
在 32 位虚拟地址空间中，p 指向的是内核空间，显然不具有写入权限，所以上述赋值操作会导致崩溃

// 3、访问了不存在的内存，比如：

#include <stdio.h>
#include <stdlib.h>

int main() {
int *a = NULL;
*a = 1;     
}
以上错误都是访问内存时的错误，所以统一会报 Segment Fault 错误（即段错误），这些都会导致进程崩溃
```
#### 进程是如何崩溃的-信号机制简介
大家想想要干掉一个正在运行的进程是不是经常用 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思，其中的 9 就是信号。
其实信号有很多类型的，在 Linux 中可以通过 kill -l查看所有可用的信号：

当然了发 kill 信号必须具有一定的权限，否则任意进程都可以通过发信号来终止其他进程，那显然是不合理的，
#### 实际上 kill 执行的是系统调用，将控制权转移给了内核（操作系统），由内核来给指定的进程发送信号

#### 那么发个信号进程怎么就崩溃了呢，这背后的原理到底是怎样的？

其背后的机制如下
* CPU 执行正常的进程指令
* 调用 kill 系统调用向进程发送信号
* 进程收到操作系统发的信号，CPU 暂停当前程序运行，并将控制权转交给操作系统
* 调用 kill 系统调用向进程发送信号（假设为 11，即 SIGSEGV，一般非法访问内存报的都是这个错误）
* 操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出
* 注意上面的第五步，如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般最后会让进程退出），
* 但如果注册了，则会执行自己的信号处理函数，它收到 kill 信号后，可以调用 exit() 来退出，
* 但也可以使用 sigsetjmp，siglongjmp 这两个函数来恢复进程的执行
```c


// 自定义信号处理函数示例

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
// 自定义信号处理函数，处理自定义逻辑后再调用 exit 退出
void sigHandler(int sig) {
printf("Signal %d catched!\n", sig);
exit(sig);
}
int main(void) {
signal(SIGSEGV, sigHandler);
int *p = (int *)0xC0000fff;
*p = 10; // 针对不属于进程的内核空间写入数据，崩溃
}

// 以上结果输出: Signal 11 catched!
// 如代码所示：注册信号处理函数后，当收到 SIGSEGV 信号后，先执行相关的逻辑再退出

//另外当进程接收信号之后也可以不定义自己的信号处理函数，而是选择忽略信号，如下

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

int main(void) {
// 忽略信号
signal(SIGSEGV, SIG_IGN);

// 产生一个 SIGSEGV 信号
raise(SIGSEGV);

printf("正常结束");
}
```
虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号就有机会逃出生天，
当然了 kill -9 命令例外，不管进程是否定义了信号处理函数，都会马上被干掉。

通过上面的介绍大家不难发现，其实是 JVM 自己定义了信号处理函数，
这样当发送 kill pid 命令（默认会传 15 也就是 SIGTERM）后，JVM 就可以在信号处理函数中执行一些资源清理之后再调用 exit 退出。

这种场景显然不能用 kill -9，不然一下把进程干掉了资源就来不及清除了。
