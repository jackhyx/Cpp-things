## UDP的特点
UDP是无连接的；
UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
UDP是面向报文的；
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；
UDP支持一对一、一对多、多对一和多对多的交互通信；
UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

## TCP的特点
TCP是面向连接的。
每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据
TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。
“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

## UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层
无论应用层交给UDP多长的报文，它统统发送，一次发送一个。
而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。
因此，它需要应用层控制报文的大小

## TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，
发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据# 当前网络的拥塞状态来确定每个报文段的大小 #

## 封包和拆包你听说过吗？它是基于TCP还是UDP的？

封包和拆包都是基于TCP的概念。

# 因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连 ##

封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分# 包头是一个固定长度的结构体，里面包含该数据包的总长度 #
拆包：接收方在接收到报文后提取包头中的长度信息进行截取


## TCP 协议如何保证可靠传输？

第一种回答
## 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
## 数据校验：TCP报文头有校验和，用于校验报文是否损坏。
## 数据合理分片和排序：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层
而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组
由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
## 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
## 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

第二种回答
建立连接（标志位）：通信前确认通信实体存在。
序号机制（序号、确认号）：确保了数据是按序、完整到达。
数据校验（校验和）：CRC校验全部数据。

第三种回答
首部校验 这个校验机制能够确保数据传输不会出错吗？ 答案是不能。
原因
TCP协议中规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字
然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。
这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？显然不能。
因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。
但是小学生都知道A+B=B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。

解决方案
传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题

## 你了解流量控制原理吗？
目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。

TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。

发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。

接收窗：用来标记可以接收的数据大小。

TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分
其中发送窗 = 已发送未确认部分 + 未发但可发送部分
接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。

发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。

## TCP四大拥塞控制算法总结？（极其重要）
四大算法
拥塞控制主要是四个算法：
# 慢启动
# 拥塞避免
# 拥塞发生 
# 快速恢复 
这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。

慢热启动算法 – Slow Start
所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。
慢启动算法：
# 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。
# 每当收到一个ACK，cwnd大小加一，呈线性上升。
# 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数上升； 
# 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”

拥塞避免算法 – Congestion Avoidance
如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：
# 收到一个ACK，则cwnd = cwnd + 1 / cwnd 
# 每当过了一个往返延迟时间RTT，cwnd大小加一。

# 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加，调整到网络的最佳值。

# 拥塞发生状态时的算法
一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号
# 对于丢包有两种判定方式
# 一种是超时重传RTO[Retransmission Timeout] # 
# 另一个是收到三个重复确认ACK #

# 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器
 在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止 #
 
# 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传
这个机制不需要等到重传定时器超时，所以叫做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。

超时重传RTO[Retransmission Timeout]，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：

由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.
cwnd重置为1
进入慢启动过程
最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。

所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：

cwnd大小缩小为当前的一半
ssthresh设置为缩小后的cwnd大小
然后进入快速恢复算法Fast Recovery。

# 快速恢复算法 – Fast Recovery
TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半
快速恢复算法的逻辑如下：
cwnd = cwnd + 3 MSS，加3 MSS的原因是因为收到3个重复的ACK。
重传DACKs指定的数据包。
如果再收到DACKs，那么cwnd大小增加一。
如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。
如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5
所以将ssthresh设置当当时cwnd的一半，也就是6/2 = 3，cwnd设置为3 + 3 = 6。然后重传第五个包
当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。

## 为何快速重传是选择3次ACK？

主要的考虑还是要区分包的丢失是由于## 链路故障还是乱序等其他因素引发 #

两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的
四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。

在没有fast retransmit / recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因
1）包checksum 出错
2）网络拥塞
3）网络断，包括路由重收敛
但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1/2，这样的方法对2是有效的，可以缓解网络拥塞
3则无所谓，反正网络断了，无论发快发慢都会被丢
但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。

# 于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断

否则也接收不到ACK，如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；

#而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包
可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。
#而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。

超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
窗口机制（窗口）：提供流量控制，避免过量发送。
拥塞控制：同上。








## 网络层常见协议？可以说一下吗？
协议	名称	作用
## IP	网际协议	IP协议不但定义了# 数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 # 
## ICMP	Internet控制报文协议	ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议
## RIP	路由信息协议	使用“跳数”(即metric)来衡量到达目标地址的路由距离
## IGMP	Internet组管理协议	用于实现组播、广播等通信

## 应用层常见协议知道多少？了解几个？
协议	名称	默认端口	底层协议
## HTTP	超文本传输协议	80	TCP
## HTTPS	超文本传输安全协议	443	TCP
Telnet	远程登录服务的标准协议	23	TCP
FTP	文件传输协议	20传输和21连接	TCP
TFTP	简单文件传输协议	69	UDP
SMTP	简单邮件传输协议（发送用）	25	TCP
POP	邮局协议（接收用）	110	TCP
## DNS	域名解析服务	53	服务器间进行域传输的时候用TCP
   客户端查询DNS服务器时用 UDP
