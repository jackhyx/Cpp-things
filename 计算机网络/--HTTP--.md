#### 状态码

* 1xx
* 200
* 204 no content : 响应头没有 body 数据
* 206 partial content : HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分

* 301 moved permanently
* 302 found
* 304 not modified

* 400 : Bad request
* 403 : forbidden
* 404 : not found

* 500 : Internal Server Error 
* 501 : Not Implemented 客户端请求的功能还不支持
* 502 : Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
* 503 : Service Unavailable : 表示服务器当前很忙，暂时无法响应客户端

#### HTTP字段
* Host 字段 : 指定服务器的域名
* Content-Length : 服务器在返回数据时, 表明本次回应的数据长度
* Connection : 
* Content-Type : 
* Content-Encoding : Accept-Encoding

#### GET & POST
在 HTTP 协议里 ：
* 「安全」是指请求方法不会「破坏」服务器上的资源。
* 「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
* GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。
* POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。
* 注意， 上面是从 RFC 规范定义的语义来分析的。
* 但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：
* 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
* 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

* RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。
* 只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

#### HTTP 缓存技术
##### 强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
* Cache-Control， 是一个相对时间；
* Expires，是一个绝对时间；
* 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
  浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
  服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。
##### 什么是协商缓存？ 
* 两种实现
* 基于时间实现 : 响应头部中的 Last-Modified  VS  请求头部中的 If-Modified-Since
* 是基于一个唯一标识 : 响应头部中 Etag VS 请求头部中的 If-None-Match
* 如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高
* 协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求

#### HTTP（1.1） 的优点
* 简单： header + body
* 灵活和易于扩展 ： 允许开发人员自定义和扩充 下层可以随意变化
* 应用广泛和跨平台 

* 无状态 好 VS 坏  
* 明文传输 
* 「不安全」 ： 
  明文（不加密），内容可能会被窃听
  不验证通信方的身份，因此有可能遭遇伪装。
  无法证明报文的完整性，所以有可能已遭篡改。

#### HTTP/1.1 的性能如何
* 长连接 ： 减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
* 管道网络传输 ： 可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间
* HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞 ： 服务器必须按照接收请求的顺序发送对这些管道化请求的响应。
* 注意：实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以后面讨论HTTP/1.1 都是建立在没有使用管道化的前提
* 队头阻塞  ： 「请求 - 应答」的模式加剧了 HTTP 的性能问题


### HTTP 与 HTTPS
#### HTTP 与 HTTPS 有哪些区别？
* HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题 ----------- HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输HTTPS ----------- 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
* HTTP 的端口号是 80 ----------- HTTPS 的端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的


#### HTTPS 解决了 HTTP 的哪些问题
* 窃听风险 -- 信息加密
* 篡改风险 -- 校验机制
* 冒充风险 -- 身份证书
* 混合加密的方式实现信息的机密性，解决了窃听的风险。
  在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
  在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
* 采用「混合加密」的方式的原因：
  对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
  非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

* 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
  用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。
  但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明
  非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。
  私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

* 可以通过哈希算法来保证消息的完整性； 
* 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

* 通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。
