#### 状态码

* 1xx
* 200
* 204 no content : 响应头没有 body 数据
* 206 partial content : HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分

* 301 moved permanently
* 302 found
* 304 not modified

* 400 : Bad request
* 403 : forbidden
* 404 : not found

* 500 : Internal Server Error 
* 501 : Not Implemented 客户端请求的功能还不支持
* 502 : Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
* 503 : Service Unavailable : 表示服务器当前很忙，暂时无法响应客户端

#### HTTP字段
* Host 字段 : 指定服务器的域名
* Content-Length : 服务器在返回数据时, 表明本次回应的数据长度
* Connection : 
* Content-Type : 
* Content-Encoding : Accept-Encoding

#### GET & POST
在 HTTP 协议里 ：
* 「安全」是指请求方法不会「破坏」服务器上的资源。
* 「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
* GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。
* POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。
* 注意， 上面是从 RFC 规范定义的语义来分析的。
* 但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：
* 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
* 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

* RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。
* 只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

#### HTTP 缓存技术
##### 强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
* Cache-Control， 是一个相对时间；
* Expires，是一个绝对时间；
* 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
  浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
  服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。
##### 什么是协商缓存？ 
* 两种实现
* 基于时间实现 : 响应头部中的 Last-Modified  VS  请求头部中的 If-Modified-Since
* 是基于一个唯一标识 : 响应头部中 Etag VS 请求头部中的 If-None-Match
* 如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高
* 协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求

#### HTTP（1.1） 的优点
* 简单： header + body
* 灵活和易于扩展 ： 允许开发人员自定义和扩充 下层可以随意变化
* 应用广泛和跨平台 

* 无状态 好 VS 坏  
* 明文传输 
* 「不安全」 ： 
  明文（不加密），内容可能会被窃听
  不验证通信方的身份，因此有可能遭遇伪装。
  无法证明报文的完整性，所以有可能已遭篡改。

#### HTTP/1.1 的性能如何
* 长连接 ： 减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
* 管道网络传输 ： 可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间
* HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞 ： 服务器必须按照接收请求的顺序发送对这些管道化请求的响应。
* 注意：实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以后面讨论HTTP/1.1 都是建立在没有使用管道化的前提
* 队头阻塞  ： 「请求 - 应答」的模式加剧了 HTTP 的性能问题


### HTTP 与 HTTPS
#### HTTP 与 HTTPS 有哪些区别？
* HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题 ----------- HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输HTTPS ----------- 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
* HTTP 的端口号是 80 ----------- HTTPS 的端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的


#### HTTPS 解决了 HTTP 的哪些问题
* 窃听风险 -- 信息加密
* 篡改风险 -- 校验机制
* 冒充风险 -- 身份证书
* 混合加密的方式实现信息的机密性，解决了窃听的风险。
  在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
  在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
* 采用「混合加密」的方式的原因：
  对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
  非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

* 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
  用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。
  但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明
  非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。
  私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

* 可以通过哈希算法来保证消息的完整性； 
* 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

* 通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。


#### SSL/TLS 的「握手阶段」涉及四次通信  2RTT
* TLS 第一次握手 : Client Hello
* TLS 第二次握手 : Server Hello 
  客户端和服务端就已确认了 TLS 版本和使用的密码套件，客户端和服务端都会各自生成一个随机数，传递给对方。
  服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书
  随后，服务端发了「Server Hello Done」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕
* 客户端验证证书
  证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？ 
  这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。
* TLS 第三次握手 
  客户端就会生成一个新的随机数 (pre-master)
  用服务器的 RSA 公钥加密该随机数，
  通过「Change Cipher Key Exchange」消息传给服务端。
  客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master。
  双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。
  生成完会话密钥后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。
  客户端再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。
* TLS 第四次握手
  服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。
  最后，就用「会话密钥」加解密 HTTP 请求和响应了。

#### 优化 HTTP/1.1 协议的思路。

* 通过缓存技术来避免发送 HTTP 请求。
  客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。
* 减少 HTTP 请求的次数，有以下的方法：
  将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；
  将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；
  按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。
* 通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。

#### 优化 HTTS协议的思路。
* 硬件优化
因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择支持 AES-NI 特性的 CPU，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。
* 软件优化 
如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。
* 协议优化
密钥交换算法应该选择 ECDHE 算法，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。
将 TLS1.2 升级 TLS1.3，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。
* 证书优化
  服务器应该选用 ECDSA 证书，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；
  服务器应该开启 OCSP Stapling 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；
  对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。
    常见的会话重用技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。
    对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。
    这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。