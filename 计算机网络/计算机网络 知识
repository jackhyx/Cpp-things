## MTU和MSS分别是什么？
# MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。
# MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据
# MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。


## 什么是TCP粘包/拆包？发生的原因？

# 拆包：一个完整的业务可能会被TCP拆分成多个包进行发送
# 粘包：也有可能把多个小的包封装成一个大的数据包发送

# 原因

# 应用程序写入数据的字节大小大于套接字发送缓冲区的大小.
# 进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)
# 以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）

# 解决方案

# 消息定长。
# 在包尾部增加回车或者空格符等特殊字符进行分割
# 将消息分为消息头和消息尾
# 使用其它复杂的协议，如RTMP协议等。

## 为什么服务器会有 # 缓存 #这一项功能？如何实现的？

# 原因

# 缓解服务器压力；
# 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快
并且缓存服务器在地理位置上也有可能比源服务器来得近，例如# 浏览器缓存。

# 实现方法

# 让代理服务器进行缓存；
# 让客户端浏览器进行缓存。

# HTTP请求方法你知道多少？

# 客户端发送的# 请求报文 # 第一行为 # 请求行 #包含了方法字段。

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。

# HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
# GET	请求指定的页面信息，并返回实体主体。
# HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
# POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。

# HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

序 号	方法	描述
1	GET	请求指定的页面信息，并返回实体主体。
2	HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
3	POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
4	PUT	从客户端向服务器传送的数据取代指定的文档的内容。
5	DELETE	请求服务器删除指定的页面。
6	CONNECT	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7	OPTIONS	允许客户端查看服务器的性能。
8	TRACE	回显服务器收到的请求，主要用于测试或诊断。
9	PATCH	是对 PUT 方法的补充，用来对已知资源进行局部更新 。

## HTTPS和HTTP的区别
# http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
# HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全
# HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
# https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 

# HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）
SSL/TLS协议的基本思路是采用 # 公钥加密法 #
客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
# 客户端向服务器端发起SSL连接请求；
# 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥
# 客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端
# 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密

# 进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。
# 因为数字签名、摘要是证书防伪非常关键的武器。
# “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”

## 什么是RARP？工作原理
概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反
RARP: 知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址
## 原理：
##网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址
主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。
# RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。
# PC1收到RARP回应后，就使用得到的IP地址进行通讯。

# 端口有效范围是多少到多少？
# 0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）
UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535
# 动态端口的范围是从1024到65535

## 为何需要把 TCP/IP 协议栈分成 5 层（或7层）？开放式回答。
# ARPANET 的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。

# 分层的好处：

# 隔层之间是独立的
# 灵活性好
# 结构上可以分隔开
# 易于实现和维护
# 能促进标准化工作。

## HTTP中缓存的私有和公有字段？知道吗？
private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在# 用户浏览器中 #
Cache-Control: private

public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在# 代理服务器中 #
Cache-Control: public

## GET 方法参数写法是固定的吗？
在约定中，我们的参数是写在 ? 后面，用 & 分割。
我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。
比如header请求头中添加token，来验证用户是否登录等权限问题。
也就是说# 我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗 #

## GET 方法的长度限制是怎么回事？
网络上都会提到浏览器地址栏输入的参数是有限的。

首先说明一点# HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因# 
浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。

## POST 方法比 GET 方法安全？
有人说POST 比 GET 安全，因为数据在地址栏上不可见。
然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。
要想安全传输，就只有加密，也就是 HTTPS。


## POST 方法会产生两个 TCP 数据包？你了解吗？
有些文章中提到# POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body #
HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。
所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。


