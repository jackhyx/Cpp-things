```
  int n = 1005; // 根据题意而定
    int father[1005];

    // 并查集初始化
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }
    // 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
        # f[find(f, x)] = find(f, y);
    }
    // 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
```

### 按秩合并的做法
* 我们用rank[ ]数组来记录每个根结点对应的树的深度（如果不是根结点，则rank中的元素大小表示的是以当前结点作为根结点的子树的深度）
* 一开始，把所有元素的rank设为1，即自己就为一颗树，且深度为1；合并的时候，比较两个根结点，把rank较小者合并到较大者中去。

#### 按秩合并的初始化：
```
    void init(int n) {
        for(int i=0;i<n;i++){
            Parent[i]=i;
            Rank[i]=1;
        }
    }
```
#### 按秩合并的合并代码：
```
//合并
    void merge(int i,int j) {
        int x = find(i),y = find(j); //分别找到结点i和结点j的根节点
        if(Rank[x] < Rank[y]){       //如果以x作为根结点的子树深度小于以y作为根结点的子树的深度，则把x合并到y中
            Parent[x]=y;
        }
        else {
            Parent[y]=x;
        }
            if(Rank[x] == Rank[y] && x != y) {  //如果深度相同且根结点不同，以x为根结点的子树深度+1
            Rank[x]++;
            }
    }
```