#### 优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的

和队列基本操作相同:

top 访问队头元素
empty 队列是否为空
size 返回队列内元素个数
push 插入元素到队尾 (并排序)
emplace 原地构造一个元素并插入队列
pop 弹出队头元素
swap 交换内容
定义：priority_queue<Type, Container, Functional>
Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector
Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆

```c++
//升序队列
priority_queue <int, vector<int>, greater<int> > q;
//降序队列
priority_queue <int, vector<int>, less<int> >q;
```

#### 347. 前 K 个高频元素

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        vector<int> res;
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        using pii = std::pair<int, int>;
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }
        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pii, vector<pii>, greater<pii>> pri_que;
        for(auto& pair : map) {
            pri_que.emplace(pair.second, pair.first);
            if (pri_que.size() > k) pri_que.pop();
        }
        while (!pri_que.empty()) {
            res.emplace_back(pri_que.top().second);
            pri_que.pop();
        }
        return res;

    }
};
```

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> res;
        unordered_map<int, int> umap;
        using pii = std::pair<int, int>;
        for (int i = 0; i < nums.size(); i++) {
            umap[nums[i]]++;
        }
        priority_queue<pii, vector<pii>, greater<pii> > pri_que;
        for (auto &pair: umap) {
            pri_que.emplace(pair.second, pair.first);
             if (pri_que.size() > k) {
            pri_que.pop();
            }
        }
       
        while(!pri_que.empty()) {
            res.push_back(pri_que.top().second);
            pri_que.pop();
        }
        return res;
    }
};
```

### 295. 数据流的中位数

* 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
  例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

* 设计一个支持以下两种操作的数据结构：
  void addNum(int num) - 从数据流中添加一个整数到数据结构中。
  double findMedian() - 返回目前所有元素的中位数。
* 示例：
  addNum(1)
  addNum(2)
  findMedian() -> 1.5
  addNum(3)
  findMedian() -> 2
* 进阶:
* 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
* 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法

```
class MedianFinder {
public:
std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;
std::priority_queue<int> max_pq;
    MedianFinder() {}

    void addNum(int x) {
        max_pq.push(x), min_pq.push(x);
        int lo = max_pq.top(), hi = min_pq.top();
        max_pq.pop(), min_pq.pop();
        if (lo > hi) std::swap(lo, hi);
        max_pq.push(lo), min_pq.push(hi);
    }
    
    double findMedian() {
        return ((double)max_pq.top() + (double)min_pq.top()) / 2;
    }
};

```

* 进阶 1
  如果数据流中所有整数都在 00 到 100100 范围内，那么我们可以利用计数排序统计每一类数的数量，并使用双指针维护中位数。

* 进阶 2
  如果数据流中 99\%99% 的整数都在 00 到 100100 范围内，那么我们依然利用计数排序统计每一类数的数量，并使用双指针维护中位数。对于超出范围的数，我们可以单独进行处理，建立两个数组，分别记录小于 00
  的部分的数的数量和大于 100100 的部分的数的数量即可。当小部分时间，中位数不落在区间 [0,100][0,100] 中时，我们在对应的数组中暴力检查即可。

### 二叉堆实现

```c++
template <class T>
struct MaxHeap{
	private:
		T *mHeap;      //存放堆的数组
		int mCapacity; //堆的容量
		int mSize;     //目前堆的大小
};
void filterup(int start){
	int c = start;      //当前位置，即数组末尾位置
	int p = (c - 1) / 2;    //当前位置的父节点位置
	T temp = mHeap[c];  //当前位置的键值
	
	while(c > 0){
		if(temp <= mHeap[p])
			break;
		else{
			mHeap[c] = mHeap[p];
			c = p;
			p = (p-1) / 2;
		}
	}
	mHeap[c] = temp;
}
int insert(T data){
	if(mSize == mCapacity)//堆满
		return;
	else{
		mHeap[mSize] = data;//放到数组最后
		filterup(mSize);
		mSize++; //堆的当前大小+1
		return 0;
	}
}
void filterdown(int start,int end){
	int c = start;    //被删当前节点
	int l = 2 * c + 1;    //左子树
	T temp = mHeap[c];//当前位置的键值
	while(l <= end){
		//判断左右子树谁大
		if(l < end && mHeap[l] < mHeap[l+1])
			l++;      //右子树大
		if(temp >= mHeap[l])
			break;
		else{
			mHeap[c] = mHeap[l];
			c = l;
			l = 2 * l + 1;
		}
	}
	mHeap[c] = temp;
}
int getIndex(T data){
	for(int i = 0;i < mSize;i++)
		if(data == mHeap[i])
			return i;
	return;
}
int remove(T data){
	int idx;
	if(mSize == 0)  //堆被清零
		return;
	idx =getIndex(data);
	mHeap[idx] = mHeap[--mSize];   //用最后元素填补
	filterdown(index, mSize - 1);
	return 0;
}
```