#### 优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的

和队列基本操作相同:

top 访问队头元素
empty 队列是否为空
size 返回队列内元素个数
push 插入元素到队尾 (并排序)
emplace 原地构造一个元素并插入队列
pop 弹出队头元素
swap 交换内容
定义：priority_queue<Type, Container, Functional>
Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector
Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆

```c++
//升序队列
priority_queue <int,vector<int>,greater<int> > q;
//降序队列
priority_queue <int,vector<int>,less<int> >q;
```





#### 347. 前 K 个高频元素
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        vector<int> res;
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        using pii = std::pair<int, int>;
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }
        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pii, vector<pii>, greater<pii>> pri_que;
        for(auto& pair : map) {
            pri_que.emplace(pair.second, pair.first);
            if (pri_que.size() > k) pri_que.pop();
        }
        while (!pri_que.empty()) {
            res.emplace_back(pri_que.top().second);
            pri_que.pop();
        }
        return res;

    }
};
```
```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> res;
        unordered_map<int, int> umap;
        using pii = std::pair<int, int>;
        for (int i = 0; i < nums.size(); i++) {
            umap[nums[i]]++;
        }
        priority_queue<pii, vector<pii>, greater<pii> > pri_que;
        for (auto &pair: umap) {
            pri_que.emplace(pair.second, pair.first);
             if (pri_que.size() > k) {
            pri_que.pop();
            }
        }
       
        while(!pri_que.empty()) {
            res.push_back(pri_que.top().second);
            pri_que.pop();
        }
        return res;
    }
};
```

### 295. 数据流的中位数
* 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

* 设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
* 示例：
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2
* 进阶:
* 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？ 
* 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法



```
class MedianFinder {
public:
std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;
std::priority_queue<int> max_pq;
    MedianFinder() {}

    void addNum(int x) {
        max_pq.push(x), min_pq.push(x);
        int lo = max_pq.top(), hi = min_pq.top();
        max_pq.pop(), min_pq.pop();
        if (lo > hi) std::swap(lo, hi);
        max_pq.push(lo), min_pq.push(hi);
    }
    
    double findMedian() {
        return ((double)max_pq.top() + (double)min_pq.top()) / 2;
    }
};

```

* 进阶 1
如果数据流中所有整数都在 00 到 100100 范围内，那么我们可以利用计数排序统计每一类数的数量，并使用双指针维护中位数。

* 进阶 2
如果数据流中 99\%99% 的整数都在 00 到 100100 范围内，那么我们依然利用计数排序统计每一类数的数量，并使用双指针维护中位数。对于超出范围的数，我们可以单独进行处理，建立两个数组，分别记录小于 00 的部分的数的数量和大于 100100 的部分的数的数量即可。当小部分时间，中位数不落在区间 [0,100][0,100] 中时，我们在对应的数组中暴力检查即可。
