#### * 205. 同构字符串
给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

#### * 290. 单词规律
给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。
示例1:
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
示例 2:

输入:pattern = "abba", s = "dog cat cat fish"
输出: false
示例 3:

输入: pattern = "aaaa", s = "dog cat cat dog"
输出: false
```c++
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        unordered_map<string, char> str2ch;
        unordered_map<char, string> ch2str;
        int m = str.length();
        int i = 0;
        for (auto ch : pattern) {
            if (i >= m) {
                return false;
            }
            int j = i;
            while (j < m && str[j] != ' ') j++;
            const string &tmp = str.substr(i, j - i);
            if (str2ch.count(tmp) && str2ch[tmp] != ch) {
                return false;
            }
            if (ch2str.count(ch) && ch2str[ch] != tmp) {
                return false;
            }
            str2ch[tmp] = ch;
            ch2str[ch] = tmp;
            i = j + 1;
        }
        return i >= m;
    }
};

class Solution {
public:
    bool wordPattern(string pattern, string s) {
        stringstream ss(s);
        string t;
        unordered_map<char,string> mc;
        unordered_map<string,char> ms;
        vector<string> ve;
        while(ss >> t) {
            ve.push_back(t);
        }
        if(pattern.size() != ve.size()) return false;
        int i = 0;
        for(auto e: pattern) {
            t = ve[i++];
            if(mc.count(e) && mc[e]!=t) return false;
            else if(ms.count(t) && ms[t]!=e) return false;
            mc[e] = t;
            ms[t] = e; 
        }
        return true;
    }
};


```
#### * 
给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。

示例 1：
输入：words = ["bella","label","roller"]
输出：["e","l","l"]
示例 2：
输入：words = ["cool","lock","cook"]
输出：["c","o"]
 
```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<string> result;

        if (words.size() == 0) return result;

        int hash[26] = {0};
        for (int i = 0; i < words[0].size(); i++) {
            hash[words[0][i] - 'a']++;
        }

        int hashOther[26] = {0};
        for (int i = 1; i < words.size(); i++) {
            memset(hashOther, 0, 26 * sizeof(int));
            for (int j = 0; j < words[i].size(); j++) {
                hashOther[words[i][j] - 'a']++;
            }
            for (int k = 0; k < 26; k++) {
                hash[k] = min(hash[k], hashOther[k]);
            }
        }
        for (int i = 0; i < 26; i++) {
            while (hash[i] != 0) {
                string s(1, i + 'a');
                result.push_back(s);
                hash[i]--;
            }
        }
        return result;
    }
};
```
#### * 387. 字符串中的第一个唯一字符
给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。

示例 1：
输入: s = "leetcode"
输出: 0
示例 2:
输入: s = "loveleetcode"
输出: 2
示例 3:
输入: s = "aabb"
输出: -1

#### 242. 有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

#### ** 599. 两个列表的最小索引总和 
假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。
示例 1:

输入: list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
输出: ["Shogun"]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。
```c++
class Solution {
public:
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        if (list2.size() < list1.size()) return findRestaurant(list2, list1);
        vector<string> result;
        unordered_map<string, int> map;
        int minIndex = list1.size() + list2.size() - 2;
        for(int i = 0; i < list1.size(); i++) {
            map[list1[i]] = i;
        }
        for (int i = 0; i < list2.size(); i++) {
            if (map.count(list2[i])) {
                if (map[list2[i]] + i == minIndex) {
                    result.push_back(list2[i]);
                } else if (map[list2[i]] + i < minIndex) {
                    minIndex = map[list2[i]] + i;
                    result.clear();
                    result.push_back(list2[i]);
                }
            }
        }
        return result;
    }
};
```
#### 383. 赎金信
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
magazine 中的每个字符只能在 ransomNote 中使用一次。

#### **滑动 594. 最长和谐子序列
和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
示例 1：
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是 [3,2,2,2,3]
示例 2：
输入：nums = [1,2,3,4]
输出：2
示例 3：
输入：nums = [1,1,1,1]
输出：0

#### 49. 字母异位词分组
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。
```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> result;
        unordered_map<string, vector<string>> map;
        for (auto str : strs) {
            string key = str;
            sort(key.begin(), key.end());
            map[key].push_back(str);
        }
        for (auto item = map.begin(); item != map.end(); item++) {
            result.push_back(item->second);
        }
        return result;
    }
};
```
#### ** 滑动窗口 438. 找到字符串中所有字母异位词
给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。
示例1:

输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
示例 2:
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
提示:
1 <= s.length, p.length <= 3 * 104
s和p仅包含小写字母

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int map1[26] = {0}, map2[26] = {0};
        for (auto ch : p) {
            map2[ch - 'a']++;
        }
        vector<int> result
        for (int slow = 0, fast = 0; fast < s.size(); fast++) {
            map1[s[fast] - 'a']++;
            while (map1[s[fast] - 'a'] > map2[s[fast] - 'a']) {
                // 如果窗口里某个字符数量比p中多了，那么要移动窗口位置
                map1[s[slow] - 'a']--;
                slow++;
            }
            if (fast - slow + 1 == p.size())
                res.push_back(slow);
        }
        return result;
    }
};

```
#### 349. 两个数组的交集
给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        
    }
};

```

#### 350. 两个数组的交集 II
给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000
进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
```c++

class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size() > nums2.size()) return intersect(nums2, nums1);
        unordered_map<int, int> map;
        vector<int> res;
        for(auto i : nums1) ++map[i];
        for(auto i : nums2) if(map.count(i) && map[i]) --map[i], res.push_back(i);
        return res;
    }
};
```

####  202. 快乐数
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
```c++

class Solution {
public:
    bool isHappy(int n) {

    }
};
```
#### 两数之和
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
    }
};
```

#### 15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```c++
class Solution {
public:
vector<vector<int>> threeSum(vector<int>& nums) {

    }
};
 

```
####645. 错误的集合
集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。



示例 1：

输入：nums = [1,2,2,4]
输出：[2,3]
示例 2：

输入：nums = [1,1]
输出：[1,2]

#### *** 720. · 
给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。
若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串
```c++
class Solution {
public:
    string longestWord(vector<string>& words) {
        sort(words.begin(),words.end());
        set<string> s;//集合
        string ans;//返回的答案
        for(int i = 0;i < words.size();i++){
            if(words[i].size() == 1||s.count(words[i].substr(0,words[i].size()-1))){
                ans = words[i].size() > ans.size() ? words[i] : ans;
                s.insert(words[i]);
            }      
        }
        return ans;
    }
};
class Solution {
public:
    string longestWord(vector<string>& words) {
        sort(words.begin(), words.end(), [](const string &a, const string &b) {
                return a.size() != b.size() ? a.size() < b.size() : a > b;
            });
        unordered_set<string> unst;
        for (auto& a : words) {
            unst.insert(a);
        }
        string ans = "";
        for (int i = words.size() - 1; i >= 0; i--) {//从后往前走
            string temp = words[i];
            int len = temp.size() - 1;
            while(len) {
                temp.pop_back();
                if (!unst.count(temp)) break;
                --len;
            }
            if (len == 0) {
                ans = words[i];
                break;
            }
        }
        return ans;
    }
};
```

#### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

```c++
class Solution {
public:
        int lengthOfLongestSubstring(string s) {
            int n = s.size();
            if (n < 2) return n;
            unordered_map <char, int> map;
            int left = 0, right = 0, maxLen = 0;
            for (right = 0 ; right < n; right++) {
                map[s[right]] ++;
                while (map[s[left] != map.end()]) {
                    map[s[left]]--;
                    left++;
                }
                maxLen = max(maxLen, right - left + 1);
        }
            return maxLen;
    }
};
```

#### 380. O(1) 时间插入、删除和获取随机元素
实现RandomizedSet 类：
RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。
首先，要在O(1)时间内的插入删除，肯定要利用哈希表的
但是问题在于随机返回一个元素，一开始还想着直接随机一个dict.size()范围内的数，然后让一个指向dict头部的迭代器与之相加
仔细一想，无序容器的迭代器不支持随机访问。。。但要随机返回某个元素，肯定要用到支持随机访问得迭代器啊！

而显然，支持随机访问的迭代器必须是管理连续内存的容器，常见的有--vector 、deque、C-stying arrary

用vector存储每一个插入的元素
散列表dict存储插入元素的下标
删除---怎样做到O(1)时间从vector容器内删除元素呢?显然，要从vector容器内删除元素，只能从其尾部删除。
所以方法是:先交换vector队尾元素和待删除元素的值(因为dict中存储了下标，所以可以直接得到待删除元素的下标)，然后把队尾元素删除，并更新原队尾元素的下标即可，其他位置的元素下标并没有变化。
```c++
class RandomizedSet {
    public:
    // 存储元素的值
    vector<int> nums;
    // 记录每个元素对应在 nums 中的索引
    unordered_map<int,int> valToIndex;

    bool insert(int val) {
        // 若 val 已存在，不用再插入
        if (valToIndex.count(val)) {
            return false;
        }
        // 若 val 不存在，插入到 nums 尾部，
        // 并记录 val 对应的索引值
        valToIndex[val] = nums.size();
        nums.push_back(val);
        return true;
    }

    bool remove(int val) {
        // 若 val 不存在，不用再删除
        if (!valToIndex.count(val)) {
            return false;
        }
        // 先拿到 val 的索引
        int index = valToIndex[val];
        // 将最后一个元素对应的索引修改为 index
        valToIndex[nums.back()] = index;
        // 交换 val 和最后一个元素
        swap(nums[index], nums.back());
        // 在数组中删除元素 val
        nums.pop_back();
        // 删除元素 val 对应的索引
        valToIndex.erase(val);
        return true;
    }

    int getRandom() {
        // 随机获取 nums 中的一个元素
        return nums[rand() % nums.size()];
    }
};
```
#### *优先队列 451. 根据字符出现频率排序
给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。
返回 已排序的字符串 。如果有多个答案，返回其中任何一个。
```c++

class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char,int> map;
        for(char& c : s)
        {
        map[i]++;
        }
        priority_queue<pair<int,char>,vector<pair<int,char>>,less<pair<int,char>>> pq;
        for(auto i:map)
        {
            pq.emplace(i.second, i.first);
        }
        string res;
        while(!pq.empty())
        {
            for(int i = 0;i < pq.top().first;i++)
            {
                res.push_back(pq.top().second);
            }
            pq.pop();
        }
        return res;
    }
};

```
* 原地排序
```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for(auto& c: s)
            map[c]++;
        sort(s.begin(), s.end(), [&](char& a, char& b){
            if(mp[a] == mp[b])
            return a < b;
            return mp[a] >= mp[b];
        });
        return s;
    }
};
``` 
#### 648. 单词替换
在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。
现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。
你需要输出替换之后的句子。
示例 1：
输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"
```c++
class Solution {
public:
    string replaceWords(vector<string>& dictionary, string sentence) {
        /*sort(dictionary.begin(), dictionary.end());//多此一举了，不预处理速度还要快一些
        unordered_set<string> dicset;
        string temp = dictionary[0];
        dicset.insert(temp);
        for(int i = 1; i<dictionary.size(); ++i){
            if(temp != dictionary[i].substr(0,temp.size())){
                temp = dictionary[i];
                dicset.insert(temp);
            }
        }*/
        unordered_set<string> dicset;
        for(string& dic : dictionary) dicset.insert(dic);
        string temp;
        stringstream ss;
        ss << sentence;
        string ans;
        while(ss >> temp){
            string str;
            for(int i = 0; i<temp.size(); ++i){
                str += temp[i];
                if(dicset.find(str) != dicset.end()) break;
            }
            ans += str + ' ';
        }
        ans.pop_back();
        return ans;
    }
};
```
#### #692. 前K个高频单词 * 标准的优先队列解决题
给一非空的单词列表，返回前 k 个出现次数最多的单词。
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。
示例 1：
输入: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
输出: ["i", "love"]
解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
注意，按字母顺序 "i" 在 "love" 之前。****
```c++
class Solution {
public:
//仿函数控制比较方式
    struct Cmp
    {
        bool operator()(const map<string,int>::iterator& a, const map<string,int>::iterator& b)
        {
            return a->second == b->second ? a->first < b->first : a->second > b->second;
        }
    };
    vector<string> topKFrequent(vector<string>& words, int k) {
            map<string,int> m;
            vector<string> ret;
            for (auto e : words)
            {
                ++m[e];
            }
           //存迭代器比直接存pair更节省空间
            priority_queue<map<string,int>::iterator, vector<map<string,int>::iterator>,Cmp> pq;
            auto it = m.begin();
               while (it != m.end()){
                pq.push(it);
                ++it;
                //建size为k的小堆
                if (pq.size() > k)
                    pq.pop();
            }
            while (!pq.empty())
            {
                auto it = pq.top();
                pq.pop();
                ret.push_back(it->first);
            }
            reverse(ret.begin(),ret.end());//小堆是反过来的，次数最少的在最前面，所以要reverse一下
            return ret;
    }
};
```