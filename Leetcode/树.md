```
    vector<int> preoderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> result;
        if (root == nullptr) return result;
        st.push(root);
        while (!stk.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
            }
        return result;
    }
    
     vector<int> inoderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> result;
        TreeNode* cur = root;
        
        while (cur != nullptr || !stk.empty()) {
            if (cur != nullptr) {
                stk.push(cur)
                cur = cur->left;
                } else {
                    cur =  stk.top();
                    stk.pop();
                    result.push_back(cur->val);
                    cur = cur->right;
                }
        }
        
```  
#### 层序遍历  : 利用队列先进先出 
```
        vector<vector<int>> leverlTraversal(TreeNode* root) {
            queue<TreeNode*> que;
            vector<vector<int>> result;
            if (root != nullptr) que.push(root);
            while(!que.empty()) {
                int size = que.size();
                vector<int> vec;
                for (int i = 0; i < size(); i++ ) {
                    TreeNode* node = que.front();
                    que.pop();
                    vec.push_back(node->val);
                    if (node->left) que.push(node->left);
                    if (node->right) que.push(node->right);
                }
                result.push_back(vec);
            }
            return result;
    }

```
#### 199.二叉树的右视图

#### 637.二叉树的层平均值

#### 429.N叉树的层序遍历

#### 116.填充每个节点的下一个右侧节点指针
