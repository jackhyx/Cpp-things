```
    vector<int> preoderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> result;
        if (root == nullptr) return result;
        st.push(root);
        while (!stk.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
            }
        return result;
    }
    
     vector<int> inoderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> result;
        TreeNode* cur = root;
        
        while (cur != nullptr || !stk.empty()) {
            if (cur != nullptr) {
                stk.push(cur)
                cur = cur->left;
                } else {
                    cur =  stk.top();
                    stk.pop();
                    result.push_back(cur->val);
                    cur = cur->right;
                }
        }
        
```  
#### 814. 二叉树剪枝
给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。
返回移除了所有不包含 1 的子树的原二叉树。
节点 node 的子树为 node 本身加上所有 node 的后代。

```c++
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {        
        if (!root)   
            return root;
        stack<TreeNode*> st;
        TreeNode* cur = root,* prenode;
        while (cur || !st.empty()) {
            while (cur) {
                st.push(cur);
                cur = cur->left;
            }
            cur = st.top();
            st.pop();
            if (!cur->right || prenode == cur->right) {
                if (cur->left && cur->left->val == 0 && !cur->left->left && !cur->left->right) {
                    delete cur->left;
                    cur->left = nullptr;
                }
                if (cur->right && cur->right->val == 0 && !cur->right->left && !cur->right->right) {
                    delete cur->right;
                    cur->right=nullptr;
                }
                prenode = cur;
                cur = nullptr;
            }
            else {
                st.push(cur);
                cur = cur->right;
            }       
                  
        }
        return root->val == 0 && !root->left && !root->right ? nullptr : root;
    }
};
```
#### 层序遍历  : 利用队列先进先出 
```c++
    vector<vector<int>> leverlTraversal(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> result;
        if (root != nullptr) que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++ ) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }

    vector<vector<int>> leverlTraversal(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> result;
        if (root != nullptr) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }   

```
#### 剑指 Offer II 043. 往完全二叉树添加节点
完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。
设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：
CBTInserter(TreeNode root) 使用根节点为 root 的给定树初始化该数据结构；
CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；
CBTInserter.get_root() 将返回树的根节点。
```c++
class CBTInserter {
public:
    TreeNode* root;
    
    CBTInserter(TreeNode* _root) {
        root = _root;
    }
    


    int insert(int val) {
        queue<TreeNode*> q;
        q.push(root);
            while (true) {
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                TreeNode* front = q.front();
                q.pop();
                if (front->left) {
                    q.push(front->left);
                } else {
                    front->left = new TreeNode(val);
                    return front->val;
                }
                if (front->right) {
                    q.push(front->right);
                } else {
                    front->right = new TreeNode(val);
                    return front->val;
                }
            }
            
        }
        return -1;
    }
    
    TreeNode* get_root() {
        return root;
    }
};

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter* obj = new CBTInserter(root);
 * int param_1 = obj->insert(val);
 * TreeNode* param_2 = obj->get_root();
 */

```
数组存放
```c++
class CBTInserter {
private:
    vector<TreeNode*> a;
public:
    CBTInserter(TreeNode* root) {  // 初始二叉树，按照层次遍历的方式存入数组
        queue<TreeNode*> q;
        q.push(root);
        while (q.size()) {
            TreeNode* p = q.front();
            q.pop();
            a.push_back(p);
            if (p->left)
                q.push(p->left);
            if (p->right)
                q.push(p->right);
        }
    }
    
    int insert(int val) {
        TreeNode* thisNode = new TreeNode(val);  // 新节点
        a.push_back(thisNode);
        int th = a.size();  // 新节点的编号
        TreeNode* father = a[th / 2 - 1];  // 父节点的编号 = 新节点的编号 / 2  ；-1是因为数组中下标从0开始而二叉树节点从1开始编号
        if (th % 2) {  // 奇数说明是左节点
            father->right = thisNode;
        }
        else {
            father->left = thisNode;
        }
        return father->val;
    }
    
    TreeNode* get_root() {
        return a[0];  // 根就是数组中的第一个节点
    }
};
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class CBTInserter {
    vector<TreeNode*>vec;
public:
    CBTInserter(TreeNode* root) {
        queue<TreeNode*>q; //用层序遍历初始化数组 
        q.push(root);
        while(!q.empty())
        {
            int n = q.size();
            for(int i = 0; i < n; i++)
            {
                TreeNode* temp = q.front();
                q.pop();
                vec.push_back(temp);
                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right); 
            }
        }
    }
    
    int insert(int val) {
        int n = vec.size() + 1;
        TreeNode* temp = new TreeNode;
        temp->val = val;
        temp->left = temp->right = NULL;
        n % 2 ? vec[n / 2 - 1]->right = temp : vec[n / 2 - 1]->left = temp;
        vec.push_back(temp);
        return vec[n / 2 - 1]->val;
    }
    
    TreeNode* get_root() {
        return vec[0];
    }
};

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter* obj = new CBTInserter(root);
 * int param_1 = obj->insert(val);
 * TreeNode* param_2 = obj->get_root();
 */

```
#### 199. 二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode *node = que.front();
                que.pop();
                if (i == (size - 1)) result.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

#### 637.二叉树的层平均值
```c++
    class Solution {
    public:
        vector<double> averageOfLevels(TreeNode* root) {
            queue<TreeNode*> que;
            vector<double> result;
            if (root != nullptr) que.push(root);
            while(!que.empty()) {
                int size = que.size();
                double sum = 0;
                for (int i = 0; i < size; i++) {
                    TreeNode* node = que.front();
                    que.pop();
                    sum += node->val;
                    if (node->left) que.push(node->left);
                    if (node->right) que.push(node->right);
                }
                result.push_back(sum / size);
            }
            return result;
        }
    };
```
#### 429.N叉树的层序遍历
```c++

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        vector<vector<int>> result;
        if (root != nullptr) que.push(root);
        while(!que.empty()) {
            vector<int> vec;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                Node* node = que.front();
                que.pop();
                vec.push_back(node->val);
                for (int i = 0; i < node->children.size(); i++) {
                    if (node->children[i]) que.push(node->children[i]);
                }
            }
            result.push_back(vec); 
        }
        return result;
    }
};
```
#### 515. 在每个树行中找最大值
给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。
示例1：
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
示例2：
提示：
二叉树的节点个数的范围是 [0,104]
-231 <= Node.val <= 231 - 1
```c++
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            int maxValue = 0;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = max(maxValue, node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue);
        }
        return result;
    }
};
```
#### 116.填充每个节点的下一个右侧节点指针
```c++
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != nullptr) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    nodePre = que.front();
                    que.pop();
                    node = nodePre;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node;
                    nodePre = nodePre ->next;
                    }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = nullptr;
        }
        return root;
    }

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != nullptr) que.push(root);
        while(!que.empty()) {
            Node* nodePre;
            Node* node;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    node = que.front();
                    que.pop();
                    nodePre = node;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node;
                    nodePre = nodePre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = nullptr;
        }
        return root;
    }
};    
    
    
    
```
#### 117.填充每个节点的下一个右侧节点指针II
思路：
这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道

#### 104. 二叉树的最大深度
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<int> que;
        int depth = 0;
        if (root != nullptr) que.push(root);
        while(!que.empty()) {
            depth ++;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right)que.push(node->right);
            }
        }
        return depth;
    }
};
```
#### 111. 二叉树的最小深度
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。
·············································································································································
#### 递归
#### 226.翻转二叉树
```
// 后序遍历
    TreeNode* invertTree(TreeNode* root) {

        if (root == nullptr) return nullptr;

        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);

        root->right = left;
        root->left = right;
        return root;

    }
```
#### 101.对称二叉树
```
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right == nullptr) return true;
        else if ((left != nullptr && right == nullptr) || (left == nullptr && right != nullptr)) return false;
        else if (left->val != right->val) return false;
        else return compare(left->left, right->right) && compare(left->right, right->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return compare(root->left, root->right);
    }
};
```

