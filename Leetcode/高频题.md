### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:

输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<int, int> umap;
        int res = 0;
        for(int i = 0, j = 0; i < s.size(); i++) {
            umap[s[i] - 'a']++;
            while(umap[s[i] - 'a'] > 1) {
                umap[s[j] - 'a']--;
                j++;
            } 
            res = max(res, i - j + 1);
        }
        return res;
    }
};
```
#### 25. K 个一组翻转链表
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```c++
class Solution {
    ListNode* reverse(ListNode* a, ListNode* b) {
        ListNode* cur = a;
        ListNode* pre = nullptr;
        ListNode* next = a;

        while(cur != b ) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (head == nullptr) return nullptr;
        ListNode* a = head;
        ListNode* b = head;
        for (int i = 0; i < k; i++) {
            if (b == nullptr) return head;
            b = b->next;
        }
        ListNode* newHead = reverse(a, b);
        a->next = reverseKGroup(b, k);
        return newHead;
    }
};
```
#### 206. 反转链表
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
* 迭代
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head ->next) {
            return head;
        }
        ListNode *newHead =  reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```
* 递归
```c++

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head ->next) {
            return head;
        }
        ListNode *newHead =  reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```
#### 215. 数组中的第K个最大元素 --->>> 295. 数据流的中位数 

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
* 快速选择排序 O(N) O(logn)
```c++
class Solution {
    int rand_partion(vector<int>& nums, int l, int r) {
        int index = rand % (r - l + 1) + l;
        int pivot = nums[index];
        swap(nums[index], nums[r]);
        while(l < r) {
            while(l < r && nums[l] < pivot) l++;
            nums[r] = nums[l];
            while(l < r && nums[r] >= pivot) r--;
            nums[l] = nums[r];
        }
        nums[l] = pivot;
        return l;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0;
        int right = nums.size() -1;
        k = nums.size() - k;
        while(1) {
            int index = rand_partion(nums, left, right);
            if(index = k) return nums[index];
            else if(index < k) {
                l = index + 1;
            } esle r = index - 1;
        }
    }
};
```
```c++
class Solution {
    int random_partion(vector<int> &nums, int l, int r) {
    int index = rand() % (r - l + 1) + l;
    swap(nums[l], nums[index]);
    int pivot  = nums[l];
    while(l < r) {
        while(l < r && nums[r] <= pivot) r--;
        nums[l] = nums[r];
        while(l < r && nums[l] >= pivot) l++;
        nums[r] = nums[l];
    }
    nums[l] = pivot;
    return l;
}
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        int l = 0, r = nums.size() - 1;
        while(l <= r) {
            int index = random_partion(nums, l, r);
            if(index + 1 == k) return nums[index];
            else if(index + 1 < k) l = index + 1;
            else r = index - 1;
        }
        return 0;
    } 
};
```
* 堆排序
```c++
class Solution {
    void maxHeapify(vector<int>& nums, int i, int n) {
        while (i * 2 + 1 < n) {
            int lSon = 2 * i + 1, rSon = 2 * i + 2;
            int large = i;
            if (lSon < n && nums[lSon] > nums[i]) large = lSon;
            if (rSon < n && nums[rSon] > nums[large]) large = rSon;
            
            if (large != i) {
                swap(nums[i], nums[large]);
                i = large;
            } else break;
        }
    }

    void buildMaxHeap(vector<int>& nums, int n) {
        for (int i = (n - 1) / 2; i >= 0; --i) {
            maxHeapify(nums, i, n);
        }
    }

public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        // 建立大根堆
        buildMaxHeap(nums, n);
        for (int i = n - 1; i >= n - k && i >= 1; --i) {
            swap(nums[0], nums[i]);
            --n;
            maxHeapify(nums, 0, n);
        }
        return nums[nums.size() - k];  
    }
};
class Solution {
public:
    void maxHeapify(vector<int>& a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a[i], a[largest]);
            maxHeapify(a, largest, heapSize);
        }
    }

    void buildMaxHeap(vector<int>& a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapSize = nums.size();
        buildMaxHeap(nums, heapSize);
        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
            swap(nums[0], nums[i]);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
};


```
### 15. 三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) return result;
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right --;
                } else if (nums[i] + nums[left] + nums[right] < 0){
                    left ++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while (right > left && nums[right] == nums[right - 1]) right --;
                    while (right > left && nums[left] == nums[left + 1]) left --;
                    right --;
                    left ++;
                }
            }
        }
        return result;
    }
};
```
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] > 0) return 0;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.size() - 1;
            while(left < right) {
                if(left < rigth && nums[left] + nums[right] + nums[i] < 0) left ++;
                else if(left < rigth && nums[left] + nums[right] + nums[i] > 0) right--;
                else {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    while(left < right && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
};
```
#### 103. 二叉树的锯齿形层序遍历 *** 
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        int flag = 1;
        while(!que.empty()) {
         int size = que.size();
         vector<int> vec(size);
         
         for (int i = 0; i < size; i++) {
             TreeNode* node = que.front();
             que.pop();

             if (flag % 2) vec[i] = node->val;
             else vec[size - 1- i] = node->val;

             if(node->left) que.push(node->left);
             if(node->right) que.push(node->right);

         }
         result.push_back(vec);
         flag++;

     }
     return result;

    }
};
```
#### 121. 买卖股票的最佳时机
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
* O(N) O(N)
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int> (2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```
* O(N) O(1)
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int> (2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1] , dp[(i - 1) % 2][0] + prices[i]);
        }
        return dp[(prices.size() - 1) % 2][1];
    }
};
```
* 贪心
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        int minVal = INT_MAX;
        int maxPro = 0;
        for(int i = 0; i < prices.size(); i++) {
            minVal = min(prices[i], minVal);
            maxPro = max(prices[i] - minVal, maxPro);
        }
        return maxPro;
    }
};
```
#### #### 236. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root; // 在相同子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != nullptr && right != nullptr) return root;
        if (left == nullptr) return right;
        else return left;
    }
};
```
* 栈实现
```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        stack<TreeNode*> stk;
        if (root) stk.push(root);
        while (!stk.empty()) {
            root = stk.top(); stk.pop();
            if (root) {
                stk.push(root);
                stk.push(nullptr);
                if (root->right) stk.push(root->right);
                if (root->left) stk.push(root->left);
            } else {
                root = stk.top(); stk.pop();
                if ((root->left == p &&root->right == q) ||
                    (root->left == q && root->right == p)) return root;
                if (root == p && (root->left == q || root->right == q)) return root;
                if (root == q &&(root->left == p || root->right == p)) return root;
                if (root->left == p || root->right == p) p = root;
                if (root->left == q || root->right == q) q = root;
            }
        }
        return nullptr;
    }
};
```
### 42. 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
* 单调栈
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int sum = 0;
        st.push(0);
        for(int i = 1; i < height.size(); i++) {
            while(!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if(!st.empty()) {
                    int h = min(height[i], height[st.top()]) - height[mid];
                    int w = i - st.top() - 1;
                    sum += h * w;
                }
                
            }
            st.push(i);
        }
        return sum;
    }
};
```
* 双指针
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        while(left < right) {
            leftMax = max(height[left], leftMax);
            rightMax = max(height[right], rightMax);
            if(leftMax < rightMax) {
                ans += leftMax - height[left];
                left++;
            } else {
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
};
```
* 动态规划
#### 200. 岛屿数量 DFS + BFS + 并查集
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
* DFS 修改原数组
```c++
class Solution {
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0|| i >= m || j >= n) return;
        if (grid[i][j] == '0') {
            return ;
        }
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
public:
    int numIslands(vector<vector<char>>& grid) {
       int m = grid.size(), n = grid[0].size();
       int res = 0;
       for(int i = 0; i < m; i++) {
           for(int j = 0; j < n; j++) {
               if(grid[i][j] == '1') {
                   res++;
                   dfs(grid, i, j);
               }
           }
       }  
       return res;
    }
};
```
* DFS 不修改原数组
```c++
class Solution {
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0|| i >= m||j >= n) return ;
        if (grid[i][j] == '0') return ;
        if(visited[i][j]) return ;
        visited[i][j] = true;
        dfs(grid, visited, i + 1, j);
        dfs(grid, visited, i - 1, j);
        dfs(grid, visited, i, j + 1);
        dfs(grid, visited, i, j - 1);
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        int res = 0;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == '1' && visited[i][j] == false) {
                    dfs(grid, visited, i, j);
                    res ++;
                }
                visited[i][j] = true; 
            }
        }
        return res;
    }
};   
```
#### 33. 搜索旋转排序数组
整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(n == 1) return nums[0] == target ? 0 : -1;
        int left = 0, right = n - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[left] <= nums[mid]) {
                if(nums[left] <= nums[mid] && target < nums[mid]) right = mid - 1;
                else left = mid + 1;
            } else {
                if(nums[mid] < target && target <= nums[right]) left = mid + 1;
                else right = mid - 1;
            }
        }
        return -1;
    }
};
```
#### 160. 相交链表
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
    }
};
```
#### 1. 两数之和 哈希表 排序 + 双指针
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。
```c++

```
#### 54. 螺旋矩阵
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        if (matrix.empty()) return ans;

        int u = 0;
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(1) {
        for (int i = l; i <= r; ++i) ans.push_back(matrix[u][i]);
        if (++u > d) break;
        for (int i = u; i <= d; ++i) ans.push_back(matrix[i][r]);
        if (--r < l) break;
        for (int i = r; i >= l; --i) ans.push_back(matrix[d][i]);
        if (--d < u) break;
        for (int i = d; i >= u; --i) ans.push_back(matrix[i][l]);
        if (++l > r) break;
        }
        return ans;
    }
};
```
59. 螺旋矩阵 II 填充模拟
给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> ans(n, vector<int> (n, 0));
        int u = 0;
        int d = n - 1;
        int l = 0;
        int r = n - 1;
        int k = 1;
        while(k <= n * n) {
            for(int i = l; i <= r; ++i) ans[u][i] = k++;
            ++u;
            for(int i = u; i <= d; ++i) ans[i][r] = k++;
            --r;
            for(int i = r; i >= l; --i) ans[d][i] = k++;
            --d;
            for(int i = d; i >= u; --i) ans[i][l] = k++;
            ++l;
        }
        return ans;
    }
};
```
#### 53. 最大子数组和 * DP * 贪心 * 分治->线段树
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        
    }
};
```
#### 5. 最长回文子串 DP 中心扩展/双指针 ->647. 回文子串->516. 最长回文子序列
给你一个字符串 s，找到 s 中最长的回文子串。
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int maxLenth = 0, left = 0, right = 0;
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false)) ;
        for(int i = s.size() - 1; i >= 0; i--) {
            for(int j = i; j < s.size(); j++) {
                if(s[i] == s[j]) {
                    if(j - i <= 1) {
                        dp[i][j] = true;
                    } else if(dp[i + 1] == dp[j - 1]) {
                        dp[i][j] = true;
                    }
                }
                if(dp[i][j] && j - i + 1 > maxLenth) {
                    maxLenth = j - i + 1;
                    left = i;
                    right = j;
                }
            }
        }
        return s.substr(left, maxLenth);
    }
};
```
```c++
class Solution {
    int left = 0, right = 0, maxLen = 0;
    void extend(string s, int i, int j, int n) {
        while(i >= 0 && j < n &&s[i] == s[j]) {
            if(j - i + 1 > maxLen) {
                left = i;
                right = j;
                maxLen = j - i + 1;
            }
            i--;
            j++;
        }
    }
public:
    string longestPalindrome(string s) {
        for(int i = 0; i < s.size(); i++) {
            extend(s, i, i, s.size());
            extend(s, i, i + 1, s.size());
        }
        return s.substr(left, maxLen);
    }
};
```
### 46. 全排列 回溯 * 迭代 * 优化空间
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {

    }
};
```
```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res(1);
        vector<int> tmp;

        for (auto i : nums) {
            for (int j = res.size()-1; j >= 0; --j) {
                for (int k = 0; k < res[j].size(); ++k) {
                    tmp = res[j];
                    tmp.insert(tmp.begin()+k, 1, i);
                    res.emplace_back(tmp);
                }
                res[j].emplace_back(i);
            }
        }
        return res;
    }
};
```
#### 23. 合并K个升序链表
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

    }
};
```
#### 31. 下一个排列
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while(i >= 0 && nums[i] >= nums[i + 1]) i--;
        if(i >= 0) {
            int j = nums.size() - 1;
            while(j >= 0 && nums[i] >= nums[j]) j--;
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```
### 300. 最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> top(n);
        int piles = 0;
        for(int i = 0; i < n; i++) {
            int left = 0, right = piles;
            int poker = nums[i];
            while(left < right) {
                int mid = left + (right - left) / 2;
                if(top[mid] >= poker) right = mid;
                else left = mid - 1;
            }
            if(left == piles) piles ++;
            top[left] = poker;
        }
        return piles;
    }
};
```
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for(int i = 1; i < nums.size(); i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1);
            }
            result = max(result, dp[i]);
        }
        return result;
    }
};
```
#### 199. 二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {

    }
};
```
#### 20. 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
```c++
class Solution {
public:
    bool isValid(string s) {

    }
};
```
#### 102. 二叉树的层序遍历
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        
    }
};
```
#### 143. 重排链表
给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```c++
class Solution {
    ListNode *reverse(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while(cur) {
            ListNode *next =cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    ListNode *middle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
    void merge(ListNode *l1, ListNode *l2) {
        ListNode *temp1;
        ListNode *temp2;
        while(l1 && l2) {
            temp1 = l1->next;
            temp2 = l2->next;
            
            l1->next = l2;
            l1 = temp1;
            
            l2->next = l1;
            l2 = temp2;
        }
    }
public:
    void reorderList(ListNode* head) {
       ListNode *l1 = head;
       ListNode *mid = middle(head);
       ListNode *l2 = mid->next;
       mid->next = nullptr;
       l2 = reverse(l2);
       merge(l1, l2);
    }
};
```
#### 88. 合并两个有序数组 双指针逆序
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```c
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        
    }
};
```
#### 41. 缺失的第一个正数
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
```c
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {

    }
};
```
#### 124. 二叉树中的最大路径和 递归--> 输出路径
路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
示例 1：

输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```c
class Solution {
public:
    int maxPathSum(TreeNode*root) {
        
    }
};

```

#### 141. 环形链表 -> 环形链表Ⅱ ->环中的节点数
给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
```c
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
            if(slow == fast) return true;
        }
        return false;
    }
};
```
#### 92. 反转链表 II
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
示例 1：
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```c
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* pre = dummy;
        for(int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }
        ListNode* cur = pre->next;
        ListNode* next = cur->next;
        for(int i = 0; i < right - left; i++) {
            cur->next = next->next;
            next->next = pre->next;
            pre->next = next;
        }
        return dummy->next;
    }
};
```
#### 148. 排序链表***  快排-->最常规的递归版归并排序-->迭代版归并排序
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

示例 1：
输入：head = [4,2,1,3]
输出：[1,2,3,4]
### 56. 合并区间
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> result;
        for(int i = 0; i < intervals.size(); i++) {
            int t = intervals[i][1];
            int j = i + 1;
            while(j < intervals.size() && intervals[j][0] <= t) {
                t = max(t, intervals[j][1]);
                j++;
            }
            result.push_back({intervals[i][0], t});
            i = j;
        }
        return result;
    }
};
```
#### 129. 求根节点到叶节点数字之和 *回溯 LC112、LC113、LC129、LC437 BFS
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。
```c++
class Solution {
public:
    int sumNumbers(TreeNode* root) {

    }
};
```
#### 105. 从前序与中序遍历序列构造二叉树
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {

    }
};
```
#### 22. 括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```c++

```
#### 69. x 的平方根
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

 
```c++

```
#### 165. 比较版本号
给你两个版本号 version1 和 version2 ，请你比较它们。
版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。
返回规则如下：
如果 version1 > version2 返回 1，
如果 version1 < version2 返回 -1，
除此之外返回 0。

示例 1：

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"
示例 2：

输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有指定下标为 2 的修订号，即视为 "0"
```c++
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int m = version1.size(), n = version2.size();
        int i = 0, j = 0;
        while(i < m || j < n) {
            int a = 0, b = 0;
            while(i < m && version1[i] != '.') a = a * 10 +(version1[i++] - '0');
            while(j < n && version2[j] != '.') b = b * 10 + (version2[j++] - '0');
            if(a > b) return 1;
            else if(a < b) return -1;
            i++;
            j++;
        }
        return 0;
    }
};
```
#### 101. 对称二叉树 ***
给你一个二叉树的根节点 root ， 检查它是否轴对称。
```c++
class Solution {
    bool compare(TreeNode* leftNode, TreeNode* rightNode) {
        if(!leftNode && rightNode) return false;
        else if(leftNode && !rightNode) return false;
        else if(!leftNode && !rightNode) return true;
        else if(leftNode->val != rightNode->val) return false;
        return compare(leftNode->left, rightNode->right) && compare(leftNode->right, rightNode->left);
    }
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;
        return compare(root->left, root->right)
    }
};
```
#### 94. 二叉树的中序遍历
给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while(cur || !st.empty()) {
            if(cur) {
                st.push(cur);
                cur = cur->left;
            } else {
                cur = st.top();
                st.pop();
                result.push_back(cur->val);
                cur = cur->right;
            }
        }
        return result;
    }
};
```
#### 32. 最长有效括号 栈 & DP * 双指针
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        st.push(-1);
        int res = 0;
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '(') st.push(i);
            else {
                st.pop();
                if(!st.empty()) {
                    res = max(res, i - st.top());
                } else st.push(i);
            }
        }
        return res;
    }
};
```

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int res = 0;
        vector<int> dp(s.size(), 0);
        for(int i = 1; i < s.size(); i++) {
            if(s[i] == ')') {
                if(s[i - 1] == '(') {
                    dp[i] = (i >= 2 > dp[i - 2] : 0) + 2;
                } else if(i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```
#### 142. 环形链表 II
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
不允许修改 链表。
```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        
    }
};
```
#### 221. 最大正方形 * DP
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
dp(i,j) 表示以 (i, j)为右下角，且只包含 1 的正方形的边长最大值
```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        
    }
};
```
#### 4. 寻找两个正序数组的中位数
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。
示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

    }
};
```
#### 76. 最小覆盖子串
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> sump, tump;
        string res = "";
        int count = 0;
        for(auto & c : t) tump[c]++;
        
        for(int i = 0, j = 0; i < s.size(); i++) {
            sump[s[i]]++;
            if(sump[s[i]] <= tump[s[i]]) count++;
            while(sump[s[j]] > tump[s[j]]) sump[s[j++]]--;
            if(count == t.size()) {
                if(res.empty() || (i - j + 1) < res.size()) {
                    res = s.substr(j, i - j + 1);
                }
            }
        }
        return res;
    }
};
```
#### 232. 用栈实现队列
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
```c++
class MyQueue {
public:
    MyQueue() {

    }
    
    void push(int x) {

    }
    
    int pop() {

    }
    
    int peek() {

    }
    
    bool empty() {

    }
};
```
#### 98. 验证二叉搜索树 * 中序保存数组判断有序 & 递归 & 迭代
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1：
输入：root = [2,1,3]
输出：true
```c++
class Solution {
    vector<int> vec;
    void traverse(TreeNode* root) {
        if(root == nullptr) return ;
        traverse(root->left);
        vec.push_back(root->val);
        traverse(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        vec.clear();
        traverse(root);
        for(int i = 1; i < vec.size(); i++) {
            if(vec[i] <= vec[i - 1] )return false;
        }
        returen true;
    }
};
```
* 递归
```c++
class Solution {
public:
    TreeNode* pre = nullptr;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        bool leftNode = isValidBST(root->left);
        if(pre && pre->val >= root->val) return false;
        pre = root;
        bool rightNode = isValidBST(root->right);
        return leftNode && rightNode;
    }
};
```
* 迭代
```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = nullptr;
        while(!cur || st.empty()) {
            if(cur ) {
                st.push(cur);
                cur = cur->right;
            } else {
                cur = st.top();
                st.pop();
                if(cur->val <= pre->val) return false;
                pre = cur;
                cur = cur->right;
            }
        }
        return true;
    }
};
```
#### 82. 删除排序链表中的重复元素 II ***递归 & 迭代
给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。
示例 1：

输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) 
            return head;
        
        if (head->next && head->val == head->next->val) {
            while (head->next && head->val == head->next->val) {
                head = head->next;
            }
            return deleteDuplicates(head->next);
        } else {
            head->next = deleteDuplicates(head->next);
        }
        
        return head;
    }
};
```
```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode *cur = head;
        ListNode *pre = dummy;
        while(cur && cur->next) {
            if(cur->val == cur->next->val) {
                while(cur->next && cur->val == cur->next->val) {
                    cur = cur->next;
                }
                pre->next = cur->next;
                cur = cur->next;
            } else {
                pre = cur;
                cur = cur->next;
            }
        }
        return dummy->next;
    }
};
```
#### 162. 寻找峰值
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
};
```
#### 39. 组合总和
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 target 的不同组合数少于 150 个。
```c++
class Solution {
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int> &candidates, int target, int sum, int index) {
        if(sum > target) return;
        if(sum == target) {
            result.push_back(path);
            return ;
        }
        for(int i = index; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            path.pop_back();
            sum -= candidates[i];
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        path.clear();
        result.clear();
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```
#### 112. 路径总和
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
叶子节点 是指没有子节点的节点。
```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        
    }
};
```
#### 113. 路径总和 II
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点
```c++
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        
    }
};
```
#### 322. 零钱兑换
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
```c++

```
#### 70. 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 1)return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++) {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```
```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```
#### 93. 复原 IP 地址
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
```c++
class Solution {
    vector<string> result;
    void backtracking(string &s, int start, int pointNum) {
        if(pointNum == 3) {
            if(isValid(s, start, s.size() - 1)) {
                result.push_back(s);
            }
            return ;
        }
        for(int i = start; i < s.size(); i++) {
            if(isValid(s, start, i)) {
                s.insert(s.begin() + i + 1, '.');
                pointNum ++;
                backtracking(s, i + 2, pointNum);
                pointNum--;
                s.erase(s.begin() + i + 1);
            } else break;
        }
    }
    bool isValid(string &s, int start, int end) {
        if(strat > end) return false;
        if(s[start] == '0' && start != end)  return false;
        int sum = 0;
        for(int i = start; i <= end; i++) {
            if(s[i] > '9' || s[i] < '0')  return fasle;
            sum = sum * 10 + (s[i] - '0');
            if(sum >255) return false;
        }
        return true;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        backtracking(s, 0, 0);
        return result;
    }
};
```
#### 19. 删除链表的倒数第 N 个结点 mid  <——剑指 Offer 22. 链表中倒数第k个节点 easy
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

### 209. 长度最小的子数组 -->560 862
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
       
    }
};
```
#### 394. 字符串解码
给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"
```c++
class Solution {
public:
    string decodeString(string s) {

    }
};
```
#### 78. 子集 回溯 
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
       
    }
};
```
#### 239. 滑动窗口最大值  单调队列
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。
```c++
class Solution {
    class MyQue {
        public:
        deque<int> que;
        void pop(int value) {
            if(!que.empty() && que.front() == value) {
                que.pop_front();
            }
        }
        void push(int value) {
            while(!que.empty() && que.back() < value) {
                que.pop_back();
            }
            que.push_back(value);
        }
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        MyQue que;
        for(int i = 0; i < k; i++) {
            que.push(nums[i]);
        }
        result.push_back(que.front());
        for(int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            result.push_back(que.front());
        }
        return result;
    }
};
```
#### 122. 买卖股票的最佳时机 II
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        vector<vector<int>> dp(2, vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < n; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i ]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], dp[(i - 1) % 2][0] + prices[i ]);
        }
        return dp[(n - 1)% 2][1];
    }
};
```
#### 662. 二叉树最大宽度 题挺好 但是不太熟悉 DFS + BFS(层序遍历)
给你一棵二叉树的根节点 root ，返回树的 最大宽度 。
树的 最大宽度 是所有层中最大的 宽度 。
每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。
题目数据保证答案将会在  32 位 带符号整数范围内。

示例 1：
输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
```c++
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        
};
```
#### 470. 用 Rand7() 实现 Rand10()
```c++

class Solution {
public:
    int rand10() {
        while(true) {
        int num = (rand7() - 1) * 7 + rand7();
        if(num <= 40) 
        return num % 10 + 1;
        }
    }
};
```
```c++
    int rand10() {
        while(true) {
            int a = rand7();
            int b = rand7();
            int num = (a-1)*7 + b; // rand 49
            if(num <= 40) return num % 10 + 1; // 拒绝采样
            
            a = num - 40; // rand 9
            b = rand7();
            num = (a-1)*7 + b; // rand 63
            if(num <= 60) return num % 10 + 1;
            
            a = num - 60; // rand 3
            b = rand7();
            num = (a-1)*7 + b; // rand 21
            if(num <= 20) return num % 10 + 1;
        }
    }
```
(randX() - 1)*Y + randY() 可以等概率的生成[1, X * Y]范围的随机数
### 用 Rand3() 实现 Rand18()
```c++
    int rand18() { 
        int res; 
        while(true){ 
            res = (rand9() - 1) * 9 + rand9();
            if( res <= 72 ) break; 
        }
    }    
        return res % 18 + 1; 
    } 
    int rand9() {
    return ( rand3() - 1 ) * 3 + rand3(); 
}
```
### 1143. 最长公共子序列 dp
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
#### #### 64. 最小路径和 dp
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
#### 198. 打家劫舍 dp
198. 打家劫舍
     你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。

```c++
    class Solution {
    public:
        int rob(vector<int>& nums) {
            int n = nums.size();
            if(n == 0) return 0;
            if(n == 1) return nums[0];
            vector<int> dp(n, 0);
            
            dp[0] = nums[0];
            dp[1] = max(nums[0], nums[1]);
            for(int i = 2; i < n; i++) {
                dp[i] = max(dp[i - 2] + nums[i] + dp[i - 1]);
            }
            return dp[n];
        }
};
```
#### 958. 二叉树的完全性检验
给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。

在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 1 到 2h 节点之间的最后一级 h 。
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
// 第一次遇到 null 时 end 变成 true，如果之后的所有节点都是 null，则说明是完全二叉树
// end 为 true 时遇到非空节点说明不是完全二叉树
class Solution {
public:
	bool isCompleteTree(TreeNode* root) {
		
	}
};

```
#### 79. 单词搜索
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
```c++
class Solution {
public:

    bool backtrack(vector<vector<char>>& board, vector<vector<int>>& map ,string word, int i, int j, int index){
        
        if(i<0 || i==board.size() || j < 0 || j==board[0].size() || map[i][j] || board[i][j] != word[index]) return false;
        
        if(index == word.size()-1 && word[index] == board[i][j])    return true;
        

        map[i][j] = 1;
        if (backtrack(board, map, word, i, j-1, index+1) || 
            backtrack(board, map, word, i-1, j, index+1) || 
            backtrack(board, map, word, i, j+1, index+1) || 
            backtrack(board, map, word, i+1, j, index+1)) return true;
        map[i][j] = 0;
        return false;
    }

    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<int>> map(board.size(), vector<int>(board[0].size(), 0));
        for(int i = 0 ; i < board.size(); i++ ){
            for(int j = 0; j < board[0].size(); j++){
                if(board[i][j] != word[0])  continue;
                if(backtrack(board, map, word, i, j, 0))   return true;
            }
        }
        return false;
    }
};
```
#### 69. x 的平方根 * 简单版->二分
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

#### 48. 旋转图像 * 先水平转置 再对角线
给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

#### 543. 二叉树的直径 * 最大深度之和
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。


#### 16. 最接近的三数之和 排序 + 双指针
给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。
返回这三个数的和。
假定每组输入只存在恰好一个解。

示例 1：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int m = INT_MAX, res = 0;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size() - 2; ++i) {
            int left = i + 1, right = nums.size() - 1;
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == target)  return target;
                else if(sum < target) left++;
                else right --;
                if(m > abs(sum - target)) {
                    m = abs(sum - target);
                    res = sum;
                }
            }
        }
        return res;
    }
};
```
#### 74. 搜索二维矩阵
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
#### 440. 字典序的第K小数字
给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
示例 1:

输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```c++
class Solution {
public:
    int findKthNumber(int n, int k) {
        int cur = 1;
        k--;
        while(k > 0) {
            long long left = cur;
            long long right = cur + 1;
            int node_num = 0;
            while(left <= n) {
                node_num += min(right - left, n - left + 1);
                left *= 10;
                right *= 10;
            }
            if(node_num <= k) {
                k -= node_num;
                cur++;
            } else {
                k--;
                cur *= 10;
            }
        }
        return cur;
    }    
};
```
#### 43. 字符串相乘
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        int m = num1.size(), n = num2.size();
        vector<int> res(m + n, 0);
        for(int i = m - 1; i >= 0; i--) {
            for(int j = n - 1; j >= 0; j--) {
                int mul = (num1[i] - '0') * (num2[j] - '0');
                int p1 = i + j, p2 = i + j + 1;
                int sum = mul + res[p2];
                res[p2] = sum % 10;
                res[p1] += sum / 10;
            }
        }
        int i = 0;
        while(i < res.size() && res[i] == 0) i++;
        string str;
        for(; i < res.size(); i++) {
            str.push_back('0' + res[i]);
        }
        return str.size() == 0 ? "0" : str;
    }
};
```
#### 402. 移掉 K 位数字 * 单调栈
给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。
示例 1 ：

输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        string stk = "";
        for(int i = 0; i < num.size(); ++i) {
            while(!stk.empty() && k && stk.back() > num[i]) {
                stk.pop_back();
                k--;
            }
            stk.push_back(num[i]);
        }
        while(k && !stk.empty()) {
            stk.pop_back();
            k--;
        }
        int i = 0;
        while(stk[i] == '0' && i < stk.size()) i++;
        stk = stk.substr(i);
        if(stk.empty()) return "0";
        return stk;
    }
};
```
#### 440. 字典序的第K小数字
给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
示例 1:

输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```c++
class Solution {
public:
    int findKthNumber(int n, int k) {
        int cur = 1;
        k--;
        while(k > 0) {
            long long left = cur;
            long long right = cur + 1;
            int node_num = 0;
            while(left <= n) {
                node_num += min(right - left, n - left + 1);
                left *= 10;
                right *= 10;
            }
            if(node_num <= k) {
                k -= node_num;
                cur++;
            } else {
                k--;
                cur *= 10;
            }
        }
        return cur;
    }    
};
```
#### 152. 乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
测试用例的答案是一个 32-位 整数。
子数组 是数组的连续子序列。
示例 1:

输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int ans = INT_MIN;
        int maxVal = 1, minVal = 1;
        for(int i = 0; i < n; i++) {
            if(nums[i] < 0) swap(minVal, maxVal);
            maxVal = max(maxVal * nums[i], nums[i]);
            minVal = min(minVal * nums[i], nums[i]);
            ans = max(maxVal, ans);
        }
        return ans;
    }
};
```
#### 114. 二叉树展开为链表
给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
```c++
class Solution {
public:
    void flatten(TreeNode* root) {
       while(root) {
           TreeNode* node = root->left;
           if(node) {
               while(node && node->right) {
                   node = node->right;
               }
               node->right = root->right;
               root->right = root->left;
               root->left = nullptr;
           }
           root = root->right;
       }
    }
};
```
#### 687. 最长同值路径
给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。
两个节点之间的路径长度 由它们之间的边数表示。

#### 226. 翻转二叉树 * 递归 * 迭代 * 层序
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

#### 151. 反转字符串中的单词
给你一个字符串 s ，请你反转字符串中 单词 的顺序。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
```c++
class Solution {
    void removeExtraSpaces(string &s) {
        int slow = 0;
        for(int i = 0; i < s.size(); ++i) {
            if(s[i] != ' ') {
                if(slow != 0) s[slow++] = ' ';
                while(i < s.size() && s[i] != ' ') {
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow);
    }
    void reverse(string& s, int start, int end) {
        for(int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
public:
    string reverseWords(string s) {
        removeExtraSpaces(s);
        reverse(s, 0, s.size() - 1);
        int start = 0;
        for(int i = 0; i <= s.size(); ++i) {
            if(i == s.size() || s[i] == ' ') {
                reverse(s, start, i - 1);
                start = i + 1;
            }
        }
        return s;
    }
};
```
#### 739. 每日温度 * 单调栈
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

#### 11. 盛最多水的容器
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器
#### 179. 最大数
给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。
```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end(), [&](int a, int b) {
            auto str_a = to_string(a);
            auto str_b = to_string(b);
            return str_a + str_b > str_b + str_a; 
        });
        string res;
        for(auto num : nums) {
            if(num != 0 || res[0] != '0') res += to_string(num);
        }
        return res;
    }
};
```
#### 83. 删除排序链表中的重复元素
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
```c++
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode() : val(0), next(nullptr) {}
*     ListNode(int x) : val(x), next(nullptr) {}
*     ListNode(int x, ListNode *next) : val(x), next(next) {}
* };
*/
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* cur = head;
        while(cur && cur->next) {
            if(cur->val == cur->next->val) {
                ListNode* del = cur->next;
                cur->next = cur->next->next;
                delete del;
            } else {
                cur = cur->next;
            }
        }
         return head;
    }
};
```
```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        head->next = deleteDuplicates(head->next);
        if(head->val ==  head->next->val) head = head->next;
        return head;
    }
};
```
#### 剑指 Offer 36. 二叉搜索树与双向链表
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
```c++
class Solution {
   
public:
    Node* treeToDoublyList(Node* root) {
        if(!root)return nullptr;
        Node* cur = root;
        Node* head = nullptr;
        Node* pre = nullptr;
        stack<Node*> st;
        while(cur || !st.empty()) {
            if(cur) {
                st.push(cur);
                cur = cur->left;
            } else {
                cur = st.top();
                st.pop();
                if(pre) {
                    pre->right = cur;
                    cur->left = pre;
                    pre = cur;
                } else {
                    pre = cur;
                    head = pre;
                }
                cur = cur->right;
            }
        }
        pre->right = head;
        head->left = pre;
        return head;
    }
};
```
```c++
class Solution {
    Node* pre;
    Node* head;
    void dfs(Node* cur) {
        if(cur == nullptr) return;
        dfs(cur->left);
        if(pre == nullptr) head = cur;
        else pre->right = cur;
        cur->left = pre;
        pre = cur;
        dfs(cur->right);
    }
public:
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        dfs(root);
        head->left = pre;
        pre->right = head;
        return head;
    }
};
```
#### 329. 矩阵中的最长递增路径
给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。
```c++
class Solution {
    int result = -1;
    int dfs(vector<vector<int>>& matrix, int i, int j, int pre, vector<vector<int>> &memo) {
        int m = matrix.size(), n = matrix[0].size();
        if(i < 0 || j < 0 || i >= m || j >= n) return 0;
        if(matrix[i][j] <= pre) return 0;
        if(memo[i][j] != -1) return memo[i][j];
        int up = dfs(matrix, i + 1, j, matrix[i][j], memo); 
        int down = dfs(matrix, i - 1, j, matrix[i][j], memo); 
        int left = dfs(matrix, i, j + 1, matrix[i][j], memo); 
        int right = dfs(matrix, i, j - 1, matrix[i][j], memo); 
        memo[i][j] = max({up, down, left, right}) + 1;
        return memo[i][j];
    }
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> memo(m, vector<int> (n, - 1));
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(memo[i][j] == -1) {
                    int maxVal = dfs(matrix, i, j, -1, memo);
                    result = max(result, maxVal);
                } else result = max(memo[i][j], result);
            }
        }
        return result;
    }
};
``` 

#### 55. 跳跃游戏 * 贪心
```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int fastCover = 0;
        if(nums.size() == 1)return true;
        for(int i = 0; i < nums.size(); i++) {
            fastCover = max(fastCover, nums[i] + i);
            if(fastCover >= nums.size() - 1) return true;
        }
        return false;
    }
};
```
#### 207. 课程表 拓扑排序->210
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

#### 210. 课程表 II 拓扑排序
现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组

#### 34. 在排序数组中查找元素的第一个和最后一个位置 * 二分 写明白也不容易
```c++
class Solution {
    int getLeft(vector<int> nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(target <= nums[mid]) {
                right = mid - 1;
            } else left = mid + 1;
        }
        if (left == nums.size()) return -1;
        return nums[left] == target ? left : -1;
    }
    int getRight(vector<int> nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(target >= nums[mid]) {
                left = mid + 1;
            } else right = mid - 1;
        }
        if (left - 1 < 0) return -1;
        return nums[left - 1] == target ? (left - 1) : -1;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = getLeft(nums, target);
        int r = getRight(nums, target);
        return {l, r};
    }
};
```
#### 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 * 原地操作 双指針
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

#### 剑指 Offer 26. 树的子结构 双重递归 先递归以A为跟节点， B是不是为A的子结构 然后再递归A->left B->right 
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。
#### 862. 和至少为 K 的最短子数组 * 前綴和 +  单调队列
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。

子数组 是数组中 连续 的一部分。

#### 91. 解码方法
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。
```c++
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1);
        if(s[0] == '0') return 0;
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i ++) {
            if(s[i - 1] != '0') {
                dp[i] += dp[i - 1];
            }
            int val = (s[i - 2] - '0') * 10 + s[i - 1] - '0';
            if (val >= 10 && val <= 26) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
};
```
#### 252. 会议室
给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，请你判断一个人是否能够参加这里面的全部会议。
示例 1:
输入: [[0,30],[5,10],[15,20]]
输出: false
示例 2:
输入: [[7,10],[2,4]]
输出: true
给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。
示例 1:
输入: [[0, 30],[5, 10],[15, 20]]
输出: 2
示例 2:
输入: [[7,10],[2,4]]
输出: 1

```c++

```
#### 61. 旋转链表
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
```c++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head == nullptr || head->next == nullptr || k == 0) return head;
        ListNode* cur = head;
        int length = 0;
        while(cur) {
            cur = cur->next;
            length++;
        }
        if(length == 0) return head;
        k %= length;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* fast = dummy, *slow = dummy;
        for(int i = 0; i < k; i++) {
            fast =fast->next;
        }
        while(fast->next) {
            fast = fast->next;
            slow = slow->next;
        }
        fast->next = dummy->next;
        dummy->next = slow->next;
        slow->next = nullptr;
        return dummy->next;
    }
};
```
#### 71. 简化路径
#### 24. 两两交换链表中的节点
#### 295. 数据流的中位数
#### 395. 至少有 K 个重复字符的最长子串
#### 1024. 视频拼接
你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。

使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。

甚至可以对这些片段自由地再剪辑：

例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。
我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。

#### 1673. 找出最具竞争力的子序列
给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。

#### 4. 寻找两个正序数组的中位数
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。
#### 25. K 个一组翻转链表
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
#### 面试题 17.19. 消失的两个数字
给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？

以任意顺序返回这两个数字均可。
#### 672. 灯泡开关 Ⅱ
房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。

这 4 个开关各自都具有不同的功能，其中：

开关 1 ：反转当前所有灯的状态（即开变为关，关变为开）
开关 2 ：反转编号为偶数的灯的状态（即 0, 2, 4, ...）
开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...）
开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...）
你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。

给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。
#### 460. LFU 缓存
请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

实现 LFUCache 类：

LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。
void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。
为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
#### 870. 优势洗牌
给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] > nums2[i] 的索引 i 的数目来描述。

返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。