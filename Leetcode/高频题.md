### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:

输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        
        
    }
};
```
#### 
```c++
class Solution {
    ListNode* reverse(ListNode* a, ListNode* b) {
        ListNode* cur = a;
        ListNode* pre = nullptr;
        ListNode* next = a;

        while(cur != b ) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (head == nullptr) return nullptr;
        ListNode* a = head;
        ListNode* b = head;
        for (int i = 0; i < k; i++) {
            if (b == nullptr) return head;
            b = b->next;
        }
        ListNode* newHead = reverse(a, b);
        a->next = reverseKGroup(b, k);
        return newHead;
    }
};
```
#### 206. 反转链表
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
* 迭代
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head ->next) {
            return head;
        }
        ListNode *newHead =  reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```
* 递归
```c++

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head ->next) {
            return head;
        }
        ListNode *newHead =  reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```
#### 215. 数组中的第K个最大元素 --->>> 295. 数据流的中位数 

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
* 快速选择排序 O(N) O(logn)
```c++
class Solution {
    int rand_partion(vector<int>& nums, int l, int r) {
        int index = rand % (r - l + 1) + l;
        int pivot = nums[index];
        swap(nums[index], nums[r]);
        while(l < r) {
            while(l < r && nums[l] < pivot) l++;
            nums[r] = nums[l];
            while(l < r && nums[r] >= pivot) r--;
            nums[l] = nums[r];
        }
        nums[l] = pivot;
        return l;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0;
        int right = nums.size() -1;
        k = nums.size() - k;
        while(1) {
            int index = rand_partion(nums, left, right);
            if(index = k) return nums[index];
            else if(index < k) {
                l = index + 1;
            } esle r = index - 1;
        }
    }
};
```
* 堆排序
```c++
class Solution {
    void maxHeapify(vector<int>& nums, int i, int n) {
        while (i * 2 + 1 < n) {
            int lSon = 2 * i + 1, rSon = 2 * i + 2;
            int large = i;
            if (lSon < n && nums[lSon] > nums[i]) large = lSon;
            if (rSon < n && nums[rSon] > nums[large]) large = rSon;
            
            if (large != i) {
                swap(nums[i], nums[large]);
                i = large;
            } else break;
        }
    }

    void buildMaxHeap(vector<int>& nums, int n) {
        for (int i = (n - 1) / 2; i >= 0; --i) {
            maxHeapify(nums, i, n);
        }
    }

public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        // 建立大根堆
        buildMaxHeap(nums, n);
        for (int i = n - 1; i >= n - k && i >= 1; --i) {
            swap(nums[0], nums[i]);
            --n;
            maxHeapify(nums, 0, n);
        }
        return nums[nums.size() - k];  
    }
};
class Solution {
public:
    void maxHeapify(vector<int>& a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a[i], a[largest]);
            maxHeapify(a, largest, heapSize);
        }
    }

    void buildMaxHeap(vector<int>& a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapSize = nums.size();
        buildMaxHeap(nums, heapSize);
        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
            swap(nums[0], nums[i]);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
};


```
### 15. 三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) return result;
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right --;
                } else if (nums[i] + nums[left] + nums[right] < 0){
                    left ++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while (right > left && nums[right] == nums[right - 1]) right --;
                    while (right > left && nums[left] == nums[left + 1]) left --;
                    right --;
                    left ++;
                }
            }
        }
        return result;
    }
};
```
#### 103. 二叉树的锯齿形层序遍历
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        int flag = 1;
        while(!que.empty()) {
         int size = que.size();
         vector<int> vec(size);
         
         for (int i = 0; i < size; i++) {
             TreeNode* node = que.front();
             que.pop();

             if (flag % 2) vec[i] = node->val;
             else vec[size - 1- i] = node->val;

             if(node->left) que.push(node->left);
             if(node->right) que.push(node->right);

         }
         result.push_back(vec);
         flag++;

     }
     return result;

    }
};
```
#### 121. 买卖股票的最佳时机
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
* O(N) O(N)
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int> (2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```
* O(N) O(1)
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int> (2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1] , dp[(i - 1) % 2][0] + prices[i]);
        }
        return dp[(prices.size() - 1) % 2][1];
    }
};
```
* 贪心
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        int minVal = INT_MAX;
        int maxPro = 0;
        for(int i = 0; i < prices.size(); i++) {
            minVal = min(prices[i], minVal);
            maxPro = max(prices[i] - minVal, maxPro);
        }
        return maxPro;
    }
};
```
#### #### 236. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root; // 在相同子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != nullptr && right != nullptr) return root;
        if (left == nullptr) return right;
        else return left;
    }
};
```
### 42. 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
* 单调栈
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int sum = 0;
        st.push(0);
        for(int i = 1; i < height.size(); i++) {
            while(!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if(!st.empty()) {
                    int h = min(height[i], height[st.top()]) - height[mid];
                    int w = i - st.top() - 1;
                    sum += h * w;
                }
                
            }
            st.push(i);
        }
        return sum;
    }
};
```
* 双指针
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        while(left < right) {
            leftMax = max(height[left], leftMax);
            rightMax = max(height[right], rightMax);
            if(leftMax < rightMax) {
                ans += leftMax - height[left];
                left++;
            } else {
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
};
```
* 动态规划
#### 200. 岛屿数量 DFS + BFS + 并查集
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
```c++
class Solution {
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0|| i >= m || j >= n) return;
        if (grid[i][j] == '0') {
            return ;
        }
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
public:
    int numIslands(vector<vector<char>>& grid) {
       int m = grid.size(), n = grid[0].size();
       int res = 0;
       for(int i = 0; i < m; i++) {
           for(int j = 0; j < n; j++) {
               if(grid[i][j] == '1') {
                   res++;
                   dfs(grid, i, j);
               }
           }
       }  
       return res;
    }
};
```