### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:

输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        
        
    }
};
```
#### 
```c++
class Solution {
    ListNode* reverse(ListNode* a, ListNode* b) {
        ListNode* cur = a;
        ListNode* pre = nullptr;
        ListNode* next = a;

        while(cur != b ) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (head == nullptr) return nullptr;
        ListNode* a = head;
        ListNode* b = head;
        for (int i = 0; i < k; i++) {
            if (b == nullptr) return head;
            b = b->next;
        }
        ListNode* newHead = reverse(a, b);
        a->next = reverseKGroup(b, k);
        return newHead;
    }
};
```
#### 206. 反转链表
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
* 迭代
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head ->next) {
            return head;
        }
        ListNode *newHead =  reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```
* 递归
```c++

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head ->next) {
            return head;
        }
        ListNode *newHead =  reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```
#### 215. 数组中的第K个最大元素 --->>> 295. 数据流的中位数 

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
* 快速选择排序 O(N) O(logn)
```c++
class Solution {
    int rand_partion(vector<int>& nums, int l, int r) {
        int index = rand % (r - l + 1) + l;
        int pivot = nums[index];
        swap(nums[index], nums[r]);
        while(l < r) {
            while(l < r && nums[l] < pivot) l++;
            nums[r] = nums[l];
            while(l < r && nums[r] >= pivot) r--;
            nums[l] = nums[r];
        }
        nums[l] = pivot;
        return l;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0;
        int right = nums.size() -1;
        k = nums.size() - k;
        while(1) {
            int index = rand_partion(nums, left, right);
            if(index = k) return nums[index];
            else if(index < k) {
                l = index + 1;
            } esle r = index - 1;
        }
    }
};
```
* 堆排序
```c++
class Solution {
    void maxHeapify(vector<int>& nums, int i, int n) {
        while (i * 2 + 1 < n) {
            int lSon = 2 * i + 1, rSon = 2 * i + 2;
            int large = i;
            if (lSon < n && nums[lSon] > nums[i]) large = lSon;
            if (rSon < n && nums[rSon] > nums[large]) large = rSon;
            
            if (large != i) {
                swap(nums[i], nums[large]);
                i = large;
            } else break;
        }
    }

    void buildMaxHeap(vector<int>& nums, int n) {
        for (int i = (n - 1) / 2; i >= 0; --i) {
            maxHeapify(nums, i, n);
        }
    }

public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        // 建立大根堆
        buildMaxHeap(nums, n);
        for (int i = n - 1; i >= n - k && i >= 1; --i) {
            swap(nums[0], nums[i]);
            --n;
            maxHeapify(nums, 0, n);
        }
        return nums[nums.size() - k];  
    }
};
class Solution {
public:
    void maxHeapify(vector<int>& a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a[i], a[largest]);
            maxHeapify(a, largest, heapSize);
        }
    }

    void buildMaxHeap(vector<int>& a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapSize = nums.size();
        buildMaxHeap(nums, heapSize);
        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
            swap(nums[0], nums[i]);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
};


```
### 15. 三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) return result;
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right --;
                } else if (nums[i] + nums[left] + nums[right] < 0){
                    left ++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while (right > left && nums[right] == nums[right - 1]) right --;
                    while (right > left && nums[left] == nums[left + 1]) left --;
                    right --;
                    left ++;
                }
            }
        }
        return result;
    }
};
```
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] > 0) return 0;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.size() - 1;
            while(left < right) {
                if(left < rigth && nums[left] + nums[right] + nums[i] < 0) left ++;
                else if(left < rigth && nums[left] + nums[right] + nums[i] > 0) right--;
                else {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    while(left < right && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
};
```
#### 103. 二叉树的锯齿形层序遍历
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        int flag = 1;
        while(!que.empty()) {
         int size = que.size();
         vector<int> vec(size);
         
         for (int i = 0; i < size; i++) {
             TreeNode* node = que.front();
             que.pop();

             if (flag % 2) vec[i] = node->val;
             else vec[size - 1- i] = node->val;

             if(node->left) que.push(node->left);
             if(node->right) que.push(node->right);

         }
         result.push_back(vec);
         flag++;

     }
     return result;

    }
};
```
#### 121. 买卖股票的最佳时机
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
* O(N) O(N)
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int> (2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```
* O(N) O(1)
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int> (2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1] , dp[(i - 1) % 2][0] + prices[i]);
        }
        return dp[(prices.size() - 1) % 2][1];
    }
};
```
* 贪心
```c++
class Solution {
public:
// 0 持有 1 不持有
    int maxProfit(vector<int>& prices) {
        int minVal = INT_MAX;
        int maxPro = 0;
        for(int i = 0; i < prices.size(); i++) {
            minVal = min(prices[i], minVal);
            maxPro = max(prices[i] - minVal, maxPro);
        }
        return maxPro;
    }
};
```
#### #### 236. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root; // 在相同子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != nullptr && right != nullptr) return root;
        if (left == nullptr) return right;
        else return left;
    }
};
```
### 42. 接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
* 单调栈
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int sum = 0;
        st.push(0);
        for(int i = 1; i < height.size(); i++) {
            while(!st.empty() && height[i] > height[st.top()]) {
                int mid = st.top();
                st.pop();
                if(!st.empty()) {
                    int h = min(height[i], height[st.top()]) - height[mid];
                    int w = i - st.top() - 1;
                    sum += h * w;
                }
                
            }
            st.push(i);
        }
        return sum;
    }
};
```
* 双指针
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        while(left < right) {
            leftMax = max(height[left], leftMax);
            rightMax = max(height[right], rightMax);
            if(leftMax < rightMax) {
                ans += leftMax - height[left];
                left++;
            } else {
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
};
```
* 动态规划
#### 200. 岛屿数量 DFS + BFS + 并查集
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
* DFS 修改原数组
```c++
class Solution {
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0|| i >= m || j >= n) return;
        if (grid[i][j] == '0') {
            return ;
        }
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
public:
    int numIslands(vector<vector<char>>& grid) {
       int m = grid.size(), n = grid[0].size();
       int res = 0;
       for(int i = 0; i < m; i++) {
           for(int j = 0; j < n; j++) {
               if(grid[i][j] == '1') {
                   res++;
                   dfs(grid, i, j);
               }
           }
       }  
       return res;
    }
};
```
* DFS 不修改原数组
```c++
class Solution {
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0|| i >= m||j >= n) return ;
        if (grid[i][j] == '0') return ;
        if(visited[i][j]) return ;
        visited[i][j] = true;
        dfs(grid, visited, i + 1, j);
        dfs(grid, visited, i - 1, j);
        dfs(grid, visited, i, j + 1);
        dfs(grid, visited, i, j - 1);
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        int res = 0;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == '1' && visited[i][j] == false) {
                    dfs(grid, visited, i, j);
                    res ++;
                }
                visited[i][j] = true; 
            }
        }
        return res;
    }
};   
```
#### 33. 搜索旋转排序数组
整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {

    }
};
```
#### 160. 相交链表
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
    }
};
```
#### 1. 两数之和
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
    }
};
```
#### 54. 螺旋矩阵
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

    }
};
```
#### 53. 最大子数组和 * DP * 贪心 * 分治->线段树
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        
    }
};
```
#### 5. 最长回文子串 DP 中心扩展/双指针 ->647. 回文子串->516. 最长回文子序列
给你一个字符串 s，找到 s 中最长的回文子串。
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int maxLenth = 0, left = 0, right = 0;
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false)) ;
        for(int i = s.size() - 1; i >= 0; i--) {
            for(int j = i; j < s.size(); j++) {
                if(s[i] == s[j]) {
                    if(j - i <= 1) {
                        dp[i][j] = true;
                    } else if(dp[i + 1] == dp[j - 1]) {
                        dp[i][j] = true;
                    }
                }
                if(dp[i][j] && j - i + 1 > maxLenth) {
                    maxLenth = j - i + 1;
                    left = i;
                    right = j;
                }
            }
        }
        return s.substr(left, maxLenth);
    }
};
```
```c++
class Solution {
    int left = 0, right = 0, maxLen = 0;
    void extend(string s, int i, int j, int n) {
        while(i >= 0 && j < n &&s[i] == s[j]) {
            if(j - i + 1 > maxLen) {
                left = i;
                right = j;
                maxLen = j - i + 1;
            }
            i--;
            j++;
        }
    }
public:
    string longestPalindrome(string s) {
        
        int result = 0;
        for(int i = 0; i < s.size(); i++) {
            extend(s, i, i, s.size());
            extend(s, i, i + 1, s.size());
        }
        return s.substr(left, maxLen);
    }
};
```
### 46. 全排列 回溯 * 迭代 * 优化空间
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {

    }
};
```
```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res(1);
        vector<int> tmp;

        for (auto i : nums) {
            for (int j = res.size()-1; j >= 0; --j) {
                for (int k = 0; k < res[j].size(); ++k) {
                    tmp = res[j];
                    tmp.insert(tmp.begin()+k, 1, i);
                    res.emplace_back(tmp);
                }
                res[j].emplace_back(i);
            }
        }
        return res;
    }
};
```
#### 23. 合并K个升序链表
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

    }
};
```
#### 31. 下一个排列
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。
```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {

    }
};
```
### 300. 最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        
    }
};
```

#### 199. 二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {

    }
};
```
#### 20. 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
```c++
class Solution {
public:
    bool isValid(string s) {

    }
};
```
#### 102. 二叉树的层序遍历
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

    }
};
```
#### 143. 重排链表
给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```c++
class Solution {
public:
    void reorderList(ListNode* head) {

    }
};
```