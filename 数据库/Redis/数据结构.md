### SDS
```
struct sdshdr{
//int 记录buf数组中未使用字节的数量 如上图free为0代表未使用字节的数量为0
int free;
//int 记录buf数组中已使用字节的数量即sds的长度 如上图len为5代表未使用字节的数量为5
int len;
//字节数组用于保存字符串 sds遵循了c字符串以空字符结尾的惯例目的是为了重用c字符串函数库里的函数
char buf[];
}
```
#### SDS优点
* 通过空间预分配策略，杜绝了缓冲区溢出；惰性空间释放，减少了修改字符串长度时所需的内存重分配次数；
* 使用len属性的值而不是空字符来判断字符串是否结束，保证了二进制安全；
* 获取字符串长度的复杂为O(1);
* 遵循以空字符结尾的惯例，因此兼容部门C字符串函数
#### 空间预分配-杜绝缓冲区溢出
当执行字符串增长操作并且需要扩展内存时，程序不仅仅会给SDS分配必需的空间还会分配额外的未使用空间，其长度存到free属性中。其分配策略如下:

如果修改后len长度将小于1M,这时分配给free的大小和len一样,例如修改过后为10字节, 那么给free也是10字节，buf实际长度变成了10+10+1 = 21byte

如果修改后len长度将大于等于1M,这时分配给free的长度为1M,例如修改过后为30M,那么给free是1M.buf实际长度变成了30M+1M+1byte

#### 惰性空间释放
惰性空间释放用于字符串缩短的操作。当字符串缩短是，程序并不是立即使用内存重分配来回收缩短出来的字节，而是使用free属性记录起来，并等待将来使用。

#### 二进制安全

C字符串的函数会把'\0'当做结束符来处理，而忽略到后面的"String"
而SDS的buf字节数组不是在保存字符，而是一系列二进制数组，SDS API都会以二进制的方式来处理buf数组里的数据，使用len属性的值而不是空字符来判断字符串是否结束

#### Redis在获取字符串长度上的时间复杂度为常数级O(1)

#### 由于SDS遵循以空字符结尾的惯例，因此兼容部门C字符串函数

### 链表
```
typedef struct listNode
{ 
	// 前置节点 
	struct listNode *prev; 
	// 后置节点 
	struct listNode *next; 
	// 节点的值 
	void *value; 
} listNode;

```

#### Redis链表结构其主要特性如下:

* 双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1);
* 无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点;
* 带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1);
* 带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1);

多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。

在列表对象常用的操作中双向链表具有优势；

双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)；

这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表！

### 整数集合 INT SET
整数集合(intset)并不是一个基础的数据结构
而是Redis自己设计的一种存储结构，是集合键的底层实现之一
当一个集合只包含整数值元素,并且这个集合的元素数量不多时, Redis就会使用整数集合作为集合键的底层实现。
#### 总结：
* 整数集合是Redis自己设计的一种存储结构,集合键的底层实现之一。
* 整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。
* 升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。
* 整数集合只支持升级操作,不支持降级操作
```
//每个intset结构表示一个整数集合
typedef struct intset{
//编码方式
uint32_t encoding;
//集合中包含的元素数量
uint32_t length;
//保存元素的数组
int8_t contents[];
} intset;
```
#### 整数集合的升级
* 整数集合升级过程：
根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间。
将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变。
将新元素添加到底层数组里面。
#### 整数集合升级的优点：
* 提升灵活性：
因为C语言是静态类型语言,为了避免类型错误,我们通常不会将两种不同类型的值放在同一个数据结构里面。
例如,我们一般只使用int16_t类型的数组来保存int16_t类型的值,只使用int32_t类型的数组来保存int32_t类型的值,诸如此类。
但是,因为整数集合可以通过自动升级底层数组来适应新元素,所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中,而不必担心出现类型错误,这种做法非常灵活。
* 节约内存：
要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值,最简单的做法就是直接使用int64t类型的数组作为整数集合的底层实现。
不过这样一来,即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值,数组都需要使用int64_t类型的空间去保存它们,从而出现浪费内存的情况。
而整数集合现在的做法既可以让集合能同时保存三种不同类型的值,又可以确保升级操作只会在有需要的时候进行,这可以尽量节省内存。
如果我们一直只向整数集合添加int16_t类型的值,那么整数集合的底层实现就会一直是int16_t类型的数组
只有在我们要将int32_t类型或者int64_t类型的值添加到集合时,程序才会对数组进行升级
* 整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态。

### 字典
```
typedef struct dict{
//类型特定函数
void *type;
//私有数据
void *privdata;
//哈希表-见2.1.2
dictht ht[2];
//rehash 索引 当rehash不在进行时 值为-1
int trehashidx;
}dict;
```
#### 总结
* 字典在redis中广泛应用，包括数据库和hash数据结构。 
* 每个字典有两个哈希表，一个是正常使用，一个用于rehash期间使用。 
* 当redis计算哈希时，采用的是MurmurHash2哈希算法。 
* 哈希表采用链表法解决散列冲突，被分配到同一个地址的键会构成一个单向链表： 
* Redis使用链表法解决散列冲突，每个散列表节点都有一个next指针 
* 多个散列表节点next可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来； 
* 在rehash对哈希表进行扩展或者收缩过程中，会将所有键值对进行迁移，并且这个迁移是渐进式的迁移。

散列表的负载因子 = 填入表中的元素个数/散列表的长度
散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。
对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降；
而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费；
* 因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash；
* 散列表的rehash过程类似于数组的收缩与扩容。

* rehash操作需要满足以下条件:
服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。
服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。
当负载因子小于0.1时，程序自动开始执行收缩操作。
Redis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。

* 扩容
为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成
当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中
当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表
每次插入一个数据到散列表，都重复上面的过程
经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了
这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了


#### 压缩列表
* 压缩列表(zip1ist)是列表和哈希的底层实现之一。

* 当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。

* 当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现

#### 总结：
* 压缩列表是Redis为节约内存自己设计的一种顺序型数据结构。 
* 压缩列表被用作列表键和哈希键的底层实现之一。 
* 压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。 
* 添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。



