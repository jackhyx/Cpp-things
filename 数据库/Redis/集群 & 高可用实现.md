## Redis 如何实现服务高可用？

### 主从复制
### 哨兵模式
* 哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。
### 切片集群模式

* 当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。
* Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中
* 哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：
  平均分配： 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。
  手动分配： 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 主从复制是怎么实现的
* 如果服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的；
* 如果这台服务器的硬盘出现了故障，可能数据就都丢失了。
* 要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。


* 服务器 B 执行这条命令
```
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>
接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。
```

所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的
#### 第一次同步
主从服务器间的第一次同步的过程可分为三个阶段：

* 第一阶段是建立链接、协商同步；
* 第二阶段是主服务器同步数据给从服务器；
* 第三阶段是主服务器发送新写操作命令给从服务器。

#### 命令传播
* 主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。
* 长连接，目的是避免频繁的 TCP 连接和断开带来的性能开销。

#### 分摊主服务器的压力
从服务器可以有自己的从服务器，我们可以把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器
主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器。

我们在「从服务器」上执行下面这条命令，使其作为目标服务器的从服务器：
```
replicaof <目标服务器的IP> 6379
```
* 此时如果目标服务器本身也是「从服务器」，那么该目标服务器就会成为「经理」的角色，不仅可以接受主服务器同步的数据，
* 也会把数据同步给自己旗下的从服务器，从而减轻主服务器的负担

#### 增量复制
* 从 Redis 2.8 开始，网络断开又恢复后，主从服务器会采用增量复制的方式继续同步
* 即只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。
* 主服务器怎么知道要将哪些增量数据发送给从服务器呢？
  repl_backlog_buffer，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据；
  replication offset，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，
  主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。
* 那repl_backlog_buffer 缓冲区是什么时候写入的呢？

  在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。

  网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：

  如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用增量同步的方式；
  相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用全量同步的方式。


### 面试题
#### redis主从节点时长连接还是短链接？
* 长连接

####  怎么判断 redis 某个节点是否正常工作？
* redis 判断接点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。

####  redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：

* redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。
* redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，
  实时监测主从节点网络状态；
  上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。

####  主从复制架构中，过期key如何处理？
* 主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。

####  redis 是同步复制还是异步复制？
* redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。

####  主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？
* replication buffer 、repl backlog buffer 区别如下：
  replication buffer 是在全量复制阶段会出现，主库会给每个新连接的从库，分配一个 replication buffer；
  repl backlog buffer 是在增量复制阶段出现，一个主库只分配一个repl backlog buffer；
  这两个 Buffer 都有大小限制的，当缓冲区满了之后。repl backlog buffer，因为是环形结构，会直接覆盖起始位置数据，
  replication buffer则会导致连接断开，删除缓存，从库重新连接，重新开始全量复制。

#### redis 主从切换如何减少数据丢失？
* 异步复制同步丢失
* 对于 redis 主节点与从节点之间的数据复制，是异步复制的，当客户端发送写请求给主节点的时候，客户端会返回 ok，
* 接着主节点将写请求异步同步给各个从节点，但是如果此时主节点还没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失。

可以有 2 种解决方案：
* 客户端将数据暂时写入本地缓存和磁盘中，在一段时间后将本地缓存或者磁盘的数据发送给主节点，来保证数据不丢失；
* 客户端将数据写入到消息队列中，发送一个延时消费消息，比如10分钟后再消费消息队列中的数据，然后再写到主节点。

#### 集群产生脑裂数据丢失
先来理解集群的脑裂现象，这就好比一个人有两个大脑，那么到底受谁控制呢？

#### 那么在 redis 中，集群脑裂产生数据丢失的现象是怎样的呢？
在 redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。
如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。
这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了 —— 脑裂出现了。
这时候网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。

* 由于网络问题，集群节点之间失去联系。主从数据不同步；
* 重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，
* 再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。

#### 解决方案：
* 当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。

在 redis 的配置文件中有两个参数我们可以设置：

min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。
min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。
我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。

这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。

即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了。

等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。我再来给你举个例子。

假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。

#### redis 主从如何做到故障自动切换？
主节点挂了 ，从节点是无法自动升级为主节点的，这个过程需要人工处理，在此期间 redis 无法对外提供写操作。

此时，redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性。