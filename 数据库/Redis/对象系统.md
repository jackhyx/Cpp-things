Redis对象系统：

Redis中的每个对象都由一个redisObject结构表示

该结构中和保存数据有关的三个属性分别是type属性、 encoding属性和ptr属性:

Redis使用对象来表示数据库中的键和值,每次当我们在Redis的数据库中新创建一个键值对时,我们至少会创建两个对象,一个对象用作键值对的健(键对象),另一个对象用作键值对的值(值对象)。

结构or实现：
typedef struct redisObiect{
	//类型
	unsigned type:4;
	//编码
	unsigned encoding:4;
	//指向底层数据结构的指针
	void *ptr;
}

 其中Redis的键对象都是字符串对象，而Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种。



总结：
Redis基于底层的一些数据结构创建了一个对象系统以供用户使用

这个系统主要包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象

Redis的键对象都是字符串对象

Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种

为了可以自由改进内部编码，以及在不同场景下发挥其最大优势，Redis中的对象，大都是通过多种数据结构来实现
#### 字符串

#### 内部实现

* 字符串对象底层的数据结构实现主要是int和简单动态字符串SDS; 
* 字符串对象的内部编码有3种 ：int、raw和embstr。Redis会根据当前值的类型和长度来决定使用哪种编码来实现

#### 字符串对象保存：整数值
可以用long类型来表示
字符串对象会将整数值保存在字符串对象结构的ptr属性里面(将void*转换成1ong)
将字符串对象的编码设置为int

#### 字符串对象保存：字符串值
* 字符串值的长度大于32字节、使用一个简单动态字符串(SDS)保存、将对象的编码设置为raw

* 字符申值的长度小于等于32字节、字符串对象将使用一个简单动态字符串(SDS)来保存、将对象的编码设置为embstr

#### embstr优点：
* embstr编码是专门用于保存短字符串的一种优化编码方式
embstr和raw编码都会使用SDS来保存值
不同之处：embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS；
raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS；

embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次
释放 embstr编码的字符串对象同样只需要调用一次内存释放函数
因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能

#### 常用命令
设置值-set
获取-get
批量设置-MSET
批量获取-MGET


#### 使用场景
* 作为缓存层
Redis经常作为缓存层，来缓存一些热点数据。来加速读写性能从而降低后端的压力。一般在读取数据的时候会先从Redis中读取，如果Redis中没有，再从数据库中读取。
* 计数器\限速器\分布式ID
主要是利用Redis字符串自增自减的特性。
计数器：经常可以被用来做计数器，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。
限速器：如验证码接口访问频率限制，用户登陆时需要让用户输入手机验证码，从而确定是否是用户本人，但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。
分布式ID：由于Redis自增自减的操作是原子性的因此也经常在分布式系统中用来生成唯一的订单号、序列号等
* 分布式系统共享session
*  二进制存储
由于Redis字符串可以存储二进制数据的特性，因此也可以用来存储一些二进制数据。如图片、 音频、 视频等

### 哈希

#### 内部实现

* 哈希类型的内部编码有两种：ziplist(压缩列表),hashtable(哈希表)。
* 只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：
  当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）
  所有值都小于hash-max-ziplist-value配置（默认64字节）
* ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。
  当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。

#### 使用场景
* 存储对象 ： Redis哈希对象常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等。
* 购物车
很多电商网站都会使用 cookie实现购物车，也就是将整个购物车都存储到 cookie里面。
这种做法的一大优点:无须对数据库进行写入就可以实现购物车功能,这种方式大大提高了购物车的性能
而缺点则是程序需要重新解析和验证( validate) cookie,确保cookie的格式正确,并且包含的商品都是真正可购买的商品
cookie购物车还有一个缺点:因为浏览器每次发送请求都会连 cookie一起发送,所以如果购物车cookie的体积比较大,那么请求发送和处理的速度可能会有所降低。
购物车的定义非常简单:我们以每个用户的用户ID(或者CookieId)作为Redis的Key,每个用户的购物车都是一个哈希表,这个哈希表存储了商品ID与商品订购数量之间的映射。
* 计数器
Redis哈希表作为计数器的使用也非常广泛，它常常被用在记录网站每一天、一月、一年的访问数量。


### Bitmap
* SETBIT <key> <offset> <value>
* GETBIT <key> <offset>
#### 使用场景
* 用户每个月的签到情况
key 可以设计成 uid:sign:{userId}:{yyyyMM}，月份的每一天的值 - 1 可以作为 offset（因为 offset 从 0 开始，所以 offset = 日期 - 1）。
```
BITPOS key bitValue [start] [end]
```
返回数据表示 Bitmap 中第一个值为 bitValue 的 offset 位置。
* 连续签到用户总数
我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。
与操作 :
``` BITOP AND destmap bitmap:01 bitmap:02 bitmap:03```
统计 bit 位 =  1 的个数 : 
```BITCOUNT destmap```

#### Redis自定义参数的布隆过滤器

Redis还提供了自定义参数的布隆过滤器，想要尽量减少布隆过滤器的误判，就要设置合理的参数。

在使用bf.add命令添加元素之前，使用bf.reserve命令创建一个自定义的布隆过滤器。

bf.reserve命令有三个参数，分别是：

* key：键

* error_rate：期望错误率，期望错误率越低，需要的空间就越大。

* capacity：初始容量，当实际元素的数量超过这个初始化容量时，误判率上升。

示例如下：
127.0.0.1:6379> BF.RESERVE customFilter 0.0001 600000
OK
如果对应的key已经存在时，在执行bf.reserve命令就会报错。如果不使用bf.reserve命令创建，而是使用Redis自动创建的布隆过滤器，默认的error_rate是 0.0001，capacity是 60。
布隆过滤器的error_rate越小，需要的存储空间就越大，对于不需要过于精确的场景，error_rate设置稍大一点也可以。
布隆过滤器的capacity设置的过大，会浪费存储空间，设置的过小，就会影响准确率，所以在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出设置值很多。
总之，error_rate和 capacity都需要设置一个合适的数值。

在哈希函数的个数k一定的情况下：

* 位数组长度m越大，误判率越低；
* 已插入元素的个数n越大，误判率越高。
