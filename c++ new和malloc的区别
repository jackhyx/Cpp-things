new和malloc的区别

## new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；

## 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

## new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符;
而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

## new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

## new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。
delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

new/new[]和delete/delete的实现原理
ew/new[]、delete/delete[]区别
delete/delete[]是如何知道释放内存的大小

new简单类型直接调用operator new分配内存；
而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；

具体过程：
#new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间
#编译器运行相应的构造函数以构造这些对象，并为其传入初始值;
#对象被分配了空间并构造完成，返回一个指向该对象的指;
#new动态数组返回的并不是数组类型，而是一个元素类型的指针;

delete简单数据类型默认只是调用free函数；
复杂数据类型先调用析构函数再调用operator delete；

对于简单类型，new[]计算好大小后调用operator new；

对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；
需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小
在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了


针对简单类型，delete和delete[]等同
假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存
delete[]时，数组中的元素按逆序的顺序进行销毁；

### 而使用delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。

new-delete
new[]-delete[]
配对使用；
