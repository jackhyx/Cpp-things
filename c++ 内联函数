## 为什么要引入内联函数（内联函数的作用）

用它替代宏定义，消除宏定义的缺点
宏定义使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测
另外它的返回值不能被强制转换为可转换的合适类型，且C++中引入了类及类的访问控制，在涉及到类的保护成员和私有成员就不能用宏定义来操作

# 内联函数与宏定义的区别：

内联函数在编译时展开，可以做一些类型检测处理，宏在预编译时展开；
内联函数直接嵌入到目标代码中，宏是简单的做文本替换。
C++中引入了类及类的访问控制，在涉及到类的保护成员和私有成员就不能用宏定义来操作

# inline相比宏定义有哪些优越处

inline函数代码是被放到符号表中，使用时像宏一样展开# 没有调用的开销，效率很高 #
inline函数是真正的函数，所以要进行一系列的数据类型检查；
inline函数作为类的成员函数，可以使用类的保护成员及私有成员；

# 为什么不能把所有的函数写成inline函数

内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率
所以一方面如果# 内联函数体内代码执行时间相比函数调用开销大# 没有太大的意义；
另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数。
函数体内有循环，函数执行时间要比函数调用开销大；

另外两点需要注意：
内联函数时无法获取其地址的。
内联函数不可以做为虚函数（内联函数，构造函数，静态函数时都不能为虚函数的）

所以要讲inline的作用，可以从两方面考虑：
相比普通函数的效率
相比宏定义

# 类中的构造函数和析构函数可以是内联的吗

effective里面说，构造函数和析构函数往往是inlining的糟糕候选人
因为编译器在编译期间会给你的构造函数和析构函数额外加入很多的代码，像成员函数的构造析构等代码，所以通常构造析构函数比表面上看起来的要多，并不适合作为内联函数。

inline很重要的一个缺点是：inline造成代码膨胀会导致额外的换页行为，降低指令高速缓存装置的命中率，以及伴随这些而来的效率降低 
