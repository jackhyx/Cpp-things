### CPA ：一个分布式系统不可能同时满足一致性，可用性和分区容错性这三个基本需求，最多只能同时满足其中的2个
* *C（Consistence）*	一致性，指数据在多个副本之间能够保持一致的特性（严格的一致性）。
* *A（Availability）* 可用性，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。
* *P（Network partitioning）* 分区容错性，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。

分区：在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。**从而导致了整个系统的环境被切分成了若干个孤立的区域。**

### BASE：既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。
* *Basically Available*(基本可用) 假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言；**有响应时间上的损失和功能上的损失**
* *Soft state*（软状态） 相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。 而软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即**允许系统在多个不同节点的数据副本存在数据延时**
* *Eventually consistent*（最终一致性）系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。

#### 在实际工程实践中，最终一致性分为 5 种：

* 因果一致性（Causal consistency） ：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。

* 读己之所写（Read your writes） :节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。

* 会话一致性（Session consistency） :对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。

* 单调读一致性（Monotonic read consistency） :指如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。

* 单调写一致性（Monotonic write consistency） :指一个系统要能够保证来自同一个节点的写操作被顺序的执行。

**然而，在实际的实践中，这 5 种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。**

### 二阶段提交协议，简称 2PC。二阶段提交就是讲事务的提交过程分成了两个阶段来进行处理
**2PC 阶段一**
* 事务询问:协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。

* 执行事务:各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中

* 各参与者向协调者反馈事务询问的响应:如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，就返回 No 给协调者，表示事务不可以执行。

**2PC 阶段二** 
在阶段二中，会根据阶段一的投票结果执行 2 种操作：执行事务提交，中断事务。

**执行事务提交步骤如下：**
* 发送提交请求：协调者向所有参与者发出 commit 请求。
* 事务提交：参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。
* 反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 信息。
* 协调者接收到所有参与者反馈的 Ack 信息后，完成事务。

**中断事务步骤如下：**
* 发送回滚请求：协调者向所有参与者发出 Rollback 请求。
* 事务回滚：参与者接收到 Rollback 请求后，会利用其在阶段一种记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
* 反馈事务回滚结果：参与者在完成事务回滚之后，想协调者发送 Ack 信息。
* 中断事务：协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。

### 优点缺点
* 优点：原理简单，实现方便
* **缺点：同步阻塞，单点问题，数据不一致，过于保守**
* 同步阻塞：在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。
* 单点问题：协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的是：其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。
* 数据不一致：假设当协调者向所有的参与者发送 commti 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有 commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问题。
* 过于保守：如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的化，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。

### 3PC，全称 “three phase commit”，是 2PC 的改进版，其将 2PC 的 “提交事务请求” 过程一分为二。
**3PC 阶段一：CanCommit**
* 事务询问：协调者向所有的参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
* 各参与者向协调者反馈事务询问的响应：参与者接收来自协调者的 canCommit 请求，如果参与者认为自己可以顺利执行事务，就返回 Yes，否则反馈 No 响应。

**3PC 阶段二：PreCommit**

*协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。*
*执行事务预提交分为 3 个步骤：*
* 发送预提交请求：协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。
* 事务预提交：参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。
* 各参与者向协调者反馈事务执行的结果：如果参与者成功执行了事务，就反馈 Ack 响应，同时等待指令：提交（commit） 或终止（abor）。
*中断事务也分为2个步骤：*
* 发送中断请求：协调者向所有参与者节点发出 abort 请求 。
* 中断事务：参与者如果收到 abort 请求或者超时了，都会中断事务。

**3PC阶段三：do Commit**
*该阶段做真正的提交，同样也会出现两种情况：*
* 执行提交
* 发送提交请求：进入这一阶段，如果协调者正常工作，并且接收到了所有协调者的 Ack 响应，那么协调者将从 “预提交” 状态变为 “提交” 状态，并向所有的参与者发送 doCommit 请求 。
* 事务提交：参与者收到 doCommit 请求后，会正式执行事务提交操作，并在完成之后释放在整个事务执行期间占用的事务资源。
* 反馈事务提交结果：参与者完成事务提交后，向协调者发送 Ack 消息。 
* 完成事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务。
*中断事务*
* 假设有任何参与者反馈了 no 响应，或者超时了，就中断事务。

* 发送中断请求：协调者向所有的参与者节点发送 abort 请求。
* 事务回滚：参与者接收到 abort 请求后，会利用其在二阶段记录的 undo 信息来执行事务回滚操作，并在完成回滚之后释放整个事务执行期间占用的资源。
* 反馈事务回滚结果：参与者在完成事务回滚之后，想协调者发送 Ack 消息。
* 中断事务：协调者接收到所有的 Ack 消息后，中断事务。
* 注意：一旦进入阶段三，可能会出现 2 种故障：

协调者出现问题：协调者和参与者之间的网络故障
一旦出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交。

### 总结：
* 优点：相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的），并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）。
* 缺点：如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题

### Paxos 算法由图灵奖获得者 Leslie Lamport 于 1990 年提出的一种基于消息传递且具有高度容错的特性的一致性算法

### 一致性 hash 还是比较简单的。核心思想是，不使用对机器取余的算法。这样就能避免机器增减带来的影响。
### 同时，使用 就近寻址 的方式找到最近的节点。当然，这会引起负载不均衡，所以需要引入虚拟节点的方式，变相的增加节点，让整个集群的负载能够均衡